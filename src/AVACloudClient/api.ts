//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AslvConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    aslvFile: FileParameter | null | undefined,
    options: {
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      aslvFile,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
   * Converts Aslv files to Dangl.AVA projects
   * @param aslvFile (optional) The input file
   * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
   * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
   */
  convertToAva(
    aslvFile: FileParameter | null | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/aslv/ava?";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (aslvFile !== null && aslvFile !== undefined)
      content_.append(
        "aslvFile",
        aslvFile.data,
        aslvFile.fileName ? aslvFile.fileName : "aslvFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    aslvFile: FileParameter | null | undefined,
    options: {
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      aslvFile,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts Aslv files to GAEB files
     * @param aslvFile (optional) The input file
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    aslvFile: FileParameter | null | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/aslv/gaeb?";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (aslvFile !== null && aslvFile !== undefined)
      content_.append(
        "aslvFile",
        aslvFile.data,
        aslvFile.fileName ? aslvFile.fileName : "aslvFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    aslvFile: FileParameter | null | undefined,
    options: {
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      aslvFile,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts Aslv files to Excel
     * @param aslvFile (optional) The input file
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    aslvFile: FileParameter | null | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/aslv/excel?";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (aslvFile !== null && aslvFile !== undefined)
      content_.append(
        "aslvFile",
        aslvFile.data,
        aslvFile.fileName ? aslvFile.fileName : "aslvFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    aslvFile: FileParameter | null | undefined,
    options: {
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      aslvFile,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts Aslv files to Oenorm files
     * @param aslvFile (optional) The input file
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    aslvFile: FileParameter | null | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/aslv/oenorm?";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (aslvFile !== null && aslvFile !== undefined)
      content_.append(
        "aslvFile",
        aslvFile.data,
        aslvFile.fileName ? aslvFile.fileName : "aslvFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class AvaConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    avaProject: ProjectDto,
    options: {
      tryAutoGenerateItemNumbersAndSchema: boolean | undefined;
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
     * Converts Dangl.AVA projects to Dangl.AVA. This is useful when
    you want to generate the calculated properties.
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
     */
  convertToAva(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/ava/ava?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    avaProject: ProjectDto,
    options: {
      tryAutoGenerateItemNumbersAndSchema: boolean | undefined;
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts Dangl.AVA projects to GAEB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/ava/gaeb?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    avaProject: ProjectDto,
    options: {
      tryAutoGenerateItemNumbersAndSchema: boolean | undefined;
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts Dangl.AVA projects to Excel
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/ava/excel?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToRebWithRequestObject(
    avaProject: ProjectDto,
    options: {
      tryAutoGenerateItemNumbersAndSchema: boolean | undefined;
      destinationRebType: DestinationRebType | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToReb(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema,
      options.destinationRebType
    );
  }

  /**
     * Converts Dangl.AVA projects to REB
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     * @param destinationRebType (optional) Defaults to D11
     */
  convertToReb(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined,
    destinationRebType: DestinationRebType | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/ava/reb?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    if (destinationRebType === null)
      throw new Error("The parameter 'destinationRebType' cannot be null.");
    else if (destinationRebType !== undefined)
      url_ +=
        "DestinationRebType=" +
        encodeURIComponent("" + destinationRebType) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToReb(_response);
    });
  }

  protected processConvertToReb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    avaProject: ProjectDto,
    options: {
      tryAutoGenerateItemNumbersAndSchema: boolean | undefined;
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts Dangl.AVA projects to Oenorm
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/ava/oenorm?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToSiaWithRequestObject(
    avaProject: ProjectDto,
    options: { tryAutoGenerateItemNumbersAndSchema: boolean | undefined }
  ): Promise<FileResponse> {
    return this.convertToSia(
      avaProject,
      options.tryAutoGenerateItemNumbersAndSchema
    );
  }

  /**
     * Converts Dangl.AVA projects to SIA 451
     * @param avaProject The Dangl.AVA project
     * @param tryAutoGenerateItemNumbersAndSchema (optional) If this is set to true, AVACloud will try to generate item numbers
    and an item number schema automatically for the input project.
    The operation will not have any effect if either an item number schema
    is already present, or if any of the elements already has an item number.
     */
  convertToSia(
    avaProject: ProjectDto,
    tryAutoGenerateItemNumbersAndSchema: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/ava/sia?";
    if (tryAutoGenerateItemNumbersAndSchema === null)
      throw new Error(
        "The parameter 'tryAutoGenerateItemNumbersAndSchema' cannot be null."
      );
    else if (tryAutoGenerateItemNumbersAndSchema !== undefined)
      url_ +=
        "TryAutoGenerateItemNumbersAndSchema=" +
        encodeURIComponent("" + tryAutoGenerateItemNumbersAndSchema) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProject);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToSia(_response);
    });
  }

  protected processConvertToSia(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class ExcelConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    excelFile: FileParameter | null | undefined,
    options: {
      readNewElements: boolean | undefined;
      rebuildItemNumberSchema: boolean | undefined;
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      excelFile,
      options.readNewElements,
      options.rebuildItemNumberSchema,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
     * Converts Excel files to Dangl.AVA projects.
     * @param excelFile (optional) The input file
     * @param readNewElements (optional) Defaults to false
     * @param rebuildItemNumberSchema (optional) When importing new elements from Excel, sometimes the ItemNumberSchema in the file
    is not in compliance with the GAEB requirements. Enabling this option tries to repair
    the ItemNumberSchema. Defaults to false.
     * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
     */
  convertToAva(
    excelFile: FileParameter | null | undefined,
    readNewElements: boolean | undefined,
    rebuildItemNumberSchema: boolean | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/excel/ava?";
    if (readNewElements === null)
      throw new Error("The parameter 'readNewElements' cannot be null.");
    else if (readNewElements !== undefined)
      url_ +=
        "ReadNewElements=" + encodeURIComponent("" + readNewElements) + "&";
    if (rebuildItemNumberSchema === null)
      throw new Error(
        "The parameter 'rebuildItemNumberSchema' cannot be null."
      );
    else if (rebuildItemNumberSchema !== undefined)
      url_ +=
        "RebuildItemNumberSchema=" +
        encodeURIComponent("" + rebuildItemNumberSchema) +
        "&";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (excelFile !== null && excelFile !== undefined)
      content_.append(
        "excelFile",
        excelFile.data,
        excelFile.fileName ? excelFile.fileName : "excelFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    excelFile: FileParameter | null | undefined,
    options: {
      readNewElements: boolean | undefined;
      rebuildItemNumberSchema: boolean | undefined;
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      excelFile,
      options.readNewElements,
      options.rebuildItemNumberSchema,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts Excel files to GAEB files.
     * @param excelFile (optional) The input file
     * @param readNewElements (optional) Defaults to false
     * @param rebuildItemNumberSchema (optional) When importing new elements from Excel, sometimes the ItemNumberSchema in the file
    is not in compliance with the GAEB requirements. Enabling this option tries to repair
    the ItemNumberSchema. Defaults to false.
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    excelFile: FileParameter | null | undefined,
    readNewElements: boolean | undefined,
    rebuildItemNumberSchema: boolean | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/excel/gaeb?";
    if (readNewElements === null)
      throw new Error("The parameter 'readNewElements' cannot be null.");
    else if (readNewElements !== undefined)
      url_ +=
        "ReadNewElements=" + encodeURIComponent("" + readNewElements) + "&";
    if (rebuildItemNumberSchema === null)
      throw new Error(
        "The parameter 'rebuildItemNumberSchema' cannot be null."
      );
    else if (rebuildItemNumberSchema !== undefined)
      url_ +=
        "RebuildItemNumberSchema=" +
        encodeURIComponent("" + rebuildItemNumberSchema) +
        "&";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (excelFile !== null && excelFile !== undefined)
      content_.append(
        "excelFile",
        excelFile.data,
        excelFile.fileName ? excelFile.fileName : "excelFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    excelFile: FileParameter | null | undefined,
    options: {
      readNewElements: boolean | undefined;
      rebuildItemNumberSchema: boolean | undefined;
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      excelFile,
      options.readNewElements,
      options.rebuildItemNumberSchema,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts Excel files to Excel files. Used, for example, when elements
    were added in excel to generate or modify a project. The Excel file can then
    be shared containing the full project with all formattings, formulas and styles applied.
     * @param excelFile (optional) The input file
     * @param readNewElements (optional) Defaults to false
     * @param rebuildItemNumberSchema (optional) When importing new elements from Excel, sometimes the ItemNumberSchema in the file
    is not in compliance with the GAEB requirements. Enabling this option tries to repair
    the ItemNumberSchema. Defaults to false.
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    excelFile: FileParameter | null | undefined,
    readNewElements: boolean | undefined,
    rebuildItemNumberSchema: boolean | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/excel/excel?";
    if (readNewElements === null)
      throw new Error("The parameter 'readNewElements' cannot be null.");
    else if (readNewElements !== undefined)
      url_ +=
        "ReadNewElements=" + encodeURIComponent("" + readNewElements) + "&";
    if (rebuildItemNumberSchema === null)
      throw new Error(
        "The parameter 'rebuildItemNumberSchema' cannot be null."
      );
    else if (rebuildItemNumberSchema !== undefined)
      url_ +=
        "RebuildItemNumberSchema=" +
        encodeURIComponent("" + rebuildItemNumberSchema) +
        "&";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (excelFile !== null && excelFile !== undefined)
      content_.append(
        "excelFile",
        excelFile.data,
        excelFile.fileName ? excelFile.fileName : "excelFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    excelFile: FileParameter | null | undefined,
    options: {
      readNewElements: boolean | undefined;
      rebuildItemNumberSchema: boolean | undefined;
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      excelFile,
      options.readNewElements,
      options.rebuildItemNumberSchema,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts Excel files to Oenorm files.
     * @param excelFile (optional) The input file
     * @param readNewElements (optional) Defaults to false
     * @param rebuildItemNumberSchema (optional) When importing new elements from Excel, sometimes the ItemNumberSchema in the file
    is not in compliance with the GAEB requirements. Enabling this option tries to repair
    the ItemNumberSchema. Defaults to false.
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    excelFile: FileParameter | null | undefined,
    readNewElements: boolean | undefined,
    rebuildItemNumberSchema: boolean | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/excel/oenorm?";
    if (readNewElements === null)
      throw new Error("The parameter 'readNewElements' cannot be null.");
    else if (readNewElements !== undefined)
      url_ +=
        "ReadNewElements=" + encodeURIComponent("" + readNewElements) + "&";
    if (rebuildItemNumberSchema === null)
      throw new Error(
        "The parameter 'rebuildItemNumberSchema' cannot be null."
      );
    else if (rebuildItemNumberSchema !== undefined)
      url_ +=
        "RebuildItemNumberSchema=" +
        encodeURIComponent("" + rebuildItemNumberSchema) +
        "&";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (excelFile !== null && excelFile !== undefined)
      content_.append(
        "excelFile",
        excelFile.data,
        excelFile.fileName ? excelFile.fileName : "excelFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class GaebConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  /*  convertToAvaWithRequestObject(gaebFile: FileParameter | null | undefined, options: { supportSkippedItemNumberLevelsInPositions: boolean | undefined, removePlainTextLongTexts: boolean | undefined, removeHtmlLongTexts: boolean | undefined }): Promise<ProjectDto> {
      return this.convertToAva(gaebFile, options.supportSkippedItemNumberLevelsInPositions, options.removePlainTextLongTexts, options.removeHtmlLongTexts,);
    } */

  /**
     * Converts GAEB files to Dangl.AVA projects
     * @param gaebFile (optional) The input file
     * @param supportSkippedItemNumberLevelsInPositions (optional) Defaults to 'false'. This controls if, when deserializing GAEB files, skipped levels in position
    item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group
    levels and one position levels - but the ItemNumber of the position is just '01.02', then it will be
    displayed as '01.__.02' if this is set to true.
     * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
     */
  convertToAva(
    gaebFile: FileParameter | null | undefined,
    supportSkippedItemNumberLevelsInPositions: boolean | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined,
    accessToken: string
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/gaeb/ava?";
    if (supportSkippedItemNumberLevelsInPositions === null)
      throw new Error(
        "The parameter 'supportSkippedItemNumberLevelsInPositions' cannot be null."
      );
    else if (supportSkippedItemNumberLevelsInPositions !== undefined)
      url_ +=
        "SupportSkippedItemNumberLevelsInPositions=" +
        encodeURIComponent("" + supportSkippedItemNumberLevelsInPositions) +
        "&";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (gaebFile !== null && gaebFile !== undefined)
      content_.append(
        "gaebFile",
        gaebFile.data,
        gaebFile.fileName ? gaebFile.fileName : "gaebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
        Authorization: `Bearer ${accessToken}`, // add the Authorization header with the access token
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    gaebFile: FileParameter | null | undefined,
    options: {
      supportSkippedItemNumberLevelsInPositions: boolean | undefined;
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      gaebFile,
      options.supportSkippedItemNumberLevelsInPositions,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts GAEB files to GAEB files. Used for example when
    transforming or repairing GAEB files.
     * @param gaebFile (optional) The input file
     * @param supportSkippedItemNumberLevelsInPositions (optional) Defaults to 'false'. This controls if, when deserializing GAEB files, skipped levels in position
    item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group
    levels and one position levels - but the ItemNumber of the position is just '01.02', then it will be
    displayed as '01.__.02' if this is set to true.
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    gaebFile: FileParameter | null | undefined,
    supportSkippedItemNumberLevelsInPositions: boolean | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/gaeb/gaeb?";
    if (supportSkippedItemNumberLevelsInPositions === null)
      throw new Error(
        "The parameter 'supportSkippedItemNumberLevelsInPositions' cannot be null."
      );
    else if (supportSkippedItemNumberLevelsInPositions !== undefined)
      url_ +=
        "SupportSkippedItemNumberLevelsInPositions=" +
        encodeURIComponent("" + supportSkippedItemNumberLevelsInPositions) +
        "&";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (gaebFile !== null && gaebFile !== undefined)
      content_.append(
        "gaebFile",
        gaebFile.data,
        gaebFile.fileName ? gaebFile.fileName : "gaebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    gaebFile: FileParameter | null | undefined,
    options: {
      supportSkippedItemNumberLevelsInPositions: boolean | undefined;
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      gaebFile,
      options.supportSkippedItemNumberLevelsInPositions,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts GAEB files to Excel
     * @param gaebFile (optional) The input file
     * @param supportSkippedItemNumberLevelsInPositions (optional) Defaults to 'false'. This controls if, when deserializing GAEB files, skipped levels in position
    item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group
    levels and one position levels - but the ItemNumber of the position is just '01.02', then it will be
    displayed as '01.__.02' if this is set to true.
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    gaebFile: FileParameter | null | undefined,
    supportSkippedItemNumberLevelsInPositions: boolean | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/gaeb/excel?";
    if (supportSkippedItemNumberLevelsInPositions === null)
      throw new Error(
        "The parameter 'supportSkippedItemNumberLevelsInPositions' cannot be null."
      );
    else if (supportSkippedItemNumberLevelsInPositions !== undefined)
      url_ +=
        "SupportSkippedItemNumberLevelsInPositions=" +
        encodeURIComponent("" + supportSkippedItemNumberLevelsInPositions) +
        "&";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (gaebFile !== null && gaebFile !== undefined)
      content_.append(
        "gaebFile",
        gaebFile.data,
        gaebFile.fileName ? gaebFile.fileName : "gaebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    gaebFile: FileParameter | null | undefined,
    options: {
      supportSkippedItemNumberLevelsInPositions: boolean | undefined;
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      gaebFile,
      options.supportSkippedItemNumberLevelsInPositions,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts GAEB files to Oenorm files
     * @param gaebFile (optional) The input file
     * @param supportSkippedItemNumberLevelsInPositions (optional) Defaults to 'false'. This controls if, when deserializing GAEB files, skipped levels in position
    item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group
    levels and one position levels - but the ItemNumber of the position is just '01.02', then it will be
    displayed as '01.__.02' if this is set to true.
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    gaebFile: FileParameter | null | undefined,
    supportSkippedItemNumberLevelsInPositions: boolean | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/gaeb/oenorm?";
    if (supportSkippedItemNumberLevelsInPositions === null)
      throw new Error(
        "The parameter 'supportSkippedItemNumberLevelsInPositions' cannot be null."
      );
    else if (supportSkippedItemNumberLevelsInPositions !== undefined)
      url_ +=
        "SupportSkippedItemNumberLevelsInPositions=" +
        encodeURIComponent("" + supportSkippedItemNumberLevelsInPositions) +
        "&";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (gaebFile !== null && gaebFile !== undefined)
      content_.append(
        "gaebFile",
        gaebFile.data,
        gaebFile.fileName ? gaebFile.fileName : "gaebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class OenormConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    oenormFile: FileParameter | null | undefined,
    options: {
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      oenormFile,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
   * Converts Ã–Norm files to Dangl.AVA projects
   * @param oenormFile (optional) The input file
   * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
   * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
   */
  convertToAva(
    oenormFile: FileParameter | null | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/oenorm/ava?";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (oenormFile !== null && oenormFile !== undefined)
      content_.append(
        "oenormFile",
        oenormFile.data,
        oenormFile.fileName ? oenormFile.fileName : "oenormFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    oenormFile: FileParameter | null | undefined,
    options: {
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      oenormFile,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts Ã–Norm files to GAEB files.
     * @param oenormFile (optional) The input file
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    oenormFile: FileParameter | null | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/oenorm/gaeb?";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (oenormFile !== null && oenormFile !== undefined)
      content_.append(
        "oenormFile",
        oenormFile.data,
        oenormFile.fileName ? oenormFile.fileName : "oenormFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    oenormFile: FileParameter | null | undefined,
    options: {
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      oenormFile,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts Ã–Norm files to Excel
     * @param oenormFile (optional) The input file
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    oenormFile: FileParameter | null | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/oenorm/excel?";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (oenormFile !== null && oenormFile !== undefined)
      content_.append(
        "oenormFile",
        oenormFile.data,
        oenormFile.fileName ? oenormFile.fileName : "oenormFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    oenormFile: FileParameter | null | undefined,
    options: {
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      oenormFile,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts Ã–Norm files to Oenorm files.
     * @param oenormFile (optional) The input file
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    oenormFile: FileParameter | null | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/oenorm/oenorm?";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (oenormFile !== null && oenormFile !== undefined)
      content_.append(
        "oenormFile",
        oenormFile.data,
        oenormFile.fileName ? oenormFile.fileName : "oenormFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class RebConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    rebFile: FileParameter | null | undefined,
    options: {
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      rebFile,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
   * Converts REB files to Dangl.AVA projects
   * @param rebFile (optional) The input file
   * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
   * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
   */
  convertToAva(
    rebFile: FileParameter | null | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/reb/ava?";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (rebFile !== null && rebFile !== undefined)
      content_.append(
        "rebFile",
        rebFile.data,
        rebFile.fileName ? rebFile.fileName : "rebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    rebFile: FileParameter | null | undefined,
    options: {
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      rebFile,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts REB files to GAEB files
     * @param rebFile (optional) The input file
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    rebFile: FileParameter | null | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/reb/gaeb?";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (rebFile !== null && rebFile !== undefined)
      content_.append(
        "rebFile",
        rebFile.data,
        rebFile.fileName ? rebFile.fileName : "rebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    rebFile: FileParameter | null | undefined,
    options: {
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      rebFile,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts REB files to Excel
     * @param rebFile (optional) The input file
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    rebFile: FileParameter | null | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/reb/excel?";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (rebFile !== null && rebFile !== undefined)
      content_.append(
        "rebFile",
        rebFile.data,
        rebFile.fileName ? rebFile.fileName : "rebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    rebFile: FileParameter | null | undefined,
    options: {
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      rebFile,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts REB files to Oenorm
     * @param rebFile (optional) The input file
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    rebFile: FileParameter | null | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/reb/oenorm?";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (rebFile !== null && rebFile !== undefined)
      content_.append(
        "rebFile",
        rebFile.data,
        rebFile.fileName ? rebFile.fileName : "rebFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class SiaConversionClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToAvaWithRequestObject(
    siaFile: FileParameter | null | undefined,
    options: {
      removePlainTextLongTexts: boolean | undefined;
      removeHtmlLongTexts: boolean | undefined;
    }
  ): Promise<ProjectDto> {
    return this.convertToAva(
      siaFile,
      options.removePlainTextLongTexts,
      options.removeHtmlLongTexts
    );
  }

  /**
   * Converts SIA 451 files to Dangl.AVA projects
   * @param siaFile (optional) The input file
   * @param removePlainTextLongTexts (optional) If set to true, plain text long texts will be removed from the output to reduce response sizes
   * @param removeHtmlLongTexts (optional) If set to true, html long texts will be removed from the output to reduce response sizes
   */
  convertToAva(
    siaFile: FileParameter | null | undefined,
    removePlainTextLongTexts: boolean | undefined,
    removeHtmlLongTexts: boolean | undefined
  ): Promise<ProjectDto> {
    let url_ = this.baseUrl + "/conversion/sia/ava?";
    if (removePlainTextLongTexts === null)
      throw new Error(
        "The parameter 'removePlainTextLongTexts' cannot be null."
      );
    else if (removePlainTextLongTexts !== undefined)
      url_ +=
        "RemovePlainTextLongTexts=" +
        encodeURIComponent("" + removePlainTextLongTexts) +
        "&";
    if (removeHtmlLongTexts === null)
      throw new Error("The parameter 'removeHtmlLongTexts' cannot be null.");
    else if (removeHtmlLongTexts !== undefined)
      url_ +=
        "RemoveHtmlLongTexts=" +
        encodeURIComponent("" + removeHtmlLongTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (siaFile !== null && siaFile !== undefined)
      content_.append(
        "siaFile",
        siaFile.data,
        siaFile.fileName ? siaFile.fileName : "siaFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/vnd.com.dangl-it.ProjectDto.v1+json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToAva(_response);
    });
  }

  protected processConvertToAva(response: Response): Promise<ProjectDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ProjectDto.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ProjectDto>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToGaebWithRequestObject(
    siaFile: FileParameter | null | undefined,
    options: {
      destinationGaebType: DestinationGaebType | undefined;
      targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined;
      enforceStrictOfferPhaseLongTextOutput: boolean | undefined;
      exportQuantityDetermination: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
      forceIncludeDescriptions: boolean | undefined;
      treatNullItemNumberSchemaAsInvalid: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToGaeb(
      siaFile,
      options.destinationGaebType,
      options.targetExchangePhaseTransform,
      options.enforceStrictOfferPhaseLongTextOutput,
      options.exportQuantityDetermination,
      options.removeUnprintableCharactersFromTexts,
      options.forceIncludeDescriptions,
      options.treatNullItemNumberSchemaAsInvalid
    );
  }

  /**
     * Converts SIA 451 files to GAEB files
     * @param siaFile (optional) The input file
     * @param destinationGaebType (optional) Defaults to GAEB XML V3.2
     * @param targetExchangePhaseTransform (optional) Defaults to none, meaning no transformation will be done
     * @param enforceStrictOfferPhaseLongTextOutput (optional) Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
    be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
    is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param exportQuantityDetermination (optional) Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
    'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
    quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
    'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
    this might export data that was not intended to be exported, like internal quantity calculation details,
    depending on what data you put in the 'QuantityComponents' property.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     * @param forceIncludeDescriptions (optional) If this is enabled, all description elements like texts and execution descriptions will be output
    to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
    typically not include descriptions.
     * @param treatNullItemNumberSchemaAsInvalid (optional) When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
    With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
    and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
    reasons.
     */
  convertToGaeb(
    siaFile: FileParameter | null | undefined,
    destinationGaebType: DestinationGaebType | undefined,
    targetExchangePhaseTransform: DestinationGaebExchangePhase | undefined,
    enforceStrictOfferPhaseLongTextOutput: boolean | undefined,
    exportQuantityDetermination: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined,
    forceIncludeDescriptions: boolean | undefined,
    treatNullItemNumberSchemaAsInvalid: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/sia/gaeb?";
    if (destinationGaebType === null)
      throw new Error("The parameter 'destinationGaebType' cannot be null.");
    else if (destinationGaebType !== undefined)
      url_ +=
        "DestinationGaebType=" +
        encodeURIComponent("" + destinationGaebType) +
        "&";
    if (targetExchangePhaseTransform === null)
      throw new Error(
        "The parameter 'targetExchangePhaseTransform' cannot be null."
      );
    else if (targetExchangePhaseTransform !== undefined)
      url_ +=
        "TargetExchangePhaseTransform=" +
        encodeURIComponent("" + targetExchangePhaseTransform) +
        "&";
    if (enforceStrictOfferPhaseLongTextOutput === null)
      throw new Error(
        "The parameter 'enforceStrictOfferPhaseLongTextOutput' cannot be null."
      );
    else if (enforceStrictOfferPhaseLongTextOutput !== undefined)
      url_ +=
        "EnforceStrictOfferPhaseLongTextOutput=" +
        encodeURIComponent("" + enforceStrictOfferPhaseLongTextOutput) +
        "&";
    if (exportQuantityDetermination === null)
      throw new Error(
        "The parameter 'exportQuantityDetermination' cannot be null."
      );
    else if (exportQuantityDetermination !== undefined)
      url_ +=
        "ExportQuantityDetermination=" +
        encodeURIComponent("" + exportQuantityDetermination) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    if (forceIncludeDescriptions === null)
      throw new Error(
        "The parameter 'forceIncludeDescriptions' cannot be null."
      );
    else if (forceIncludeDescriptions !== undefined)
      url_ +=
        "ForceIncludeDescriptions=" +
        encodeURIComponent("" + forceIncludeDescriptions) +
        "&";
    if (treatNullItemNumberSchemaAsInvalid === null)
      throw new Error(
        "The parameter 'treatNullItemNumberSchemaAsInvalid' cannot be null."
      );
    else if (treatNullItemNumberSchemaAsInvalid !== undefined)
      url_ +=
        "TreatNullItemNumberSchemaAsInvalid=" +
        encodeURIComponent("" + treatNullItemNumberSchemaAsInvalid) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (siaFile !== null && siaFile !== undefined)
      content_.append(
        "siaFile",
        siaFile.data,
        siaFile.fileName ? siaFile.fileName : "siaFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToGaeb(_response);
    });
  }

  protected processConvertToGaeb(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToExcelWithRequestObject(
    siaFile: FileParameter | null | undefined,
    options: {
      writePrices: boolean | undefined;
      writeLongTexts: boolean | undefined;
      conversionCulture: string | null | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToExcel(
      siaFile,
      options.writePrices,
      options.writeLongTexts,
      options.conversionCulture
    );
  }

  /**
     * Converts SIA 451 files to Excel
     * @param siaFile (optional) The input file
     * @param writePrices (optional) Defaults to true
     * @param writeLongTexts (optional) Defaults to true
     * @param conversionCulture (optional) The culture that should be used for the conversion process, to have
    localized Excel files
     */
  convertToExcel(
    siaFile: FileParameter | null | undefined,
    writePrices: boolean | undefined,
    writeLongTexts: boolean | undefined,
    conversionCulture: string | null | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/sia/excel?";
    if (writePrices === null)
      throw new Error("The parameter 'writePrices' cannot be null.");
    else if (writePrices !== undefined)
      url_ += "WritePrices=" + encodeURIComponent("" + writePrices) + "&";
    if (writeLongTexts === null)
      throw new Error("The parameter 'writeLongTexts' cannot be null.");
    else if (writeLongTexts !== undefined)
      url_ += "WriteLongTexts=" + encodeURIComponent("" + writeLongTexts) + "&";
    if (conversionCulture !== undefined && conversionCulture !== null)
      url_ +=
        "ConversionCulture=" + encodeURIComponent("" + conversionCulture) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (siaFile !== null && siaFile !== undefined)
      content_.append(
        "siaFile",
        siaFile.data,
        siaFile.fileName ? siaFile.fileName : "siaFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToExcel(_response);
    });
  }

  protected processConvertToExcel(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  convertToOenormWithRequestObject(
    siaFile: FileParameter | null | undefined,
    options: {
      destinationOenormType: DestinationOenormType | undefined;
      tryRepairProjectStructure: boolean | undefined;
      skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined;
      removeUnprintableCharactersFromTexts: boolean | undefined;
    }
  ): Promise<FileResponse> {
    return this.convertToOenorm(
      siaFile,
      options.destinationOenormType,
      options.tryRepairProjectStructure,
      options.skipTryEnforceSchemaCompliantXmlOutput,
      options.removeUnprintableCharactersFromTexts
    );
  }

  /**
     * Converts SIA 451 files to Oenorm files
     * @param siaFile (optional) The input file
     * @param destinationOenormType (optional) Defaults to Lv2015
     * @param tryRepairProjectStructure (optional) Defaults to false. If this is enabled, the converter will try to ensure that the project structure
    can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param skipTryEnforceSchemaCompliantXmlOutput (optional) If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
    based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
    can be disabled with this option.
     * @param removeUnprintableCharactersFromTexts (optional) If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
    might fail in case some text content contains characters that are not allowed in XML output formats.
     */
  convertToOenorm(
    siaFile: FileParameter | null | undefined,
    destinationOenormType: DestinationOenormType | undefined,
    tryRepairProjectStructure: boolean | undefined,
    skipTryEnforceSchemaCompliantXmlOutput: boolean | undefined,
    removeUnprintableCharactersFromTexts: boolean | undefined
  ): Promise<FileResponse> {
    let url_ = this.baseUrl + "/conversion/sia/oenorm?";
    if (destinationOenormType === null)
      throw new Error("The parameter 'destinationOenormType' cannot be null.");
    else if (destinationOenormType !== undefined)
      url_ +=
        "DestinationOenormType=" +
        encodeURIComponent("" + destinationOenormType) +
        "&";
    if (tryRepairProjectStructure === null)
      throw new Error(
        "The parameter 'tryRepairProjectStructure' cannot be null."
      );
    else if (tryRepairProjectStructure !== undefined)
      url_ +=
        "TryRepairProjectStructure=" +
        encodeURIComponent("" + tryRepairProjectStructure) +
        "&";
    if (skipTryEnforceSchemaCompliantXmlOutput === null)
      throw new Error(
        "The parameter 'skipTryEnforceSchemaCompliantXmlOutput' cannot be null."
      );
    else if (skipTryEnforceSchemaCompliantXmlOutput !== undefined)
      url_ +=
        "SkipTryEnforceSchemaCompliantXmlOutput=" +
        encodeURIComponent("" + skipTryEnforceSchemaCompliantXmlOutput) +
        "&";
    if (removeUnprintableCharactersFromTexts === null)
      throw new Error(
        "The parameter 'removeUnprintableCharactersFromTexts' cannot be null."
      );
    else if (removeUnprintableCharactersFromTexts !== undefined)
      url_ +=
        "RemoveUnprintableCharactersFromTexts=" +
        encodeURIComponent("" + removeUnprintableCharactersFromTexts) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (siaFile !== null && siaFile !== undefined)
      content_.append(
        "siaFile",
        siaFile.data,
        siaFile.fileName ? siaFile.fileName : "siaFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConvertToOenorm(_response);
    });
  }

  protected processConvertToOenorm(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get("content-disposition")
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1
            ? fileNameMatch[1]
            : undefined;
      }
      return response.blob().then((blob) => {
        return {
          fileName: fileName,
          data: blob,
          status: status,
          headers: _headers,
        };
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class StatusClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * Reports the health status of the AVACloud API
   */
  getStatus(): Promise<GetStatus> {
    let url_ = this.baseUrl + "/status";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetStatus(_response);
    });
  }

  protected processGetStatus(response: Response): Promise<GetStatus> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = GetStatus.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<GetStatus>(null as any);
  }
}

export class ValidationClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  validateFileWithRequestObject(
    avaFile: FileParameter | null | undefined,
    options: { fileValidationSourceType: FileValidationSourceType | undefined }
  ): Promise<ValidationResult> {
    return this.validateFile(avaFile, options.fileValidationSourceType);
  }

  /**
     * This endpoint validates AVA files, typically GAEB or Ã–Norm. The type of file needs to be provided
    as a query parameter, since there is no auto detection of the uploaded file type.
     * @param avaFile (optional) The file to validate
     * @param fileValidationSourceType (optional) You need to indicate which type of file is being provided, there is no auto detection mechanism
     */
  validateFile(
    avaFile: FileParameter | null | undefined,
    fileValidationSourceType: FileValidationSourceType | undefined
  ): Promise<ValidationResult> {
    let url_ = this.baseUrl + "/validation/file?";
    if (fileValidationSourceType === null)
      throw new Error(
        "The parameter 'fileValidationSourceType' cannot be null."
      );
    else if (fileValidationSourceType !== undefined)
      url_ +=
        "fileValidationSourceType=" +
        encodeURIComponent("" + fileValidationSourceType) +
        "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (avaFile !== null && avaFile !== undefined)
      content_.append(
        "avaFile",
        avaFile.data,
        avaFile.fileName ? avaFile.fileName : "avaFile"
      );

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValidateFile(_response);
    });
  }

  protected processValidateFile(response: Response): Promise<ValidationResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ValidationResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ValidationResult>(null as any);
  }

  /**
     * This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase
    into account and do some general project validation. Optionally, a conversion to a desired target can also
    be done, in which case the target file will also be validated.
     * @param avaProjectValidationSourceOptions The options used for the validation operation
     */
  validateProject(
    avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions
  ): Promise<ValidationResult> {
    let url_ = this.baseUrl + "/validation/project";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(avaProjectValidationSourceOptions);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processValidateProject(_response);
    });
  }

  protected processValidateProject(
    response: Response
  ): Promise<ValidationResult> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ValidationResult.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<ValidationResult>(null as any);
  }
}

export class DanglIdentityClient {
  private http: {
    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
  };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(
    baseUrl?: string,
    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
  ) {
    this.http = http ? http : (window as any);
    this.baseUrl =
      baseUrl !== undefined && baseUrl !== null
        ? baseUrl
        : "https://avacloud-api.dangl-it.com";
  }

  /**
   * This is a generated method that accepts an options object, it simply calls the generated method with the parameter list
   */
  loginWithCookieWithRequestObject(
    model: LoginPost,
    options: { redirectUrl: string | null | undefined }
  ): Promise<void> {
    return this.loginWithCookie(model, options.redirectUrl);
  }

  loginWithCookie(
    model: LoginPost,
    redirectUrl: string | null | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/identity/login?";
    if (redirectUrl !== undefined && redirectUrl !== null)
      url_ += "redirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginWithCookie(_response);
    });
  }

  protected processLoginWithCookie(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signOutWithSignInManager(): Promise<void> {
    let url_ = this.baseUrl + "/identity/login";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      headers: {},
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignOutWithSignInManager(_response);
    });
  }

  protected processSignOutWithSignInManager(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  loginAndReturnToken(model: TokenLoginPost): Promise<TokenResponseGet> {
    let url_ = this.baseUrl + "/identity/token-login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLoginAndReturnToken(_response);
    });
  }

  protected processLoginAndReturnToken(
    response: Response
  ): Promise<TokenResponseGet> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TokenResponseGet.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = TokenResponseGet.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TokenResponseGet>(null as any);
  }

  refreshToken(model: TokenRefreshPost): Promise<TokenResponseGet> {
    let url_ = this.baseUrl + "/identity/token-refresh";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRefreshToken(_response);
    });
  }

  protected processRefreshToken(response: Response): Promise<TokenResponseGet> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = TokenResponseGet.fromJS(resultData200);
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = TokenResponseGet.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<TokenResponseGet>(null as any);
  }

  register(registerModel: RegisterPost): Promise<void> {
    let url_ = this.baseUrl + "/identity/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(registerModel);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRegister(_response);
    });
  }

  protected processRegister(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        let resultData400 =
          _responseText === ""
            ? null
            : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ApiError.fromJS(resultData400);
        return throwException(
          "A server side error occurred.",
          status,
          _responseText,
          _headers,
          result400
        );
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }

  requestPasswordReset(forgotPasswordModel: ForgotPasswordPost): Promise<void> {
    let url_ = this.baseUrl + "/identity/password-forgotten";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(forgotPasswordModel);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRequestPasswordReset(_response);
    });
  }

  protected processRequestPasswordReset(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && response.headers.forEach) {
      response.headers.forEach((v: any, k: any) => (_headers[k] = v));
    }
    if (status === 204) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException(
          "An unexpected server error occurred.",
          status,
          _responseText,
          _headers
        );
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

/** A Project contains all relevant information for a construction project. */
export class ProjectDto implements IProjectDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This property controls the accuracy of all price properties, meaning how many decimal places are preserved in calculations. It defaults to DEFAULT_PRICE_ACCURACY. Please see the Dangl.AVA documentation for further information about decimal precision. */
  priceAccuracy!: number;
  /** This forces total prices to be the strict product of quantities times unit price in positions. It is enabled by default. If this is disabled, both the unit price and the total price of positions is calculated from the non-rounded values. Please see the documentation for a more detailed explanation of this setting. */
  forceStrictTotals!: boolean;
  /** This property controls the rounding mode of all price properties, meaning how rounding of decimal places is performed in price calculations. It defaults to DEFAULT_ROUNDING_MODE. Please see the Dangl.AVA documentation for further information about decimal precision. */
  priceRoundingMode!: PriceRoundingModeDto;
  /** The ProjectInformation contains information that describes the project and its structure. */
  projectInformation?: ProjectInformationDto | undefined;
  /** The ServiceSpecifications in this Project. */
  serviceSpecifications?: ServiceSpecificationDto[] | undefined;
  /** This is used to store the GAEB XML Id within this Project. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;

  constructor(data?: IProjectDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.priceAccuracy = _data["priceAccuracy"];
      this.forceStrictTotals = _data["forceStrictTotals"];
      this.priceRoundingMode = _data["priceRoundingMode"];
      this.projectInformation = _data["projectInformation"]
        ? ProjectInformationDto.fromJS(_data["projectInformation"])
        : <any>undefined;
      if (Array.isArray(_data["serviceSpecifications"])) {
        this.serviceSpecifications = [] as any;
        for (let item of _data["serviceSpecifications"])
          this.serviceSpecifications!.push(
            ServiceSpecificationDto.fromJS(item)
          );
      }
      this.gaebXmlId = _data["gaebXmlId"];
    }
  }

  static fromJS(data: any): ProjectDto {
    data = typeof data === "object" ? data : {};
    let result = new ProjectDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["priceAccuracy"] = this.priceAccuracy;
    data["forceStrictTotals"] = this.forceStrictTotals;
    data["priceRoundingMode"] = this.priceRoundingMode;
    data["projectInformation"] = this.projectInformation
      ? this.projectInformation.toJSON()
      : <any>undefined;
    if (Array.isArray(this.serviceSpecifications)) {
      data["serviceSpecifications"] = [];
      for (let item of this.serviceSpecifications)
        data["serviceSpecifications"].push(item.toJSON());
    }
    data["gaebXmlId"] = this.gaebXmlId;
    return data;
  }
}

/** A Project contains all relevant information for a construction project. */
export interface IProjectDto {
  /** Elements GUID identifier. */
  id: string;
  /** This property controls the accuracy of all price properties, meaning how many decimal places are preserved in calculations. It defaults to DEFAULT_PRICE_ACCURACY. Please see the Dangl.AVA documentation for further information about decimal precision. */
  priceAccuracy: number;
  /** This forces total prices to be the strict product of quantities times unit price in positions. It is enabled by default. If this is disabled, both the unit price and the total price of positions is calculated from the non-rounded values. Please see the documentation for a more detailed explanation of this setting. */
  forceStrictTotals: boolean;
  /** This property controls the rounding mode of all price properties, meaning how rounding of decimal places is performed in price calculations. It defaults to DEFAULT_ROUNDING_MODE. Please see the Dangl.AVA documentation for further information about decimal precision. */
  priceRoundingMode: PriceRoundingModeDto;
  /** The ProjectInformation contains information that describes the project and its structure. */
  projectInformation?: ProjectInformationDto | undefined;
  /** The ServiceSpecifications in this Project. */
  serviceSpecifications?: ServiceSpecificationDto[] | undefined;
  /** This is used to store the GAEB XML Id within this Project. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
}

/** This enum configures rounding modes for price calculations in projects */
export enum PriceRoundingModeDto {
  Normal = "Normal",
  Floor = "Floor",
  Ceiling = "Ceiling",
}

/** General information about a Project. */
export class ProjectInformationDto implements IProjectInformationDto {
  /** Information about the buyer. */
  buyer?: PartyInformationDto | undefined;
  /** Description for the project. */
  description?: string | undefined;
  /** Short description for the project. */
  descriptionShort?: string | undefined;
  /** Name of the project. */
  name?: string | undefined;
  /** Information about the site. */
  site?: PartyInformationDto | undefined;
  /** The ItemNumberSchema used in the project. */
  itemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** Short label for the currency used. */
  currencyShort?: string | undefined;
  /** Full label of the currency used. */
  currencyLong?: string | undefined;
  /** Label for the labour time part of prices used in the project. */
  labourTimeLabel?: string | undefined;
  /** Labels for the price components used in the project. Caution: Removal of a price component will trigger to have dependent price informations be deleted in IElements that use this property. If this property is changed or altered after the project has already been used, it is strongly advised to do operations step by step, e.g. if renaming and reordering multiple price components, this should be done one by one. Otherwise, a combination of rename and reordering will not be correctly propagated downwards to child objects in this Project. */
  priceComponents?: string[] | undefined;
  /** This dictionary specifies actual types used for the PriceComponents. For example, a single price component might have the name 'Material' as a string, ans this dictionary would then have a key 'Material' and a value of Materials. You can not add keys here that are not also present in the PriceComponents property, and removing price components will also remove them from this dictionary here. */
  readonly priceComponentTypes?:
    | { [key: string]: PriceComponentTypeDto }
    | undefined;
  /** This bool indicates if this project allows the bidder to add bidder comments. Bidder comments are a way to attach clarifying information when submitting an offer. */
  bidderCommentAllowed!: boolean;
  /** This property indicates if the project should allow side offers from contractors. In GAEB, a side offer would typically be in exchange phase 85. */
  sideOffersAllowed!: boolean;
  /** This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard */
  awardType!: AwardTypeDto;
  /** This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary */
  specialAwardKind!: SpecialAwardKindDto;

  constructor(data?: IProjectInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.buyer = _data["buyer"]
        ? PartyInformationDto.fromJS(_data["buyer"])
        : <any>undefined;
      this.description = _data["description"];
      this.descriptionShort = _data["descriptionShort"];
      this.name = _data["name"];
      this.site = _data["site"]
        ? PartyInformationDto.fromJS(_data["site"])
        : <any>undefined;
      this.itemNumberSchema = _data["itemNumberSchema"]
        ? ItemNumberSchemaDto.fromJS(_data["itemNumberSchema"])
        : <any>undefined;
      this.currencyShort = _data["currencyShort"];
      this.currencyLong = _data["currencyLong"];
      this.labourTimeLabel = _data["labourTimeLabel"];
      if (Array.isArray(_data["priceComponents"])) {
        this.priceComponents = [] as any;
        for (let item of _data["priceComponents"])
          this.priceComponents!.push(item);
      }
      if (_data["priceComponentTypes"]) {
        (<any>this).priceComponentTypes = {} as any;
        for (let key in _data["priceComponentTypes"]) {
          if (_data["priceComponentTypes"].hasOwnProperty(key))
            (<any>(<any>this).priceComponentTypes)![key] =
              _data["priceComponentTypes"][key];
        }
      }
      this.bidderCommentAllowed = _data["bidderCommentAllowed"];
      this.sideOffersAllowed = _data["sideOffersAllowed"];
      this.awardType = _data["awardType"];
      this.specialAwardKind = _data["specialAwardKind"];
    }
  }

  static fromJS(data: any): ProjectInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new ProjectInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["buyer"] = this.buyer ? this.buyer.toJSON() : <any>undefined;
    data["description"] = this.description;
    data["descriptionShort"] = this.descriptionShort;
    data["name"] = this.name;
    data["site"] = this.site ? this.site.toJSON() : <any>undefined;
    data["itemNumberSchema"] = this.itemNumberSchema
      ? this.itemNumberSchema.toJSON()
      : <any>undefined;
    data["currencyShort"] = this.currencyShort;
    data["currencyLong"] = this.currencyLong;
    data["labourTimeLabel"] = this.labourTimeLabel;
    if (Array.isArray(this.priceComponents)) {
      data["priceComponents"] = [];
      for (let item of this.priceComponents) data["priceComponents"].push(item);
    }
    if (this.priceComponentTypes) {
      data["priceComponentTypes"] = {};
      for (let key in this.priceComponentTypes) {
        if (this.priceComponentTypes.hasOwnProperty(key))
          (<any>data["priceComponentTypes"])[key] = (<any>(
            this.priceComponentTypes
          ))[key];
      }
    }
    data["bidderCommentAllowed"] = this.bidderCommentAllowed;
    data["sideOffersAllowed"] = this.sideOffersAllowed;
    data["awardType"] = this.awardType;
    data["specialAwardKind"] = this.specialAwardKind;
    return data;
  }
}

/** General information about a Project. */
export interface IProjectInformationDto {
  /** Information about the buyer. */
  buyer?: PartyInformationDto | undefined;
  /** Description for the project. */
  description?: string | undefined;
  /** Short description for the project. */
  descriptionShort?: string | undefined;
  /** Name of the project. */
  name?: string | undefined;
  /** Information about the site. */
  site?: PartyInformationDto | undefined;
  /** The ItemNumberSchema used in the project. */
  itemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** Short label for the currency used. */
  currencyShort?: string | undefined;
  /** Full label of the currency used. */
  currencyLong?: string | undefined;
  /** Label for the labour time part of prices used in the project. */
  labourTimeLabel?: string | undefined;
  /** Labels for the price components used in the project. Caution: Removal of a price component will trigger to have dependent price informations be deleted in IElements that use this property. If this property is changed or altered after the project has already been used, it is strongly advised to do operations step by step, e.g. if renaming and reordering multiple price components, this should be done one by one. Otherwise, a combination of rename and reordering will not be correctly propagated downwards to child objects in this Project. */
  priceComponents?: string[] | undefined;
  /** This dictionary specifies actual types used for the PriceComponents. For example, a single price component might have the name 'Material' as a string, ans this dictionary would then have a key 'Material' and a value of Materials. You can not add keys here that are not also present in the PriceComponents property, and removing price components will also remove them from this dictionary here. */
  priceComponentTypes?: { [key: string]: PriceComponentTypeDto } | undefined;
  /** This bool indicates if this project allows the bidder to add bidder comments. Bidder comments are a way to attach clarifying information when submitting an offer. */
  bidderCommentAllowed: boolean;
  /** This property indicates if the project should allow side offers from contractors. In GAEB, a side offer would typically be in exchange phase 85. */
  sideOffersAllowed: boolean;
  /** This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard */
  awardType: AwardTypeDto;
  /** This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary */
  specialAwardKind: SpecialAwardKindDto;
}

/** Represents information about a party (a site or an organization). */
export class PartyInformationDto implements IPartyInformationDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This party's name. */
  name?: string | undefined;
  /** This party's street. */
  street?: string | undefined;
  /** This party's ZipCode. */
  zipCode?: string | undefined;
  /** This party's City. */
  city?: string | undefined;
  /** This party's Country. */
  country?: string | undefined;
  /** This party's Identifier. */
  identifier?: string | undefined;
  /** Remarks for this party. */
  remarks?: string | undefined;
  /** An email address for this party. */
  email?: string | undefined;
  /** A phone number for this party. */
  phone?: string | undefined;
  /** The name of a contact person. */
  contactPersonName?: string | undefined;
  /** This is an identifier related to this PartyInformation and their internal reference of the tender (or award). This might be used to assign an identifier (German "Vergabenummer") for the current project. This is typically only used in Buyer and Bidder representations and should map to the concept of "Vergabenummer" or "AwardNo" in GAEB. */
  awardIdentifier?: string | undefined;
  /** This property indicates if the party is registered within the European Economic Area. */
  isInEuropeanEconomicArea!: boolean;
  /** If this is within the European Economic Area (see IsInEuropeanEconomicArea, then as a business entity it likely has an EU VAT Id. */
  vatId?: string | undefined;
  /** The fax number for this party. */
  fax?: string | undefined;
  /** The two letter ISO country code, e.g. DE for Germany. */
  countryCode?: string | undefined;
  /** Depending on which party this class represents, it might have either a 'creditor' or 'debtor' number. This is often used in internal accounting systems. */
  creditorOrDebtorIdentifier?: string | undefined;
  /** The Global Location Number (GLN) is issued by GS1 and is intended to be a unique identifier for the physical address of a party, e.g. a business office. */
  globalLocationNumber?: string | undefined;
  /** This list contains information about bank accounts associated with this PartyInformation. It's typically used for buyers and bidders. */
  bankingInformation?: BankingInformationDto[] | undefined;

  constructor(data?: IPartyInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.street = _data["street"];
      this.zipCode = _data["zipCode"];
      this.city = _data["city"];
      this.country = _data["country"];
      this.identifier = _data["identifier"];
      this.remarks = _data["remarks"];
      this.email = _data["email"];
      this.phone = _data["phone"];
      this.contactPersonName = _data["contactPersonName"];
      this.awardIdentifier = _data["awardIdentifier"];
      this.isInEuropeanEconomicArea = _data["isInEuropeanEconomicArea"];
      this.vatId = _data["vatId"];
      this.fax = _data["fax"];
      this.countryCode = _data["countryCode"];
      this.creditorOrDebtorIdentifier = _data["creditorOrDebtorIdentifier"];
      this.globalLocationNumber = _data["globalLocationNumber"];
      if (Array.isArray(_data["bankingInformation"])) {
        this.bankingInformation = [] as any;
        for (let item of _data["bankingInformation"])
          this.bankingInformation!.push(BankingInformationDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PartyInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new PartyInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["street"] = this.street;
    data["zipCode"] = this.zipCode;
    data["city"] = this.city;
    data["country"] = this.country;
    data["identifier"] = this.identifier;
    data["remarks"] = this.remarks;
    data["email"] = this.email;
    data["phone"] = this.phone;
    data["contactPersonName"] = this.contactPersonName;
    data["awardIdentifier"] = this.awardIdentifier;
    data["isInEuropeanEconomicArea"] = this.isInEuropeanEconomicArea;
    data["vatId"] = this.vatId;
    data["fax"] = this.fax;
    data["countryCode"] = this.countryCode;
    data["creditorOrDebtorIdentifier"] = this.creditorOrDebtorIdentifier;
    data["globalLocationNumber"] = this.globalLocationNumber;
    if (Array.isArray(this.bankingInformation)) {
      data["bankingInformation"] = [];
      for (let item of this.bankingInformation)
        data["bankingInformation"].push(item.toJSON());
    }
    return data;
  }
}

/** Represents information about a party (a site or an organization). */
export interface IPartyInformationDto {
  /** Elements GUID identifier. */
  id: string;
  /** This party's name. */
  name?: string | undefined;
  /** This party's street. */
  street?: string | undefined;
  /** This party's ZipCode. */
  zipCode?: string | undefined;
  /** This party's City. */
  city?: string | undefined;
  /** This party's Country. */
  country?: string | undefined;
  /** This party's Identifier. */
  identifier?: string | undefined;
  /** Remarks for this party. */
  remarks?: string | undefined;
  /** An email address for this party. */
  email?: string | undefined;
  /** A phone number for this party. */
  phone?: string | undefined;
  /** The name of a contact person. */
  contactPersonName?: string | undefined;
  /** This is an identifier related to this PartyInformation and their internal reference of the tender (or award). This might be used to assign an identifier (German "Vergabenummer") for the current project. This is typically only used in Buyer and Bidder representations and should map to the concept of "Vergabenummer" or "AwardNo" in GAEB. */
  awardIdentifier?: string | undefined;
  /** This property indicates if the party is registered within the European Economic Area. */
  isInEuropeanEconomicArea: boolean;
  /** If this is within the European Economic Area (see IsInEuropeanEconomicArea, then as a business entity it likely has an EU VAT Id. */
  vatId?: string | undefined;
  /** The fax number for this party. */
  fax?: string | undefined;
  /** The two letter ISO country code, e.g. DE for Germany. */
  countryCode?: string | undefined;
  /** Depending on which party this class represents, it might have either a 'creditor' or 'debtor' number. This is often used in internal accounting systems. */
  creditorOrDebtorIdentifier?: string | undefined;
  /** The Global Location Number (GLN) is issued by GS1 and is intended to be a unique identifier for the physical address of a party, e.g. a business office. */
  globalLocationNumber?: string | undefined;
  /** This list contains information about bank accounts associated with this PartyInformation. It's typically used for buyers and bidders. */
  bankingInformation?: BankingInformationDto[] | undefined;
}

/** This is a class that represents the information about a bank connection. It is usually used within a PartyInformation. */
export class BankingInformationDto implements IBankingInformationDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The name of the bank. */
  name?: string | undefined;
  /** The international identifier for the bank account. */
  iban?: string | undefined;
  /** The account number. Typically no longer used since the introduction of IBAN within the SEPA area. */
  accountNumber?: string | undefined;
  /** The international bank identifier. */
  bic?: string | undefined;
  /** The routing number for the bank. Typically no longer used since the introduction of IBAN within the SEPA area. */
  routingNumber?: string | undefined;

  constructor(data?: IBankingInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.iban = _data["iban"];
      this.accountNumber = _data["accountNumber"];
      this.bic = _data["bic"];
      this.routingNumber = _data["routingNumber"];
    }
  }

  static fromJS(data: any): BankingInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new BankingInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["iban"] = this.iban;
    data["accountNumber"] = this.accountNumber;
    data["bic"] = this.bic;
    data["routingNumber"] = this.routingNumber;
    return data;
  }
}

/** This is a class that represents the information about a bank connection. It is usually used within a PartyInformation. */
export interface IBankingInformationDto {
  /** Elements GUID identifier. */
  id: string;
  /** The name of the bank. */
  name?: string | undefined;
  /** The international identifier for the bank account. */
  iban?: string | undefined;
  /** The account number. Typically no longer used since the introduction of IBAN within the SEPA area. */
  accountNumber?: string | undefined;
  /** The international bank identifier. */
  bic?: string | undefined;
  /** The routing number for the bank. Typically no longer used since the introduction of IBAN within the SEPA area. */
  routingNumber?: string | undefined;
}

/** The schema for ItemNumber's in a Project. */
export class ItemNumberSchemaDto implements IItemNumberSchemaDto {
  /** The count of tiers in the ItemNumberSchema */
  readonly totalLength!: number;
  /** The collection of tiers for this ItemNumberSchema. */
  tiers?: ItemNumberSchemaTierDto[] | undefined;
  /** The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results */
  separator?: string | undefined;
  /** This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations. */
  filler?: string | undefined;
  /** This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store Ã–Norm service specification structure types. */
  identifier?: string | undefined;
  /** This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation. */
  skipNonExistingLevelsInPositionItemNumbers!: boolean;
  /** This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations. */
  skippedTiersFiller?: string | undefined;
  /** This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false. */
  readonly schemaIsCorrectlyDefined!: boolean;

  constructor(data?: IItemNumberSchemaDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).totalLength = _data["totalLength"];
      if (Array.isArray(_data["tiers"])) {
        this.tiers = [] as any;
        for (let item of _data["tiers"])
          this.tiers!.push(ItemNumberSchemaTierDto.fromJS(item));
      }
      this.separator = _data["separator"];
      this.filler = _data["filler"];
      this.identifier = _data["identifier"];
      this.skipNonExistingLevelsInPositionItemNumbers =
        _data["skipNonExistingLevelsInPositionItemNumbers"];
      this.skippedTiersFiller = _data["skippedTiersFiller"];
      (<any>this).schemaIsCorrectlyDefined = _data["schemaIsCorrectlyDefined"];
    }
  }

  static fromJS(data: any): ItemNumberSchemaDto {
    data = typeof data === "object" ? data : {};
    let result = new ItemNumberSchemaDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["totalLength"] = this.totalLength;
    if (Array.isArray(this.tiers)) {
      data["tiers"] = [];
      for (let item of this.tiers) data["tiers"].push(item.toJSON());
    }
    data["separator"] = this.separator;
    data["filler"] = this.filler;
    data["identifier"] = this.identifier;
    data["skipNonExistingLevelsInPositionItemNumbers"] =
      this.skipNonExistingLevelsInPositionItemNumbers;
    data["skippedTiersFiller"] = this.skippedTiersFiller;
    data["schemaIsCorrectlyDefined"] = this.schemaIsCorrectlyDefined;
    return data;
  }
}

/** The schema for ItemNumber's in a Project. */
export interface IItemNumberSchemaDto {
  /** The count of tiers in the ItemNumberSchema */
  totalLength: number;
  /** The collection of tiers for this ItemNumberSchema. */
  tiers?: ItemNumberSchemaTierDto[] | undefined;
  /** The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point '.'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one '1', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results */
  separator?: string | undefined;
  /** This string is used to fill (left-pad) item numbers. For example, if a tier has a length of '4' but the given item number is '12', with a Filler of '0', then the final item number will be represented as '0'. This must be a single character string, if a value is given where the Length property does not evaluate to '1', the DEFAULT_FILLER '0' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations. */
  filler?: string | undefined;
  /** This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store Ã–Norm service specification structure types. */
  identifier?: string | undefined;
  /** This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation. */
  skipNonExistingLevelsInPositionItemNumbers: boolean;
  /** This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like '01.__.02', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations. */
  skippedTiersFiller?: string | undefined;
  /** This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false. */
  schemaIsCorrectlyDefined: boolean;
}

/** Represents information about a single Tier in an ItemNumber. */
export class ItemNumberSchemaTierDto implements IItemNumberSchemaTierDto {
  /** The (maximum) length for this tier. Will not accept a length less than 1. Defaults to 1 if length less than one is specified. */
  length!: number;
  /** This ItemNumberSchemaTier's type. */
  type!: ItemNumberTypeDto;
  /** This specifies which ItemNumberSchemaTierType this tier represents. This can be, for example, a group tier / level, a position level or a lot level. */
  tierType!: ItemNumberSchemaTierTypeDto;
  /** Indicates if this tier represents a lot. See the documentation for more information about lots. */
  readonly isLot!: boolean;
  /** This value is the increment, or step size, that should be used for new item numbers. It defaults to DEFAULT_INCREMENT, but can be changed to any other positive number greater than zero. Invalid values make this be set to one '1' */
  increment!: number;
  /** This is an optional name for the given tier */
  tierName?: string | undefined;

  constructor(data?: IItemNumberSchemaTierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.length = _data["length"];
      this.type = _data["type"];
      this.tierType = _data["tierType"];
      (<any>this).isLot = _data["isLot"];
      this.increment = _data["increment"];
      this.tierName = _data["tierName"];
    }
  }

  static fromJS(data: any): ItemNumberSchemaTierDto {
    data = typeof data === "object" ? data : {};
    let result = new ItemNumberSchemaTierDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["length"] = this.length;
    data["type"] = this.type;
    data["tierType"] = this.tierType;
    data["isLot"] = this.isLot;
    data["increment"] = this.increment;
    data["tierName"] = this.tierName;
    return data;
  }
}

/** Represents information about a single Tier in an ItemNumber. */
export interface IItemNumberSchemaTierDto {
  /** The (maximum) length for this tier. Will not accept a length less than 1. Defaults to 1 if length less than one is specified. */
  length: number;
  /** This ItemNumberSchemaTier's type. */
  type: ItemNumberTypeDto;
  /** This specifies which ItemNumberSchemaTierType this tier represents. This can be, for example, a group tier / level, a position level or a lot level. */
  tierType: ItemNumberSchemaTierTypeDto;
  /** Indicates if this tier represents a lot. See the documentation for more information about lots. */
  isLot: boolean;
  /** This value is the increment, or step size, that should be used for new item numbers. It defaults to DEFAULT_INCREMENT, but can be changed to any other positive number greater than zero. Invalid values make this be set to one '1' */
  increment: number;
  /** This is an optional name for the given tier */
  tierName?: string | undefined;
}

/** Determines the type of an ItemNumberSchema */
export enum ItemNumberTypeDto {
  Numeric = "Numeric",
  Alphanumeric = "Alphanumeric",
}

/** Specifies the type an ItemNumberSchemaTier represents. For example, a tier may indicate to be used for positions or for groups. */
export enum ItemNumberSchemaTierTypeDto {
  Undefined = "Undefined",
  Index = "Index",
  Position = "Position",
  Group = "Group",
  Lot = "Lot",
}

/** This enumeration models types of price components for better classification. */
export enum PriceComponentTypeDto {
  Unknown = "Unknown",
  Wages = "Wages",
  Materials = "Materials",
  Plant = "Plant",
  Miscellaneous = "Miscellaneous",
}

/** This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard */
export enum AwardTypeDto {
  Unspecified = "Unspecified",
  OpenProcurement = "OpenProcurement",
  ClosedProducrement = "ClosedProducrement",
  NegotiationProcurementWithoutPublicAnnouncement = "NegotiationProcurementWithoutPublicAnnouncement",
  NegotiationProcurement = "NegotiationProcurement",
  OpenCall = "OpenCall",
  SelectedCallWithoutPublicCompetition = "SelectedCallWithoutPublicCompetition",
  SelectedCall = "SelectedCall",
  DirectAward = "DirectAward",
  InternationalNATOProcurement = "InternationalNATOProcurement",
  CompetitiveDialog = "CompetitiveDialog",
}

/** This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary */
export enum SpecialAwardKindDto {
  Unspecified = "Unspecified",
  MaintenanceContract = "MaintenanceContract",
  OutlineContract = "OutlineContract",
  OutlineForMaintenanceContract = "OutlineForMaintenanceContract",
}

/** This is the base class that holds information about a whole service specification. */
export class ServiceSpecificationDto implements IServiceSpecificationDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements. */
  readonly projectHourlyWage!: number;
  /** The tax rate that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectTaxRate!: number;
  /** The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project. */
  projectPriceComponents?: string[] | undefined;
  /** The ItemNumberSchema that is used within this project. */
  projectItemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** The IElements within this ElementContainerBase. */
  elements?: IElementDto[] | undefined;
  /** The label used in the parent Project to mark labour time, e.g. "Hours" or "Stunden". */
  readonly projectLabourTimeLabel?: string | undefined;
  /** Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers. */
  readonly containsDuplicateItemNumbers!: boolean;
  /** Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers. */
  readonly containsDuplicateElementIds!: boolean;
  /** Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateItemNumbers!: boolean;
  /** Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateElementIds!: boolean;
  /** Price composition by tax rate. */
  totalPriceGrossByTaxRate?: GrossPriceComponentDto[] | undefined;
  /** Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once. */
  ignoreChildPriceUpdates!: boolean;
  /** Net price after applied deductions. */
  readonly deductedPrice!: number;
  /** Factor of applied deductions to the total price. For example, "0.03" means that a 3% deduction is to be applied. */
  deductionFactor!: number;
  /** The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum. */
  absoluteDeduction?: number | undefined;
  /** Will return this ElementContainerBase's total price. */
  readonly totalPrice!: number;
  /** The total gross price for this ElementContainerBase including all child elements. */
  readonly totalPriceGross!: number;
  /** Total gross price after applied deductions. */
  readonly totalPriceGrossDeducted!: number;
  /** Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not. */
  priceType!: PriceTypeDto;
  /** Information about the bidder. */
  bidder?: PartyInformationDto | undefined;
  /** This discriminator is used to identify different bidders in a project. It is different from the Identifier property in the Bidder in that the BidderDiscriminator is intended to be a numerical identifier within a project, while the Identifier does uniquely identify a bidder in the system independent of a specific project. This property should map to "Bieternummer" or "BidderNo" in GAEB. */
  bidderDiscriminator?: string | undefined;
  /** This is used to store the GAEB XML Id within this ServiceSpecification. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** The ProjectInformation used within the Project in which this ElementContainerBase is contained. This is reference equal to the ProjectInformation used in the parent project. */
  readonly projectInformation?: ProjectInformationDto | undefined;
  /** This service specifications exchange phase, i.e. the current status in the project it is intended to be used (such as request for offer, offer, awarding...). */
  exchangePhase!: ExchangePhaseDto;
  /** This indicates where the service specification originates, i.e. from an exchange file format or self created. If applicable, additional information is present in the OriginDetail property. */
  origin!: OriginDto;
  /** This property complements the Origin property. Some formats, e.g. GaebXml might have additional information attached, e.g. GAEB XML V3.2 oder GAEB XML V3.1. This string property is used to hold such data. The Dangl.AVA module does not have a list of possible values, since this is defined in the native format assemblies, e.g. Dangl.GAEB or Dangl.Oenorm. */
  originDetail?: string | undefined;
  /** Creation date of this ServiceSpecification. */
  creationDate?: Date | undefined;
  /** Date indicating until when an offer has to be submitted. In German, this is often called the "ErÃ¶ffnungstermin" */
  offerByDate?: Date | undefined;
  /** Date indicating by when the buyer will select a contractor. */
  decisionDate?: Date | undefined;
  /** String indicating where the physical submission of the offer is taking place. */
  submissionLocation?: string | undefined;
  /** Description of this ServiceSpecification. */
  description?: string | undefined;
  /** The name of this ServiceSpecification. */
  name?: string | undefined;
  /** This PriceInformation contains global data for the ServiceSpecification. When inside a Project, do not set this property manually. */
  priceInformation?: PriceInformationDto | undefined;
  /** These are Catalogue that are used within this ElementContainerBase. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this ElementContainerBase. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;
  /** The date when the execution of the services is scheduled to start */
  plannedExecutionStart?: Date | undefined;
  /** The date then the execution of the services is scheduled to be finished */
  plannedExecutionEnd?: Date | undefined;
  /** The date on which the contract has been awarded. This matches "Auftragsdatum" in GAEB */
  contractDate?: Date | undefined;
  /** This value can be used to indicate the number or identifier of the contract. It matches "Auftragsnummer" in GAEB */
  contractIdentifier?: string | undefined;
  /** This indicates how long the warranty period is for this ServiceSpecification */
  warrantyDuration?: WarrantyDurationDto | undefined;
  /** The date on which the warranty period ends */
  warrantyEnd?: Date | undefined;
  /** The date on which the services rendered by the bidder are scheduled to be approved by the buyer */
  approvalDate?: Date | undefined;
  /** This should specify how the approval is performed by the buyer. This matches "AcceptType" in GAEB */
  typeOfApproval?: string | undefined;
  /** This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German. */
  addendumNumber?: string | undefined;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;
  /** This property holds additional information that's only valid in commerce exchange phases. */
  commerceProperties?: ServiceSpecificationCommercePropertiesDto | undefined;

  constructor(data?: IServiceSpecificationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      (<any>this).projectHourlyWage = _data["projectHourlyWage"];
      this.projectTaxRate = _data["projectTaxRate"];
      if (Array.isArray(_data["projectPriceComponents"])) {
        this.projectPriceComponents = [] as any;
        for (let item of _data["projectPriceComponents"])
          this.projectPriceComponents!.push(item);
      }
      this.projectItemNumberSchema = _data["projectItemNumberSchema"]
        ? ItemNumberSchemaDto.fromJS(_data["projectItemNumberSchema"])
        : <any>undefined;
      if (Array.isArray(_data["elements"])) {
        this.elements = [] as any;
        for (let item of _data["elements"])
          this.elements!.push(IElementDto.fromJS(item));
      }
      (<any>this).projectLabourTimeLabel = _data["projectLabourTimeLabel"];
      (<any>this).containsDuplicateItemNumbers =
        _data["containsDuplicateItemNumbers"];
      (<any>this).containsDuplicateElementIds =
        _data["containsDuplicateElementIds"];
      this.ignoreDuplicateItemNumbers = _data["ignoreDuplicateItemNumbers"];
      this.ignoreDuplicateElementIds = _data["ignoreDuplicateElementIds"];
      if (Array.isArray(_data["totalPriceGrossByTaxRate"])) {
        this.totalPriceGrossByTaxRate = [] as any;
        for (let item of _data["totalPriceGrossByTaxRate"])
          this.totalPriceGrossByTaxRate!.push(
            GrossPriceComponentDto.fromJS(item)
          );
      }
      this.ignoreChildPriceUpdates = _data["ignoreChildPriceUpdates"];
      (<any>this).deductedPrice = _data["deductedPrice"];
      this.deductionFactor = _data["deductionFactor"];
      this.absoluteDeduction = _data["absoluteDeduction"];
      (<any>this).totalPrice = _data["totalPrice"];
      (<any>this).totalPriceGross = _data["totalPriceGross"];
      (<any>this).totalPriceGrossDeducted = _data["totalPriceGrossDeducted"];
      this.priceType = _data["priceType"];
      this.bidder = _data["bidder"]
        ? PartyInformationDto.fromJS(_data["bidder"])
        : <any>undefined;
      this.bidderDiscriminator = _data["bidderDiscriminator"];
      this.gaebXmlId = _data["gaebXmlId"];
      (<any>this).projectInformation = _data["projectInformation"]
        ? ProjectInformationDto.fromJS(_data["projectInformation"])
        : <any>undefined;
      this.exchangePhase = _data["exchangePhase"];
      this.origin = _data["origin"];
      this.originDetail = _data["originDetail"];
      this.creationDate = _data["creationDate"]
        ? new Date(_data["creationDate"].toString())
        : <any>undefined;
      this.offerByDate = _data["offerByDate"]
        ? new Date(_data["offerByDate"].toString())
        : <any>undefined;
      this.decisionDate = _data["decisionDate"]
        ? new Date(_data["decisionDate"].toString())
        : <any>undefined;
      this.submissionLocation = _data["submissionLocation"];
      this.description = _data["description"];
      this.name = _data["name"];
      this.priceInformation = _data["priceInformation"]
        ? PriceInformationDto.fromJS(_data["priceInformation"])
        : <any>undefined;
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      if (Array.isArray(_data["catalogueReferences"])) {
        this.catalogueReferences = [] as any;
        for (let item of _data["catalogueReferences"])
          this.catalogueReferences!.push(CatalogueReferenceDto.fromJS(item));
      }
      this.plannedExecutionStart = _data["plannedExecutionStart"]
        ? new Date(_data["plannedExecutionStart"].toString())
        : <any>undefined;
      this.plannedExecutionEnd = _data["plannedExecutionEnd"]
        ? new Date(_data["plannedExecutionEnd"].toString())
        : <any>undefined;
      this.contractDate = _data["contractDate"]
        ? new Date(_data["contractDate"].toString())
        : <any>undefined;
      this.contractIdentifier = _data["contractIdentifier"];
      this.warrantyDuration = _data["warrantyDuration"]
        ? WarrantyDurationDto.fromJS(_data["warrantyDuration"])
        : <any>undefined;
      this.warrantyEnd = _data["warrantyEnd"]
        ? new Date(_data["warrantyEnd"].toString())
        : <any>undefined;
      this.approvalDate = _data["approvalDate"]
        ? new Date(_data["approvalDate"].toString())
        : <any>undefined;
      this.typeOfApproval = _data["typeOfApproval"];
      this.addendumNumber = _data["addendumNumber"];
      this.addendumStatus = _data["addendumStatus"];
      this.commerceProperties = _data["commerceProperties"]
        ? ServiceSpecificationCommercePropertiesDto.fromJS(
            _data["commerceProperties"]
          )
        : <any>undefined;
    }
  }

  static fromJS(data: any): ServiceSpecificationDto {
    data = typeof data === "object" ? data : {};
    let result = new ServiceSpecificationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["projectHourlyWage"] = this.projectHourlyWage;
    data["projectTaxRate"] = this.projectTaxRate;
    if (Array.isArray(this.projectPriceComponents)) {
      data["projectPriceComponents"] = [];
      for (let item of this.projectPriceComponents)
        data["projectPriceComponents"].push(item);
    }
    data["projectItemNumberSchema"] = this.projectItemNumberSchema
      ? this.projectItemNumberSchema.toJSON()
      : <any>undefined;
    if (Array.isArray(this.elements)) {
      data["elements"] = [];
      for (let item of this.elements) data["elements"].push(item.toJSON());
    }
    data["projectLabourTimeLabel"] = this.projectLabourTimeLabel;
    data["containsDuplicateItemNumbers"] = this.containsDuplicateItemNumbers;
    data["containsDuplicateElementIds"] = this.containsDuplicateElementIds;
    data["ignoreDuplicateItemNumbers"] = this.ignoreDuplicateItemNumbers;
    data["ignoreDuplicateElementIds"] = this.ignoreDuplicateElementIds;
    if (Array.isArray(this.totalPriceGrossByTaxRate)) {
      data["totalPriceGrossByTaxRate"] = [];
      for (let item of this.totalPriceGrossByTaxRate)
        data["totalPriceGrossByTaxRate"].push(item.toJSON());
    }
    data["ignoreChildPriceUpdates"] = this.ignoreChildPriceUpdates;
    data["deductedPrice"] = this.deductedPrice;
    data["deductionFactor"] = this.deductionFactor;
    data["absoluteDeduction"] = this.absoluteDeduction;
    data["totalPrice"] = this.totalPrice;
    data["totalPriceGross"] = this.totalPriceGross;
    data["totalPriceGrossDeducted"] = this.totalPriceGrossDeducted;
    data["priceType"] = this.priceType;
    data["bidder"] = this.bidder ? this.bidder.toJSON() : <any>undefined;
    data["bidderDiscriminator"] = this.bidderDiscriminator;
    data["gaebXmlId"] = this.gaebXmlId;
    data["projectInformation"] = this.projectInformation
      ? this.projectInformation.toJSON()
      : <any>undefined;
    data["exchangePhase"] = this.exchangePhase;
    data["origin"] = this.origin;
    data["originDetail"] = this.originDetail;
    data["creationDate"] = this.creationDate
      ? this.creationDate.toISOString()
      : <any>undefined;
    data["offerByDate"] = this.offerByDate
      ? this.offerByDate.toISOString()
      : <any>undefined;
    data["decisionDate"] = this.decisionDate
      ? this.decisionDate.toISOString()
      : <any>undefined;
    data["submissionLocation"] = this.submissionLocation;
    data["description"] = this.description;
    data["name"] = this.name;
    data["priceInformation"] = this.priceInformation
      ? this.priceInformation.toJSON()
      : <any>undefined;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    if (Array.isArray(this.catalogueReferences)) {
      data["catalogueReferences"] = [];
      for (let item of this.catalogueReferences)
        data["catalogueReferences"].push(item.toJSON());
    }
    data["plannedExecutionStart"] = this.plannedExecutionStart
      ? this.plannedExecutionStart.toISOString()
      : <any>undefined;
    data["plannedExecutionEnd"] = this.plannedExecutionEnd
      ? this.plannedExecutionEnd.toISOString()
      : <any>undefined;
    data["contractDate"] = this.contractDate
      ? this.contractDate.toISOString()
      : <any>undefined;
    data["contractIdentifier"] = this.contractIdentifier;
    data["warrantyDuration"] = this.warrantyDuration
      ? this.warrantyDuration.toJSON()
      : <any>undefined;
    data["warrantyEnd"] = this.warrantyEnd
      ? this.warrantyEnd.toISOString()
      : <any>undefined;
    data["approvalDate"] = this.approvalDate
      ? this.approvalDate.toISOString()
      : <any>undefined;
    data["typeOfApproval"] = this.typeOfApproval;
    data["addendumNumber"] = this.addendumNumber;
    data["addendumStatus"] = this.addendumStatus;
    data["commerceProperties"] = this.commerceProperties
      ? this.commerceProperties.toJSON()
      : <any>undefined;
    return data;
  }
}

/** This is the base class that holds information about a whole service specification. */
export interface IServiceSpecificationDto {
  /** Elements GUID identifier. */
  id: string;
  /** The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectHourlyWage: number;
  /** The tax rate that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectTaxRate: number;
  /** The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project. */
  projectPriceComponents?: string[] | undefined;
  /** The ItemNumberSchema that is used within this project. */
  projectItemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** The IElements within this ElementContainerBase. */
  elements?: IElementDto[] | undefined;
  /** The label used in the parent Project to mark labour time, e.g. "Hours" or "Stunden". */
  projectLabourTimeLabel?: string | undefined;
  /** Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers. */
  containsDuplicateItemNumbers: boolean;
  /** Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers. */
  containsDuplicateElementIds: boolean;
  /** Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateItemNumbers: boolean;
  /** Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateElementIds: boolean;
  /** Price composition by tax rate. */
  totalPriceGrossByTaxRate?: GrossPriceComponentDto[] | undefined;
  /** Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once. */
  ignoreChildPriceUpdates: boolean;
  /** Net price after applied deductions. */
  deductedPrice: number;
  /** Factor of applied deductions to the total price. For example, "0.03" means that a 3% deduction is to be applied. */
  deductionFactor: number;
  /** The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum. */
  absoluteDeduction?: number | undefined;
  /** Will return this ElementContainerBase's total price. */
  totalPrice: number;
  /** The total gross price for this ElementContainerBase including all child elements. */
  totalPriceGross: number;
  /** Total gross price after applied deductions. */
  totalPriceGrossDeducted: number;
  /** Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not. */
  priceType: PriceTypeDto;
  /** Information about the bidder. */
  bidder?: PartyInformationDto | undefined;
  /** This discriminator is used to identify different bidders in a project. It is different from the Identifier property in the Bidder in that the BidderDiscriminator is intended to be a numerical identifier within a project, while the Identifier does uniquely identify a bidder in the system independent of a specific project. This property should map to "Bieternummer" or "BidderNo" in GAEB. */
  bidderDiscriminator?: string | undefined;
  /** This is used to store the GAEB XML Id within this ServiceSpecification. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** The ProjectInformation used within the Project in which this ElementContainerBase is contained. This is reference equal to the ProjectInformation used in the parent project. */
  projectInformation?: ProjectInformationDto | undefined;
  /** This service specifications exchange phase, i.e. the current status in the project it is intended to be used (such as request for offer, offer, awarding...). */
  exchangePhase: ExchangePhaseDto;
  /** This indicates where the service specification originates, i.e. from an exchange file format or self created. If applicable, additional information is present in the OriginDetail property. */
  origin: OriginDto;
  /** This property complements the Origin property. Some formats, e.g. GaebXml might have additional information attached, e.g. GAEB XML V3.2 oder GAEB XML V3.1. This string property is used to hold such data. The Dangl.AVA module does not have a list of possible values, since this is defined in the native format assemblies, e.g. Dangl.GAEB or Dangl.Oenorm. */
  originDetail?: string | undefined;
  /** Creation date of this ServiceSpecification. */
  creationDate?: Date | undefined;
  /** Date indicating until when an offer has to be submitted. In German, this is often called the "ErÃ¶ffnungstermin" */
  offerByDate?: Date | undefined;
  /** Date indicating by when the buyer will select a contractor. */
  decisionDate?: Date | undefined;
  /** String indicating where the physical submission of the offer is taking place. */
  submissionLocation?: string | undefined;
  /** Description of this ServiceSpecification. */
  description?: string | undefined;
  /** The name of this ServiceSpecification. */
  name?: string | undefined;
  /** This PriceInformation contains global data for the ServiceSpecification. When inside a Project, do not set this property manually. */
  priceInformation?: PriceInformationDto | undefined;
  /** These are Catalogue that are used within this ElementContainerBase. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this ElementContainerBase. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;
  /** The date when the execution of the services is scheduled to start */
  plannedExecutionStart?: Date | undefined;
  /** The date then the execution of the services is scheduled to be finished */
  plannedExecutionEnd?: Date | undefined;
  /** The date on which the contract has been awarded. This matches "Auftragsdatum" in GAEB */
  contractDate?: Date | undefined;
  /** This value can be used to indicate the number or identifier of the contract. It matches "Auftragsnummer" in GAEB */
  contractIdentifier?: string | undefined;
  /** This indicates how long the warranty period is for this ServiceSpecification */
  warrantyDuration?: WarrantyDurationDto | undefined;
  /** The date on which the warranty period ends */
  warrantyEnd?: Date | undefined;
  /** The date on which the services rendered by the bidder are scheduled to be approved by the buyer */
  approvalDate?: Date | undefined;
  /** This should specify how the approval is performed by the buyer. This matches "AcceptType" in GAEB */
  typeOfApproval?: string | undefined;
  /** This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German. */
  addendumNumber?: string | undefined;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;
  /** This property holds additional information that's only valid in commerce exchange phases. */
  commerceProperties?: ServiceSpecificationCommercePropertiesDto | undefined;
}

/** Base interface definition for elements within an ElementContainerBase. */
export abstract class IElementDto implements IIElementDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This is used to store the GAEB XML Id within this IElement. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German. */
  addendumNumber?: string | undefined;
  projectCatalogues?: CatalogueDto[] | undefined;
  catalogueReferences?: CatalogueReferenceDto[] | undefined;

  protected _discriminator: string;

  constructor(data?: IIElementDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    this._discriminator = "IElementDto";
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.gaebXmlId = _data["gaebXmlId"];
      this.addendumNumber = _data["addendumNumber"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      if (Array.isArray(_data["catalogueReferences"])) {
        this.catalogueReferences = [] as any;
        for (let item of _data["catalogueReferences"])
          this.catalogueReferences!.push(CatalogueReferenceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): IElementDto {
    data = typeof data === "object" ? data : {};
    if (data["elementTypeDiscriminator"] === "PositionDto") {
      let result = new PositionDto();
      result.init(data);
      return result;
    }
    if (data["elementTypeDiscriminator"] === "ExecutionDescriptionDto") {
      let result = new ExecutionDescriptionDto();
      result.init(data);
      return result;
    }
    if (data["elementTypeDiscriminator"] === "NoteTextDto") {
      let result = new NoteTextDto();
      result.init(data);
      return result;
    }
    if (data["elementTypeDiscriminator"] === "ServiceSpecificationGroupDto") {
      let result = new ServiceSpecificationGroupDto();
      result.init(data);
      return result;
    }
    throw new Error("The abstract class 'IElementDto' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["elementTypeDiscriminator"] = this._discriminator;
    data["id"] = this.id;
    data["gaebXmlId"] = this.gaebXmlId;
    data["addendumNumber"] = this.addendumNumber;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    if (Array.isArray(this.catalogueReferences)) {
      data["catalogueReferences"] = [];
      for (let item of this.catalogueReferences)
        data["catalogueReferences"].push(item.toJSON());
    }
    return data;
  }
}

/** Base interface definition for elements within an ElementContainerBase. */
export interface IIElementDto {
  /** Elements GUID identifier. */
  id: string;
  /** This is used to store the GAEB XML Id within this IElement. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a 'Nachtrag' in German. */
  addendumNumber?: string | undefined;
  projectCatalogues?: CatalogueDto[] | undefined;
  catalogueReferences?: CatalogueReferenceDto[] | undefined;
}

/** This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue. */
export class CatalogueDto implements ICatalogueDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This is used to store the GAEB XML Id within this Catalogue. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** The name that is given for this catalogue. */
  name?: string | undefined;
  /** Additional information about this catalogue. */
  description?: string | undefined;
  /** If given, this gives a classification for the contents of the catalogue */
  catalogueType!: CatalogueTypeDto;

  constructor(data?: ICatalogueDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.gaebXmlId = _data["gaebXmlId"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.catalogueType = _data["catalogueType"];
    }
  }

  static fromJS(data: any): CatalogueDto {
    data = typeof data === "object" ? data : {};
    let result = new CatalogueDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["gaebXmlId"] = this.gaebXmlId;
    data["name"] = this.name;
    data["description"] = this.description;
    data["catalogueType"] = this.catalogueType;
    return data;
  }
}

/** This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue. */
export interface ICatalogueDto {
  /** Elements GUID identifier. */
  id: string;
  /** This is used to store the GAEB XML Id within this Catalogue. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization. */
  gaebXmlId?: string | undefined;
  /** The name that is given for this catalogue. */
  name?: string | undefined;
  /** Additional information about this catalogue. */
  description?: string | undefined;
  /** If given, this gives a classification for the contents of the catalogue */
  catalogueType: CatalogueTypeDto;
}

/** This enumeration describes the type of a catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue. */
export enum CatalogueTypeDto {
  Unknown = "Unknown",
  Location = "Location",
  DIN276 = "DIN276",
  CostUnit = "CostUnit",
  WorkCategory = "WorkCategory",
  OenormB1801CostGroup = "OenormB1801CostGroup",
  BIM = "BIM",
}

/** This class is used to link data between catalogues and objects. */
export class CatalogueReferenceDto implements ICatalogueReferenceDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This points to the item in the catalogue itself. This means that, for example when this quantity assignment references a "DIN 276" catalogue, this property indicates the number / identifier / key in DIN 276 that is referenced. */
  catalogueReferenceKey?: string | undefined;
  /** The Id of the CatalogueReference that is targeted by this item. Set this property to set the referenced catalogue. */
  catalogueReferenceId!: string;
  /** These are CatalogueReference that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** This returns the referenced catalogue. Will return null if there is no reference or the catalogue is not present in the ProjectCatalogues. */
  readonly catalogue?: CatalogueDto | undefined;

  constructor(data?: ICatalogueReferenceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.catalogueReferenceKey = _data["catalogueReferenceKey"];
      this.catalogueReferenceId = _data["catalogueReferenceId"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      (<any>this).catalogue = _data["catalogue"]
        ? CatalogueDto.fromJS(_data["catalogue"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CatalogueReferenceDto {
    data = typeof data === "object" ? data : {};
    let result = new CatalogueReferenceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["catalogueReferenceKey"] = this.catalogueReferenceKey;
    data["catalogueReferenceId"] = this.catalogueReferenceId;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    data["catalogue"] = this.catalogue
      ? this.catalogue.toJSON()
      : <any>undefined;
    return data;
  }
}

/** This class is used to link data between catalogues and objects. */
export interface ICatalogueReferenceDto {
  /** Elements GUID identifier. */
  id: string;
  /** This points to the item in the catalogue itself. This means that, for example when this quantity assignment references a "DIN 276" catalogue, this property indicates the number / identifier / key in DIN 276 that is referenced. */
  catalogueReferenceKey?: string | undefined;
  /** The Id of the CatalogueReference that is targeted by this item. Set this property to set the referenced catalogue. */
  catalogueReferenceId: string;
  /** These are CatalogueReference that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** This returns the referenced catalogue. Will return null if there is no reference or the catalogue is not present in the ProjectCatalogues. */
  catalogue?: CatalogueDto | undefined;
}

/** A Position is the main item type in a ServiceSpecification, holding information about tasks to be done, their prices, description, amounts etc. */
export class PositionDto extends IElementDto implements IPositionDto {
  /** Will return the price per unit, rounded according to the project settings or the default value of three decimal places */
  readonly unitPrice!: number;
  /** You can use this property to directly set the unit price for this position. This will override any given PriceComponents */
  unitPriceOverride?: number | undefined;
  /** Will return this Position's total quantity, rounded to three decimal places. */
  readonly quantity!: number;
  /** You can use this property to directly set the quantity for this position. This will override any given QuantityComponents */
  quantityOverride?: number | undefined;
  /** This indicates true if this specific position is specified as a complementing position for any base position. */
  isComplementingPosition!: boolean;
  /** If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position. */
  complementsPositions?: string[] | undefined;
  /** You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride. */
  complementingPricePercentageOverride?: number | undefined;
  /** This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null. */
  complementingPricePercentage?: number | undefined;
  /** The tag of the unit used for this positions quantity. */
  unitTag?: string | undefined;
  /** The components for labour time in this Position. */
  labourComponents?: LabourPriceComponentDto | undefined;
  /** The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation. */
  priceComponents?: PriceComponentDto[] | undefined;
  /** The quantity components of this Position. */
  quantityComponents?: CalculationDto[] | undefined;
  /** Further structuring of this Position. */
  subDescriptions?: SubDescriptionDto[] | undefined;
  /** Indicates the status of this Position's comission. */
  comissionStatus!: ComissionStatusDto;
  /** A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions. */
  complementedBy?: string[] | undefined;
  /** Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property. */
  complemented!: boolean;
  /** Indicates that the amount for this Position is to be set by the bidder. */
  amountToBeEnteredByBidder!: boolean;
  /** Indicates if the bidder demands for prices to be broken up into their price components. */
  priceCompositionRequired!: boolean;
  /** Indicates if this Position should use a different TaxRate than what is the default for the Project. */
  useDifferentTaxRate!: boolean;
  /** Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions) */
  taxRate!: number;
  /** The ItemNumber for this Position. */
  itemNumber?: ItemNumberDto | undefined;
  /** The rate of deductions, i.e. 0.12m means 12% price deduction. */
  deductionFactor!: number;
  /** Returns the product of UnitPrice times Quantity. */
  readonly totalPrice!: number;
  /** The total gross price for this Position. */
  readonly totalPriceGross!: number;
  /** Total gross price after applied deductions. */
  readonly totalPriceGrossDeducted!: number;
  /** Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position. */
  readonly deductedPrice!: number;
  /** This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace. */
  positionType!: PositionTypeDto;
  /** Indicates the PriceType of this Position. */
  priceType!: PriceTypeDto;
  /** This indicates if this position is regular or describing a labour / hourly paid work service */
  serviceType!: ServiceTypeDto;
  /** This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles. */
  productData?: ProductDataDto | undefined;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType!: AdditionTypeDto;
  elementType?: string | undefined;
  /** Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000mÂ² wall, 500mÂ² are classified as exterior walls and 500mÂ² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes. */
  quantityAssignments?: QuantityAssignmentDto[] | undefined;
  /** The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information. */
  commerceProperties?: CommercePropertiesDto | undefined;
  /** If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position. */
  alternativeTo?: string | undefined;
  /** This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo. */
  alternativeIdentifier?: number | undefined;
  /** This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo. */
  alternativeGroupIdentifier?: number | undefined;
  /** If this is true, it indicates that the position is intended to be a lump sum, "Pauschal" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used. */
  isLumpSum!: boolean;
  /** This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches "Bezugsposition" in GAEB. This can be used for positions that repeat partially or are linked together */
  repetitionTo?: string | undefined;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  /** This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here. */
  complementedByQuantities?: ComplementedByQuantityDto[] | undefined;
  /** This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details. */
  executionDescriptionReference?: string | undefined;
  /** This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all. */
  notOffered!: boolean;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for Positions and extends the OenormProperties base class. */
  oenormPositionProperties?: OenormPositionPropertiesDto | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel!: number;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;
  readonly hasBidderCommentInHtmlLongText!: boolean;
  /** This property can optionally be used in GAEB exchange scenarios. It is only meaningful if this position itself is a complementing position, meaning if this position is marked in other positions in their ComplementedBy list. Then, it specifies how the complementing should be expressed in GAEB. By default, positions are always explicitly referenced, but other options are possible. Please also note that the Dangl.AVA.Converter package, which is used for GAEB exports, will check if the given type is valid in the current project configuration. If not, directly referenced positions will be used as fallback. */
  gaebComplementingType!: PositionComplementingTypeDto;

  constructor(data?: IPositionDto) {
    super(data);
    this._discriminator = "PositionDto";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      (<any>this).unitPrice = _data["unitPrice"];
      this.unitPriceOverride = _data["unitPriceOverride"];
      (<any>this).quantity = _data["quantity"];
      this.quantityOverride = _data["quantityOverride"];
      this.isComplementingPosition = _data["isComplementingPosition"];
      if (Array.isArray(_data["complementsPositions"])) {
        this.complementsPositions = [] as any;
        for (let item of _data["complementsPositions"])
          this.complementsPositions!.push(item);
      }
      this.complementingPricePercentageOverride =
        _data["complementingPricePercentageOverride"];
      this.complementingPricePercentage = _data["complementingPricePercentage"];
      this.unitTag = _data["unitTag"];
      this.labourComponents = _data["labourComponents"]
        ? LabourPriceComponentDto.fromJS(_data["labourComponents"])
        : <any>undefined;
      if (Array.isArray(_data["priceComponents"])) {
        this.priceComponents = [] as any;
        for (let item of _data["priceComponents"])
          this.priceComponents!.push(PriceComponentDto.fromJS(item));
      }
      if (Array.isArray(_data["quantityComponents"])) {
        this.quantityComponents = [] as any;
        for (let item of _data["quantityComponents"])
          this.quantityComponents!.push(CalculationDto.fromJS(item));
      }
      if (Array.isArray(_data["subDescriptions"])) {
        this.subDescriptions = [] as any;
        for (let item of _data["subDescriptions"])
          this.subDescriptions!.push(SubDescriptionDto.fromJS(item));
      }
      this.comissionStatus = _data["comissionStatus"];
      if (Array.isArray(_data["complementedBy"])) {
        this.complementedBy = [] as any;
        for (let item of _data["complementedBy"])
          this.complementedBy!.push(item);
      }
      this.complemented = _data["complemented"];
      this.amountToBeEnteredByBidder = _data["amountToBeEnteredByBidder"];
      this.priceCompositionRequired = _data["priceCompositionRequired"];
      this.useDifferentTaxRate = _data["useDifferentTaxRate"];
      this.taxRate = _data["taxRate"];
      this.itemNumber = _data["itemNumber"]
        ? ItemNumberDto.fromJS(_data["itemNumber"])
        : <any>undefined;
      this.deductionFactor = _data["deductionFactor"];
      (<any>this).totalPrice = _data["totalPrice"];
      (<any>this).totalPriceGross = _data["totalPriceGross"];
      (<any>this).totalPriceGrossDeducted = _data["totalPriceGrossDeducted"];
      (<any>this).deductedPrice = _data["deductedPrice"];
      this.positionType = _data["positionType"];
      this.priceType = _data["priceType"];
      this.serviceType = _data["serviceType"];
      this.productData = _data["productData"]
        ? ProductDataDto.fromJS(_data["productData"])
        : <any>undefined;
      this.shortText = _data["shortText"];
      this.longText = _data["longText"];
      this.htmlLongText = _data["htmlLongText"];
      this.additionType = _data["additionType"];
      this.elementType = _data["elementType"];
      if (Array.isArray(_data["quantityAssignments"])) {
        this.quantityAssignments = [] as any;
        for (let item of _data["quantityAssignments"])
          this.quantityAssignments!.push(QuantityAssignmentDto.fromJS(item));
      }
      this.commerceProperties = _data["commerceProperties"]
        ? CommercePropertiesDto.fromJS(_data["commerceProperties"])
        : <any>undefined;
      this.alternativeTo = _data["alternativeTo"];
      this.alternativeIdentifier = _data["alternativeIdentifier"];
      this.alternativeGroupIdentifier = _data["alternativeGroupIdentifier"];
      this.isLumpSum = _data["isLumpSum"];
      this.repetitionTo = _data["repetitionTo"];
      this.standardizedDescription = _data["standardizedDescription"]
        ? StandardizedDescriptionDto.fromJS(_data["standardizedDescription"])
        : <any>undefined;
      if (Array.isArray(_data["complementedByQuantities"])) {
        this.complementedByQuantities = [] as any;
        for (let item of _data["complementedByQuantities"])
          this.complementedByQuantities!.push(
            ComplementedByQuantityDto.fromJS(item)
          );
      }
      this.executionDescriptionReference =
        _data["executionDescriptionReference"];
      this.notOffered = _data["notOffered"];
      this.oenormPositionProperties = _data["oenormPositionProperties"]
        ? OenormPositionPropertiesDto.fromJS(_data["oenormPositionProperties"])
        : <any>undefined;
      this.descriptionId = _data["descriptionId"];
      this.hierarchyLevel = _data["hierarchyLevel"];
      this.addendumStatus = _data["addendumStatus"];
      (<any>this).hasBidderCommentInHtmlLongText =
        _data["hasBidderCommentInHtmlLongText"];
      this.gaebComplementingType = _data["gaebComplementingType"];
    }
  }

  static fromJS(data: any): PositionDto {
    data = typeof data === "object" ? data : {};
    let result = new PositionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["unitPrice"] = this.unitPrice;
    data["unitPriceOverride"] = this.unitPriceOverride;
    data["quantity"] = this.quantity;
    data["quantityOverride"] = this.quantityOverride;
    data["isComplementingPosition"] = this.isComplementingPosition;
    if (Array.isArray(this.complementsPositions)) {
      data["complementsPositions"] = [];
      for (let item of this.complementsPositions)
        data["complementsPositions"].push(item);
    }
    data["complementingPricePercentageOverride"] =
      this.complementingPricePercentageOverride;
    data["complementingPricePercentage"] = this.complementingPricePercentage;
    data["unitTag"] = this.unitTag;
    data["labourComponents"] = this.labourComponents
      ? this.labourComponents.toJSON()
      : <any>undefined;
    if (Array.isArray(this.priceComponents)) {
      data["priceComponents"] = [];
      for (let item of this.priceComponents)
        data["priceComponents"].push(item.toJSON());
    }
    if (Array.isArray(this.quantityComponents)) {
      data["quantityComponents"] = [];
      for (let item of this.quantityComponents)
        data["quantityComponents"].push(item.toJSON());
    }
    if (Array.isArray(this.subDescriptions)) {
      data["subDescriptions"] = [];
      for (let item of this.subDescriptions)
        data["subDescriptions"].push(item.toJSON());
    }
    data["comissionStatus"] = this.comissionStatus;
    if (Array.isArray(this.complementedBy)) {
      data["complementedBy"] = [];
      for (let item of this.complementedBy) data["complementedBy"].push(item);
    }
    data["complemented"] = this.complemented;
    data["amountToBeEnteredByBidder"] = this.amountToBeEnteredByBidder;
    data["priceCompositionRequired"] = this.priceCompositionRequired;
    data["useDifferentTaxRate"] = this.useDifferentTaxRate;
    data["taxRate"] = this.taxRate;
    data["itemNumber"] = this.itemNumber
      ? this.itemNumber.toJSON()
      : <any>undefined;
    data["deductionFactor"] = this.deductionFactor;
    data["totalPrice"] = this.totalPrice;
    data["totalPriceGross"] = this.totalPriceGross;
    data["totalPriceGrossDeducted"] = this.totalPriceGrossDeducted;
    data["deductedPrice"] = this.deductedPrice;
    data["positionType"] = this.positionType;
    data["priceType"] = this.priceType;
    data["serviceType"] = this.serviceType;
    data["productData"] = this.productData
      ? this.productData.toJSON()
      : <any>undefined;
    data["shortText"] = this.shortText;
    data["longText"] = this.longText;
    data["htmlLongText"] = this.htmlLongText;
    data["additionType"] = this.additionType;
    data["elementType"] = this.elementType;
    if (Array.isArray(this.quantityAssignments)) {
      data["quantityAssignments"] = [];
      for (let item of this.quantityAssignments)
        data["quantityAssignments"].push(item.toJSON());
    }
    data["commerceProperties"] = this.commerceProperties
      ? this.commerceProperties.toJSON()
      : <any>undefined;
    data["alternativeTo"] = this.alternativeTo;
    data["alternativeIdentifier"] = this.alternativeIdentifier;
    data["alternativeGroupIdentifier"] = this.alternativeGroupIdentifier;
    data["isLumpSum"] = this.isLumpSum;
    data["repetitionTo"] = this.repetitionTo;
    data["standardizedDescription"] = this.standardizedDescription
      ? this.standardizedDescription.toJSON()
      : <any>undefined;
    if (Array.isArray(this.complementedByQuantities)) {
      data["complementedByQuantities"] = [];
      for (let item of this.complementedByQuantities)
        data["complementedByQuantities"].push(item.toJSON());
    }
    data["executionDescriptionReference"] = this.executionDescriptionReference;
    data["notOffered"] = this.notOffered;
    data["oenormPositionProperties"] = this.oenormPositionProperties
      ? this.oenormPositionProperties.toJSON()
      : <any>undefined;
    data["descriptionId"] = this.descriptionId;
    data["hierarchyLevel"] = this.hierarchyLevel;
    data["addendumStatus"] = this.addendumStatus;
    data["hasBidderCommentInHtmlLongText"] =
      this.hasBidderCommentInHtmlLongText;
    data["gaebComplementingType"] = this.gaebComplementingType;
    super.toJSON(data);
    return data;
  }
}

/** A Position is the main item type in a ServiceSpecification, holding information about tasks to be done, their prices, description, amounts etc. */
export interface IPositionDto extends IIElementDto {
  /** Will return the price per unit, rounded according to the project settings or the default value of three decimal places */
  unitPrice: number;
  /** You can use this property to directly set the unit price for this position. This will override any given PriceComponents */
  unitPriceOverride?: number | undefined;
  /** Will return this Position's total quantity, rounded to three decimal places. */
  quantity: number;
  /** You can use this property to directly set the quantity for this position. This will override any given QuantityComponents */
  quantityOverride?: number | undefined;
  /** This indicates true if this specific position is specified as a complementing position for any base position. */
  isComplementingPosition: boolean;
  /** If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position. */
  complementsPositions?: string[] | undefined;
  /** You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride. */
  complementingPricePercentageOverride?: number | undefined;
  /** This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null. */
  complementingPricePercentage?: number | undefined;
  /** The tag of the unit used for this positions quantity. */
  unitTag?: string | undefined;
  /** The components for labour time in this Position. */
  labourComponents?: LabourPriceComponentDto | undefined;
  /** The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation. */
  priceComponents?: PriceComponentDto[] | undefined;
  /** The quantity components of this Position. */
  quantityComponents?: CalculationDto[] | undefined;
  /** Further structuring of this Position. */
  subDescriptions?: SubDescriptionDto[] | undefined;
  /** Indicates the status of this Position's comission. */
  comissionStatus: ComissionStatusDto;
  /** A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions. */
  complementedBy?: string[] | undefined;
  /** Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property. */
  complemented: boolean;
  /** Indicates that the amount for this Position is to be set by the bidder. */
  amountToBeEnteredByBidder: boolean;
  /** Indicates if the bidder demands for prices to be broken up into their price components. */
  priceCompositionRequired: boolean;
  /** Indicates if this Position should use a different TaxRate than what is the default for the Project. */
  useDifferentTaxRate: boolean;
  /** Will return either the parent ServiceSpecification's TaxRate or it's own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions) */
  taxRate: number;
  /** The ItemNumber for this Position. */
  itemNumber?: ItemNumberDto | undefined;
  /** The rate of deductions, i.e. 0.12m means 12% price deduction. */
  deductionFactor: number;
  /** Returns the product of UnitPrice times Quantity. */
  totalPrice: number;
  /** The total gross price for this Position. */
  totalPriceGross: number;
  /** Total gross price after applied deductions. */
  totalPriceGrossDeducted: number;
  /** Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position. */
  deductedPrice: number;
  /** This indicates the type of a position. If this is an alternative position, its AlternativeTo property should be set to the id of the position it can replace. */
  positionType: PositionTypeDto;
  /** Indicates the PriceType of this Position. */
  priceType: PriceTypeDto;
  /** This indicates if this position is regular or describing a labour / hourly paid work service */
  serviceType: ServiceTypeDto;
  /** This property describes additional information about a product being used within this Position. For example, a pipe position, per length unit, could be composed of different pipe segments, fitting and other accessory articles. */
  productData?: ProductDataDto | undefined;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType: AdditionTypeDto;
  elementType?: string | undefined;
  /** Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000mÂ² wall, 500mÂ² are classified as exterior walls and 500mÂ² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes. */
  quantityAssignments?: QuantityAssignmentDto[] | undefined;
  /** The CommerceProperties support specialized information that is only useful in GAEB XML 9x data exchange phases. It is intended to provide article information. */
  commerceProperties?: CommercePropertiesDto | undefined;
  /** If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position. */
  alternativeTo?: string | undefined;
  /** This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo. */
  alternativeIdentifier?: number | undefined;
  /** This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It's different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo. */
  alternativeGroupIdentifier?: number | undefined;
  /** If this is true, it indicates that the position is intended to be a lump sum, "Pauschal" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used. */
  isLumpSum: boolean;
  /** This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches "Bezugsposition" in GAEB. This can be used for positions that repeat partially or are linked together */
  repetitionTo?: string | undefined;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  /** This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it's up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here. */
  complementedByQuantities?: ComplementedByQuantityDto[] | undefined;
  /** This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details. */
  executionDescriptionReference?: string | undefined;
  /** This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all. */
  notOffered: boolean;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for Positions and extends the OenormProperties base class. */
  oenormPositionProperties?: OenormPositionPropertiesDto | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel: number;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;
  hasBidderCommentInHtmlLongText: boolean;
  /** This property can optionally be used in GAEB exchange scenarios. It is only meaningful if this position itself is a complementing position, meaning if this position is marked in other positions in their ComplementedBy list. Then, it specifies how the complementing should be expressed in GAEB. By default, positions are always explicitly referenced, but other options are possible. Please also note that the Dangl.AVA.Converter package, which is used for GAEB exports, will check if the given type is valid in the current project configuration. If not, directly referenced positions will be used as fallback. */
  gaebComplementingType: PositionComplementingTypeDto;
}

/** Based on the PriceComponent, this class is responsible for labour time components. */
export class LabourPriceComponentDto implements ILabourPriceComponentDto {
  /** The label associated with this price component. Will be taken from the parent Projects ProjectInformation. */
  label?: string | undefined;
  /** The total, calculated price of this component. Will multiply the calculated amount of hours with the ServiceSpecifications hourly wage rate. */
  readonly price!: number;
  /** The cost per hour of manual labor. */
  hourlyWage!: number;
  /** The single Calculation elements this price component is composed of. */
  values?: CalculationDto[] | undefined;
  /** Indicates if the ServiceSpecification's standard HourlyWage is to be used or a custom value. */
  useOwnHourlyWage!: boolean;
  /** The total, calculated time of this component. Will return the result rounded to three decimal places. */
  readonly totalTime!: number;
  /** These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;

  constructor(data?: ILabourPriceComponentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.label = _data["label"];
      (<any>this).price = _data["price"];
      this.hourlyWage = _data["hourlyWage"];
      if (Array.isArray(_data["values"])) {
        this.values = [] as any;
        for (let item of _data["values"])
          this.values!.push(CalculationDto.fromJS(item));
      }
      this.useOwnHourlyWage = _data["useOwnHourlyWage"];
      (<any>this).totalTime = _data["totalTime"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): LabourPriceComponentDto {
    data = typeof data === "object" ? data : {};
    let result = new LabourPriceComponentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["label"] = this.label;
    data["price"] = this.price;
    data["hourlyWage"] = this.hourlyWage;
    if (Array.isArray(this.values)) {
      data["values"] = [];
      for (let item of this.values) data["values"].push(item.toJSON());
    }
    data["useOwnHourlyWage"] = this.useOwnHourlyWage;
    data["totalTime"] = this.totalTime;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    return data;
  }
}

/** Based on the PriceComponent, this class is responsible for labour time components. */
export interface ILabourPriceComponentDto {
  /** The label associated with this price component. Will be taken from the parent Projects ProjectInformation. */
  label?: string | undefined;
  /** The total, calculated price of this component. Will multiply the calculated amount of hours with the ServiceSpecifications hourly wage rate. */
  price: number;
  /** The cost per hour of manual labor. */
  hourlyWage: number;
  /** The single Calculation elements this price component is composed of. */
  values?: CalculationDto[] | undefined;
  /** Indicates if the ServiceSpecification's standard HourlyWage is to be used or a custom value. */
  useOwnHourlyWage: boolean;
  /** The total, calculated time of this component. Will return the result rounded to three decimal places. */
  totalTime: number;
  /** These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
}

/** This class holds means to calculate mathematical expressions from given strings. */
export class CalculationDto implements ICalculationDto {
  /** Descriptive text for this calculation. */
  description?: string | undefined;
  /** This Calculation's mathematical expression. Please note that thousands separators are not supported. Both comma and point will be treated as decimal separators. */
  formula?: string | undefined;
  /** The calculated result from the formula, 0 if invalid. */
  readonly result!: number;
  /** Whether the Formula is a valid expression. */
  readonly valid!: boolean;
  /** Will be -1 if the Formula is correct, else it will show the position in the formula where an error was encountered. This is a zero based index. */
  readonly errorPositionInLine!: number;
  /** These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this Calculation. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;

  constructor(data?: ICalculationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data["description"];
      this.formula = _data["formula"];
      (<any>this).result = _data["result"];
      (<any>this).valid = _data["valid"];
      (<any>this).errorPositionInLine = _data["errorPositionInLine"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      if (Array.isArray(_data["catalogueReferences"])) {
        this.catalogueReferences = [] as any;
        for (let item of _data["catalogueReferences"])
          this.catalogueReferences!.push(CatalogueReferenceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CalculationDto {
    data = typeof data === "object" ? data : {};
    let result = new CalculationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["description"] = this.description;
    data["formula"] = this.formula;
    data["result"] = this.result;
    data["valid"] = this.valid;
    data["errorPositionInLine"] = this.errorPositionInLine;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    if (Array.isArray(this.catalogueReferences)) {
      data["catalogueReferences"] = [];
      for (let item of this.catalogueReferences)
        data["catalogueReferences"].push(item.toJSON());
    }
    return data;
  }
}

/** This class holds means to calculate mathematical expressions from given strings. */
export interface ICalculationDto {
  /** Descriptive text for this calculation. */
  description?: string | undefined;
  /** This Calculation's mathematical expression. Please note that thousands separators are not supported. Both comma and point will be treated as decimal separators. */
  formula?: string | undefined;
  /** The calculated result from the formula, 0 if invalid. */
  result: number;
  /** Whether the Formula is a valid expression. */
  valid: boolean;
  /** Will be -1 if the Formula is correct, else it will show the position in the formula where an error was encountered. This is a zero based index. */
  errorPositionInLine: number;
  /** These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this Calculation. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;
}

/** This class provides means to store information about a price and it's composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc. */
export class PriceComponentDto implements IPriceComponentDto {
  /** The total, calculated price of this component. */
  readonly price!: number;
  /** The label associated with this price component. Will be taken from the parent Projects ProjectInformation. */
  label?: string | undefined;
  /** The single Calculation elements this price component is composed of. */
  values?: CalculationDto[] | undefined;
  /** These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;

  constructor(data?: IPriceComponentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      (<any>this).price = _data["price"];
      this.label = _data["label"];
      if (Array.isArray(_data["values"])) {
        this.values = [] as any;
        for (let item of _data["values"])
          this.values!.push(CalculationDto.fromJS(item));
      }
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceComponentDto {
    data = typeof data === "object" ? data : {};
    let result = new PriceComponentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["price"] = this.price;
    data["label"] = this.label;
    if (Array.isArray(this.values)) {
      data["values"] = [];
      for (let item of this.values) data["values"].push(item.toJSON());
    }
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    return data;
  }
}

/** This class provides means to store information about a price and it's composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc. */
export interface IPriceComponentDto {
  /** The total, calculated price of this component. */
  price: number;
  /** The label associated with this price component. Will be taken from the parent Projects ProjectInformation. */
  label?: string | undefined;
  /** The single Calculation elements this price component is composed of. */
  values?: CalculationDto[] | undefined;
  /** These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
}

/** This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys. */
export class SubDescriptionDto implements ISubDescriptionDto {
  /** Elements GUID identifier. */
  id!: string;
  /** Returns the total calculated sum of all quantity assignments. Will return the result rounded to three decimal places. */
  readonly quantity!: number;
  /** You can use this property to directly set the quantity for this sub description. This will override any given QuantityComponents */
  quantityOverride?: number | undefined;
  /** Holds quantity information for this sub description. Quantity is listening to changes here and is reporting the total sum of all quantity components. */
  quantityComponents?: CalculationDto[] | undefined;
  /** Indicates if the bidder is asked to specify an amount. */
  amountToBeEnteredByBidder!: boolean;
  /** Identifier for this SubDescription. */
  identifier?: string | undefined;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** If this is given, then the sub description has a different unit tag than the parent position. */
  unitTag?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType!: AdditionTypeDto;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  /** This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions (or sub descriptions) should be executed in practice. Often, the position (or sub description) itself still has text of its own to highlight deviations from that or add more details. When working with import and export features, this property is only supported in GAEB 90 data exchange. */
  executionDescriptionReference?: string | undefined;
  /** These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  readonly hasBidderCommentInHtmlLongText!: boolean;
  elementType?: string | undefined;
  elementTypeDiscriminator?: string | undefined;

  constructor(data?: ISubDescriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      (<any>this).quantity = _data["quantity"];
      this.quantityOverride = _data["quantityOverride"];
      if (Array.isArray(_data["quantityComponents"])) {
        this.quantityComponents = [] as any;
        for (let item of _data["quantityComponents"])
          this.quantityComponents!.push(CalculationDto.fromJS(item));
      }
      this.amountToBeEnteredByBidder = _data["amountToBeEnteredByBidder"];
      this.identifier = _data["identifier"];
      this.shortText = _data["shortText"];
      this.longText = _data["longText"];
      this.unitTag = _data["unitTag"];
      this.htmlLongText = _data["htmlLongText"];
      this.additionType = _data["additionType"];
      this.standardizedDescription = _data["standardizedDescription"]
        ? StandardizedDescriptionDto.fromJS(_data["standardizedDescription"])
        : <any>undefined;
      this.executionDescriptionReference =
        _data["executionDescriptionReference"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      this.descriptionId = _data["descriptionId"];
      (<any>this).hasBidderCommentInHtmlLongText =
        _data["hasBidderCommentInHtmlLongText"];
      this.elementType = _data["elementType"];
      this.elementTypeDiscriminator = _data["elementTypeDiscriminator"];
    }
  }

  static fromJS(data: any): SubDescriptionDto {
    data = typeof data === "object" ? data : {};
    let result = new SubDescriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["quantity"] = this.quantity;
    data["quantityOverride"] = this.quantityOverride;
    if (Array.isArray(this.quantityComponents)) {
      data["quantityComponents"] = [];
      for (let item of this.quantityComponents)
        data["quantityComponents"].push(item.toJSON());
    }
    data["amountToBeEnteredByBidder"] = this.amountToBeEnteredByBidder;
    data["identifier"] = this.identifier;
    data["shortText"] = this.shortText;
    data["longText"] = this.longText;
    data["unitTag"] = this.unitTag;
    data["htmlLongText"] = this.htmlLongText;
    data["additionType"] = this.additionType;
    data["standardizedDescription"] = this.standardizedDescription
      ? this.standardizedDescription.toJSON()
      : <any>undefined;
    data["executionDescriptionReference"] = this.executionDescriptionReference;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    data["descriptionId"] = this.descriptionId;
    data["hasBidderCommentInHtmlLongText"] =
      this.hasBidderCommentInHtmlLongText;
    data["elementType"] = this.elementType;
    data["elementTypeDiscriminator"] = this.elementTypeDiscriminator;
    return data;
  }
}

/** This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys. */
export interface ISubDescriptionDto {
  /** Elements GUID identifier. */
  id: string;
  /** Returns the total calculated sum of all quantity assignments. Will return the result rounded to three decimal places. */
  quantity: number;
  /** You can use this property to directly set the quantity for this sub description. This will override any given QuantityComponents */
  quantityOverride?: number | undefined;
  /** Holds quantity information for this sub description. Quantity is listening to changes here and is reporting the total sum of all quantity components. */
  quantityComponents?: CalculationDto[] | undefined;
  /** Indicates if the bidder is asked to specify an amount. */
  amountToBeEnteredByBidder: boolean;
  /** Identifier for this SubDescription. */
  identifier?: string | undefined;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** If this is given, then the sub description has a different unit tag than the parent position. */
  unitTag?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType: AdditionTypeDto;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  /** This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions (or sub descriptions) should be executed in practice. Often, the position (or sub description) itself still has text of its own to highlight deviations from that or add more details. When working with import and export features, this property is only supported in GAEB 90 data exchange. */
  executionDescriptionReference?: string | undefined;
  /** These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  hasBidderCommentInHtmlLongText: boolean;
  elementType?: string | undefined;
  elementTypeDiscriminator?: string | undefined;
}

/** Indicates the origin of an element. */
export enum AdditionTypeDto {
  None = "None",
  ByBuyer = "ByBuyer",
  ByBidder = "ByBidder",
}

/** This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
export class StandardizedDescriptionDto implements IStandardizedDescriptionDto {
  /** This enumeration identifies a pre-known standard used for referencing standardized descriptions. */
  standardReferenceType!: StandardReferenceTypeDto;
  /** This string property is the identifier to map to the references standard. Its type is given in the StandardReferenceType */
  standardReference?: string | undefined;
  /** This is a special reference to the German STLB "Standardleistungsbuch Bau" reference. If this is used, the StandardReference property should not be set. */
  stlbReference?: STLBReferenceDto | undefined;

  constructor(data?: IStandardizedDescriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.standardReferenceType = _data["standardReferenceType"];
      this.standardReference = _data["standardReference"];
      this.stlbReference = _data["stlbReference"]
        ? STLBReferenceDto.fromJS(_data["stlbReference"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): StandardizedDescriptionDto {
    data = typeof data === "object" ? data : {};
    let result = new StandardizedDescriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["standardReferenceType"] = this.standardReferenceType;
    data["standardReference"] = this.standardReference;
    data["stlbReference"] = this.stlbReference
      ? this.stlbReference.toJSON()
      : <any>undefined;
    return data;
  }
}

/** This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
export interface IStandardizedDescriptionDto {
  /** This enumeration identifies a pre-known standard used for referencing standardized descriptions. */
  standardReferenceType: StandardReferenceTypeDto;
  /** This string property is the identifier to map to the references standard. Its type is given in the StandardReferenceType */
  standardReference?: string | undefined;
  /** This is a special reference to the German STLB "Standardleistungsbuch Bau" reference. If this is used, the StandardReference property should not be set. */
  stlbReference?: STLBReferenceDto | undefined;
}

/** This enumeration identifies a pre-known standard used for referencing standardized descriptions. */
export enum StandardReferenceTypeDto {
  Unknown = "Unknown",
  StLB = "StLB",
  StLK = "StLK",
  STLBBauZ = "STLBBauZ",
}

/** This class represents a specialized reference to the German STLB "Standardleistungsbuch Bau". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard */
export class STLBReferenceDto implements ISTLBReferenceDto {
  /** The date of the STLB version. Typically, only the Year and Month are used */
  versionDate?: Date | undefined;
  /** The name of the catalogue within the STLB */
  catalogueName?: string | undefined;
  /** The name of the group in STLB */
  group?: string | undefined;
  /** The cost group this service is associated with */
  costGroup?: string | undefined;
  /** The service area (or type) in the STLB */
  serviceArea?: string | undefined;
  /** These keys may optionally be used to further reference multiple, specific items within the STLB */
  keys?: STLBKeyDto[] | undefined;

  constructor(data?: ISTLBReferenceDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.versionDate = _data["versionDate"]
        ? new Date(_data["versionDate"].toString())
        : <any>undefined;
      this.catalogueName = _data["catalogueName"];
      this.group = _data["group"];
      this.costGroup = _data["costGroup"];
      this.serviceArea = _data["serviceArea"];
      if (Array.isArray(_data["keys"])) {
        this.keys = [] as any;
        for (let item of _data["keys"])
          this.keys!.push(STLBKeyDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): STLBReferenceDto {
    data = typeof data === "object" ? data : {};
    let result = new STLBReferenceDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["versionDate"] = this.versionDate
      ? this.versionDate.toISOString()
      : <any>undefined;
    data["catalogueName"] = this.catalogueName;
    data["group"] = this.group;
    data["costGroup"] = this.costGroup;
    data["serviceArea"] = this.serviceArea;
    if (Array.isArray(this.keys)) {
      data["keys"] = [];
      for (let item of this.keys) data["keys"].push(item.toJSON());
    }
    return data;
  }
}

/** This class represents a specialized reference to the German STLB "Standardleistungsbuch Bau". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard */
export interface ISTLBReferenceDto {
  /** The date of the STLB version. Typically, only the Year and Month are used */
  versionDate?: Date | undefined;
  /** The name of the catalogue within the STLB */
  catalogueName?: string | undefined;
  /** The name of the group in STLB */
  group?: string | undefined;
  /** The cost group this service is associated with */
  costGroup?: string | undefined;
  /** The service area (or type) in the STLB */
  serviceArea?: string | undefined;
  /** These keys may optionally be used to further reference multiple, specific items within the STLB */
  keys?: STLBKeyDto[] | undefined;
}

/** This class represents a single key reference within the German STLB "Standardleistungsbuch Bau" */
export class STLBKeyDto implements ISTLBKeyDto {
  /** This identifier is required and uniquely describes a single reference within the STLB standard. It maps to "ArtChrIdent" in GAEB XML */
  artIdentifier!: number;
  /** This optional index property further categorizes a single reference within the STLB standard. It maps to "ArtChIdx" in GAEB XML */
  artIndex?: number | undefined;
  /** This optional identifier further specifies the execution kind of the reference in the STLB standard. It maps to "ChVIdent" in GAEB XML */
  kindIdentifier?: number | undefined;

  constructor(data?: ISTLBKeyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.artIdentifier = _data["artIdentifier"];
      this.artIndex = _data["artIndex"];
      this.kindIdentifier = _data["kindIdentifier"];
    }
  }

  static fromJS(data: any): STLBKeyDto {
    data = typeof data === "object" ? data : {};
    let result = new STLBKeyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["artIdentifier"] = this.artIdentifier;
    data["artIndex"] = this.artIndex;
    data["kindIdentifier"] = this.kindIdentifier;
    return data;
  }
}

/** This class represents a single key reference within the German STLB "Standardleistungsbuch Bau" */
export interface ISTLBKeyDto {
  /** This identifier is required and uniquely describes a single reference within the STLB standard. It maps to "ArtChrIdent" in GAEB XML */
  artIdentifier: number;
  /** This optional index property further categorizes a single reference within the STLB standard. It maps to "ArtChIdx" in GAEB XML */
  artIndex?: number | undefined;
  /** This optional identifier further specifies the execution kind of the reference in the STLB standard. It maps to "ChVIdent" in GAEB XML */
  kindIdentifier?: number | undefined;
}

/** Indicates if this service specification item is commissioned (and therefore should be executed), postponed for later or undefined. */
export enum ComissionStatusDto {
  Undefined = "Undefined",
  Commissioned = "Commissioned",
  Postponed = "Postponed",
  Removed = "Removed",
}

/** This class represents as identifier of a certain service specification's element and is uniquely within the service specification. */
export class ItemNumberDto implements IItemNumberDto {
  /** Elements GUID identifier. */
  id!: string;
  /** Will return this ItemNumber as point delimited string. Will not distinguish between upper- and lowercase and return an all-lowercase representation. Will consider first numbers, then characters, e.g. 1a is considered preceding aa. */
  stringRepresentation?: string | undefined;
  /** Indicates if the characters and the length of the Identifiers match the current ItemNumberSchema. */
  readonly isSchemaCompliant!: boolean;
  /** Used for representing and validating this ItemNumber. */
  itemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** Collection of the single identifiers in this ItemNumber. P.e., "02.03.004" will have three elements "02", "03", and "004". Since ReadOnlyObservableCollection`1 does have the event set to protected, it can be accessed like this: (itemNumber.Identifiers as INotifyCollectionChanged).CollectionChanged */
  identifiers?: string[] | undefined;
  /** This indicates if this item number is at the lot level. Find out more about lots in the documentation. */
  readonly isLot!: boolean;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel!: number;
  /** This property indicates if this ItemNumber is attached to an object of the Position type. */
  readonly isAttachedToPosition!: boolean;

  constructor(data?: IItemNumberDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.stringRepresentation = _data["stringRepresentation"];
      (<any>this).isSchemaCompliant = _data["isSchemaCompliant"];
      this.itemNumberSchema = _data["itemNumberSchema"]
        ? ItemNumberSchemaDto.fromJS(_data["itemNumberSchema"])
        : <any>undefined;
      if (Array.isArray(_data["identifiers"])) {
        this.identifiers = [] as any;
        for (let item of _data["identifiers"]) this.identifiers!.push(item);
      }
      (<any>this).isLot = _data["isLot"];
      this.hierarchyLevel = _data["hierarchyLevel"];
      (<any>this).isAttachedToPosition = _data["isAttachedToPosition"];
    }
  }

  static fromJS(data: any): ItemNumberDto {
    data = typeof data === "object" ? data : {};
    let result = new ItemNumberDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["stringRepresentation"] = this.stringRepresentation;
    data["isSchemaCompliant"] = this.isSchemaCompliant;
    data["itemNumberSchema"] = this.itemNumberSchema
      ? this.itemNumberSchema.toJSON()
      : <any>undefined;
    if (Array.isArray(this.identifiers)) {
      data["identifiers"] = [];
      for (let item of this.identifiers) data["identifiers"].push(item);
    }
    data["isLot"] = this.isLot;
    data["hierarchyLevel"] = this.hierarchyLevel;
    data["isAttachedToPosition"] = this.isAttachedToPosition;
    return data;
  }
}

/** This class represents as identifier of a certain service specification's element and is uniquely within the service specification. */
export interface IItemNumberDto {
  /** Elements GUID identifier. */
  id: string;
  /** Will return this ItemNumber as point delimited string. Will not distinguish between upper- and lowercase and return an all-lowercase representation. Will consider first numbers, then characters, e.g. 1a is considered preceding aa. */
  stringRepresentation?: string | undefined;
  /** Indicates if the characters and the length of the Identifiers match the current ItemNumberSchema. */
  isSchemaCompliant: boolean;
  /** Used for representing and validating this ItemNumber. */
  itemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** Collection of the single identifiers in this ItemNumber. P.e., "02.03.004" will have three elements "02", "03", and "004". Since ReadOnlyObservableCollection`1 does have the event set to protected, it can be accessed like this: (itemNumber.Identifiers as INotifyCollectionChanged).CollectionChanged */
  identifiers?: string[] | undefined;
  /** This indicates if this item number is at the lot level. Find out more about lots in the documentation. */
  isLot: boolean;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel: number;
  /** This property indicates if this ItemNumber is attached to an object of the Position type. */
  isAttachedToPosition: boolean;
}

/** This is a classification for Position elements. */
export enum PositionTypeDto {
  Regular = "Regular",
  Optional = "Optional",
  Alternative = "Alternative",
}

/** This indicates the price type of a IPricedElement. */
export enum PriceTypeDto {
  WithTotal = "WithTotal",
  WithoutTotal = "WithoutTotal",
}

/** The service type describes the type of service a Position represents. */
export enum ServiceTypeDto {
  Regular = "Regular",
  HourlyPaidWork = "HourlyPaidWork",
}

/** This class represents data about products and their vendor */
export class ProductDataDto implements IProductDataDto {
  /** Elements GUID identifier. */
  id!: string;
  /** This PartyInformation is used to describe details about the vendor of this ProductData. */
  vendor?: PartyInformationDto | undefined;
  /** The collection of ArticleData that describe this product, e.g. a pipe product could be composed out of multiple pipe segments and fittings. */
  articles?: ArticleDataDto[] | undefined;
  /** Short description for this ITextElement element. */
  shortText?: string | undefined;
  /** Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;

  constructor(data?: IProductDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.vendor = _data["vendor"]
        ? PartyInformationDto.fromJS(_data["vendor"])
        : <any>undefined;
      if (Array.isArray(_data["articles"])) {
        this.articles = [] as any;
        for (let item of _data["articles"])
          this.articles!.push(ArticleDataDto.fromJS(item));
      }
      this.shortText = _data["shortText"];
      this.longText = _data["longText"];
      this.htmlLongText = _data["htmlLongText"];
    }
  }

  static fromJS(data: any): ProductDataDto {
    data = typeof data === "object" ? data : {};
    let result = new ProductDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
    if (Array.isArray(this.articles)) {
      data["articles"] = [];
      for (let item of this.articles) data["articles"].push(item.toJSON());
    }
    data["shortText"] = this.shortText;
    data["longText"] = this.longText;
    data["htmlLongText"] = this.htmlLongText;
    return data;
  }
}

/** This class represents data about products and their vendor */
export interface IProductDataDto {
  /** Elements GUID identifier. */
  id: string;
  /** This PartyInformation is used to describe details about the vendor of this ProductData. */
  vendor?: PartyInformationDto | undefined;
  /** The collection of ArticleData that describe this product, e.g. a pipe product could be composed out of multiple pipe segments and fittings. */
  articles?: ArticleDataDto[] | undefined;
  /** Short description for this ITextElement element. */
  shortText?: string | undefined;
  /** Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
}

/** This class represents a single article, usually used within ProductData */
export class ArticleDataDto implements IArticleDataDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The name (or brand name) for this article, usually given by the supplier or vendor. */
  name?: string | undefined;
  /** An article number that describes it, useful when integrating other systems. */
  articleNumber?: string | undefined;
  /** Quantity for this article. If this is used within a Position, the quantity here should be the quantity required for the full quantity of the position, not for a single unit. */
  quantity!: number;
  /** The unit tag for this single ArticleData. */
  unitTag?: string | undefined;
  /** This is an optional text element that can be used to further describe the ArticleData. */
  description?: string | undefined;
  /** Short description for this ITextElement element. */
  shortText?: string | undefined;
  /** Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;

  constructor(data?: IArticleDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.articleNumber = _data["articleNumber"];
      this.quantity = _data["quantity"];
      this.unitTag = _data["unitTag"];
      this.description = _data["description"];
      this.shortText = _data["shortText"];
      this.longText = _data["longText"];
      this.htmlLongText = _data["htmlLongText"];
    }
  }

  static fromJS(data: any): ArticleDataDto {
    data = typeof data === "object" ? data : {};
    let result = new ArticleDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["articleNumber"] = this.articleNumber;
    data["quantity"] = this.quantity;
    data["unitTag"] = this.unitTag;
    data["description"] = this.description;
    data["shortText"] = this.shortText;
    data["longText"] = this.longText;
    data["htmlLongText"] = this.htmlLongText;
    return data;
  }
}

/** This class represents a single article, usually used within ProductData */
export interface IArticleDataDto {
  /** Elements GUID identifier. */
  id: string;
  /** The name (or brand name) for this article, usually given by the supplier or vendor. */
  name?: string | undefined;
  /** An article number that describes it, useful when integrating other systems. */
  articleNumber?: string | undefined;
  /** Quantity for this article. If this is used within a Position, the quantity here should be the quantity required for the full quantity of the position, not for a single unit. */
  quantity: number;
  /** The unit tag for this single ArticleData. */
  unitTag?: string | undefined;
  /** This is an optional text element that can be used to further describe the ArticleData. */
  description?: string | undefined;
  /** Short description for this ITextElement element. */
  shortText?: string | undefined;
  /** Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
}

/** Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000mÂ² wall, 500mÂ² are classified as exterior walls and 500mÂ² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes. */
export class QuantityAssignmentDto implements IQuantityAssignmentDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The total quantity in this quantity assignment */
  quantity!: number;
  /** These are Catalogue that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this QuantityAssignment. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;

  constructor(data?: IQuantityAssignmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.quantity = _data["quantity"];
      if (Array.isArray(_data["projectCatalogues"])) {
        this.projectCatalogues = [] as any;
        for (let item of _data["projectCatalogues"])
          this.projectCatalogues!.push(CatalogueDto.fromJS(item));
      }
      if (Array.isArray(_data["catalogueReferences"])) {
        this.catalogueReferences = [] as any;
        for (let item of _data["catalogueReferences"])
          this.catalogueReferences!.push(CatalogueReferenceDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): QuantityAssignmentDto {
    data = typeof data === "object" ? data : {};
    let result = new QuantityAssignmentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["quantity"] = this.quantity;
    if (Array.isArray(this.projectCatalogues)) {
      data["projectCatalogues"] = [];
      for (let item of this.projectCatalogues)
        data["projectCatalogues"].push(item.toJSON());
    }
    if (Array.isArray(this.catalogueReferences)) {
      data["catalogueReferences"] = [];
      for (let item of this.catalogueReferences)
        data["catalogueReferences"].push(item.toJSON());
    }
    return data;
  }
}

/** Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000mÂ² wall, 500mÂ² are classified as exterior walls and 500mÂ² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes. */
export interface IQuantityAssignmentDto {
  /** Elements GUID identifier. */
  id: string;
  /** The total quantity in this quantity assignment */
  quantity: number;
  /** These are Catalogue that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. */
  projectCatalogues?: CatalogueDto[] | undefined;
  /** Referenced catalogues for this QuantityAssignment. */
  catalogueReferences?: CatalogueReferenceDto[] | undefined;
}

/** This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases. */
export class CommercePropertiesDto implements ICommercePropertiesDto {
  /** This maps to ArtNo in GAEB XML and represents an article number given by the supplier. */
  articleNumber?: string | undefined;
  /** This maps to EAN in GAEB XML and represents an GTIN (formerly EAN) article number. */
  eanGtinArticleNumber?: string | undefined;
  /** This maps to ArtNoID in GAEB XML and represents an ILN article number. */
  ilnArticleNumber?: string | undefined;
  /** This maps to CatalogNo in GAEB XML and represents an identifier of a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences. */
  catalogueNumber?: string | undefined;
  /** This maps to CatalogArtNo in GAEB XML and represents a key that maps to an entry in a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences. */
  catalogueArticleNumber?: string | undefined;
  /** This optional property can be used to indicate the basis for prices for a single position. Price basis means that the price is given per unit of the basis, e.g. per a pack of five when this property is set to '5'. */
  priceBasis?: number | undefined;

  constructor(data?: ICommercePropertiesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.articleNumber = _data["articleNumber"];
      this.eanGtinArticleNumber = _data["eanGtinArticleNumber"];
      this.ilnArticleNumber = _data["ilnArticleNumber"];
      this.catalogueNumber = _data["catalogueNumber"];
      this.catalogueArticleNumber = _data["catalogueArticleNumber"];
      this.priceBasis = _data["priceBasis"];
    }
  }

  static fromJS(data: any): CommercePropertiesDto {
    data = typeof data === "object" ? data : {};
    let result = new CommercePropertiesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["articleNumber"] = this.articleNumber;
    data["eanGtinArticleNumber"] = this.eanGtinArticleNumber;
    data["ilnArticleNumber"] = this.ilnArticleNumber;
    data["catalogueNumber"] = this.catalogueNumber;
    data["catalogueArticleNumber"] = this.catalogueArticleNumber;
    data["priceBasis"] = this.priceBasis;
    return data;
  }
}

/** This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases. */
export interface ICommercePropertiesDto {
  /** This maps to ArtNo in GAEB XML and represents an article number given by the supplier. */
  articleNumber?: string | undefined;
  /** This maps to EAN in GAEB XML and represents an GTIN (formerly EAN) article number. */
  eanGtinArticleNumber?: string | undefined;
  /** This maps to ArtNoID in GAEB XML and represents an ILN article number. */
  ilnArticleNumber?: string | undefined;
  /** This maps to CatalogNo in GAEB XML and represents an identifier of a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences. */
  catalogueNumber?: string | undefined;
  /** This maps to CatalogArtNo in GAEB XML and represents a key that maps to an entry in a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences. */
  catalogueArticleNumber?: string | undefined;
  /** This optional property can be used to indicate the basis for prices for a single position. Price basis means that the price is given per unit of the basis, e.g. per a pack of five when this property is set to '5'. */
  priceBasis?: number | undefined;
}

/** This class represents the linking to a complementary position with a specific quantity set. For example, Position 'A' could be complementing Position 'B' with a total quantity of 20 units */
export class ComplementedByQuantityDto implements IComplementedByQuantityDto {
  /** The quantity that is complemented. E.g., if the base position has a quantity of 100 mÂ² of a brick wall, a complementing position might be for 'walls that exceed 3 m height' and for a total quantity of 10 mÂ². */
  quantity!: number;
  /** This is the reference to the Id of the Position that is complementing. This means it does NOT reference the base position but the one that contains the actual addition. */
  complementingPositionId?: string | undefined;

  constructor(data?: IComplementedByQuantityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.quantity = _data["quantity"];
      this.complementingPositionId = _data["complementingPositionId"];
    }
  }

  static fromJS(data: any): ComplementedByQuantityDto {
    data = typeof data === "object" ? data : {};
    let result = new ComplementedByQuantityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["quantity"] = this.quantity;
    data["complementingPositionId"] = this.complementingPositionId;
    return data;
  }
}

/** This class represents the linking to a complementary position with a specific quantity set. For example, Position 'A' could be complementing Position 'B' with a total quantity of 20 units */
export interface IComplementedByQuantityDto {
  /** The quantity that is complemented. E.g., if the base position has a quantity of 100 mÂ² of a brick wall, a complementing position might be for 'walls that exceed 3 m height' and for a total quantity of 10 mÂ². */
  quantity: number;
  /** This is the reference to the Id of the Position that is complementing. This means it does NOT reference the base position but the one that contains the actual addition. */
  complementingPositionId?: string | undefined;
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for Positions and extends the OenormProperties base class. */
export class OenormPositionPropertiesDto
  implements IOenormPositionPropertiesDto
{
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode!: OenormOriginCodeDto;
  /** This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in Ã–Norm. */
  openingTextIsFreeText!: boolean;
  /** This indicates if the Ã–Norm 'wesentliche position' mark is set */
  isMainPosition!: boolean;
  /** This indicates if the Ã–Norm position was a 'ungeteilteposition' (undivided position). This will only be taken into account when the position is also the sole element inside it's parent group */
  isUndividedPosition!: boolean;
  /** In some Ã–Norm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText ' ' OenormShortTextAddition needs to match the ShortText. */
  oenormShortText?: string | undefined;
  /** In some Ã–Norm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText ' ' OenormShortTextAddition needs to match the ShortText. */
  oenormShortTextAddition?: string | undefined;

  constructor(data?: IOenormPositionPropertiesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.originCode = _data["originCode"];
      this.openingTextIsFreeText = _data["openingTextIsFreeText"];
      this.isMainPosition = _data["isMainPosition"];
      this.isUndividedPosition = _data["isUndividedPosition"];
      this.oenormShortText = _data["oenormShortText"];
      this.oenormShortTextAddition = _data["oenormShortTextAddition"];
    }
  }

  static fromJS(data: any): OenormPositionPropertiesDto {
    data = typeof data === "object" ? data : {};
    let result = new OenormPositionPropertiesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["originCode"] = this.originCode;
    data["openingTextIsFreeText"] = this.openingTextIsFreeText;
    data["isMainPosition"] = this.isMainPosition;
    data["isUndividedPosition"] = this.isUndividedPosition;
    data["oenormShortText"] = this.oenormShortText;
    data["oenormShortTextAddition"] = this.oenormShortTextAddition;
    return data;
  }
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for Positions and extends the OenormProperties base class. */
export interface IOenormPositionPropertiesDto {
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode: OenormOriginCodeDto;
  /** This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in Ã–Norm. */
  openingTextIsFreeText: boolean;
  /** This indicates if the Ã–Norm 'wesentliche position' mark is set */
  isMainPosition: boolean;
  /** This indicates if the Ã–Norm position was a 'ungeteilteposition' (undivided position). This will only be taken into account when the position is also the sole element inside it's parent group */
  isUndividedPosition: boolean;
  /** In some Ã–Norm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText ' ' OenormShortTextAddition needs to match the ShortText. */
  oenormShortText?: string | undefined;
  /** In some Ã–Norm formats, the short text can have it's own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText ' ' OenormShortTextAddition needs to match the ShortText. */
  oenormShortTextAddition?: string | undefined;
}

/** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
export enum OenormOriginCodeDto {
  Unknown = "Unknown",
  FreeText = "FreeText",
  AdditionDescription = "AdditionDescription",
}

/** This enumeration represents the status of an addendum, 'Nachtrag' in German */
export enum AddendumStatusDto {
  Unknown = "Unknown",
  Recognized = "Recognized",
  Filed = "Filed",
  Offered = "Offered",
  Withdrawn = "Withdrawn",
  Rejected = "Rejected",
  RejectionObjected = "RejectionObjected",
  FormallyAcknowledged = "FormallyAcknowledged",
  Approved = "Approved",
}

/** This enum represents the different ways in which a complementing position type can be specified. It is typically only used in GAEB exports, since in Dangl.AVA, complementing positions are always explicitly referenced. */
export enum PositionComplementingTypeDto {
  Undefined = "Undefined",
  AllPreviousMarkedPositions = "AllPreviousMarkedPositions",
  AllPreviousPositions = "AllPreviousPositions",
  ReferencedPositions = "ReferencedPositions",
}

/** An ExecutionDescription is used to give more details for certain items, especially on how they are meant to be executed. */
export class ExecutionDescriptionDto
  extends IElementDto
  implements IExecutionDescriptionDto
{
  /** Blocks within an ExecutionDescription contain the actual information. */
  blocks?: NoteTextDto[] | undefined;
  /** Labels this ExecutionDescription. */
  label?: string | undefined;
  /** Uniquely identifies this ExecutionDescription. */
  identifier?: string | undefined;
  elementType?: string | undefined;

  constructor(data?: IExecutionDescriptionDto) {
    super(data);
    this._discriminator = "ExecutionDescriptionDto";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (Array.isArray(_data["blocks"])) {
        this.blocks = [] as any;
        for (let item of _data["blocks"])
          this.blocks!.push(NoteTextDto.fromJS(item));
      }
      this.label = _data["label"];
      this.identifier = _data["identifier"];
      this.elementType = _data["elementType"];
    }
  }

  static fromJS(data: any): ExecutionDescriptionDto {
    data = typeof data === "object" ? data : {};
    let result = new ExecutionDescriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.blocks)) {
      data["blocks"] = [];
      for (let item of this.blocks) data["blocks"].push(item.toJSON());
    }
    data["label"] = this.label;
    data["identifier"] = this.identifier;
    data["elementType"] = this.elementType;
    super.toJSON(data);
    return data;
  }
}

/** An ExecutionDescription is used to give more details for certain items, especially on how they are meant to be executed. */
export interface IExecutionDescriptionDto extends IIElementDto {
  /** Blocks within an ExecutionDescription contain the actual information. */
  blocks?: NoteTextDto[] | undefined;
  /** Labels this ExecutionDescription. */
  label?: string | undefined;
  /** Uniquely identifies this ExecutionDescription. */
  identifier?: string | undefined;
  elementType?: string | undefined;
}

/** Represents an element that holds text information. */
export class NoteTextDto extends IElementDto implements INoteTextDto {
  /** If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true. */
  isOpeningText!: boolean;
  /** If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true. */
  isClosingText!: boolean;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType!: AdditionTypeDto;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export. */
  identifier?: string | undefined;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  elementType?: string | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for NoteTexts. */
  oenormNoteTextProperties?: OenormNoteTextPropertiesDto | undefined;
  readonly hasBidderCommentInHtmlLongText!: boolean;

  constructor(data?: INoteTextDto) {
    super(data);
    this._discriminator = "NoteTextDto";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.isOpeningText = _data["isOpeningText"];
      this.isClosingText = _data["isClosingText"];
      this.shortText = _data["shortText"];
      this.additionType = _data["additionType"];
      this.longText = _data["longText"];
      this.htmlLongText = _data["htmlLongText"];
      this.identifier = _data["identifier"];
      this.standardizedDescription = _data["standardizedDescription"]
        ? StandardizedDescriptionDto.fromJS(_data["standardizedDescription"])
        : <any>undefined;
      this.elementType = _data["elementType"];
      this.descriptionId = _data["descriptionId"];
      this.oenormNoteTextProperties = _data["oenormNoteTextProperties"]
        ? OenormNoteTextPropertiesDto.fromJS(_data["oenormNoteTextProperties"])
        : <any>undefined;
      (<any>this).hasBidderCommentInHtmlLongText =
        _data["hasBidderCommentInHtmlLongText"];
    }
  }

  static fromJS(data: any): NoteTextDto {
    data = typeof data === "object" ? data : {};
    let result = new NoteTextDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isOpeningText"] = this.isOpeningText;
    data["isClosingText"] = this.isClosingText;
    data["shortText"] = this.shortText;
    data["additionType"] = this.additionType;
    data["longText"] = this.longText;
    data["htmlLongText"] = this.htmlLongText;
    data["identifier"] = this.identifier;
    data["standardizedDescription"] = this.standardizedDescription
      ? this.standardizedDescription.toJSON()
      : <any>undefined;
    data["elementType"] = this.elementType;
    data["descriptionId"] = this.descriptionId;
    data["oenormNoteTextProperties"] = this.oenormNoteTextProperties
      ? this.oenormNoteTextProperties.toJSON()
      : <any>undefined;
    data["hasBidderCommentInHtmlLongText"] =
      this.hasBidderCommentInHtmlLongText;
    super.toJSON(data);
    return data;
  }
}

/** Represents an element that holds text information. */
export interface INoteTextDto extends IIElementDto {
  /** If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true. */
  isOpeningText: boolean;
  /** If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true. */
  isClosingText: boolean;
  /** Short description for this DescriptionBase element. */
  shortText?: string | undefined;
  /** Indicates if this DescriptionBase element contains Buyer or Bidder additions to the text. */
  additionType: AdditionTypeDto;
  /** Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText. */
  longText?: string | undefined;
  /** This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out. */
  htmlLongText?: string | undefined;
  /** This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export. */
  identifier?: string | undefined;
  /** This represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding. */
  standardizedDescription?: StandardizedDescriptionDto | undefined;
  elementType?: string | undefined;
  /** This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It's different to an elements identifier in that it should only apply to the description component, meaning the text itself. */
  descriptionId?: string | undefined;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for NoteTexts. */
  oenormNoteTextProperties?: OenormNoteTextPropertiesDto | undefined;
  hasBidderCommentInHtmlLongText: boolean;
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for NoteTexts. */
export class OenormNoteTextPropertiesDto
  implements IOenormNoteTextPropertiesDto
{
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode!: OenormOriginCodeDto;

  constructor(data?: IOenormNoteTextPropertiesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.originCode = _data["originCode"];
    }
  }

  static fromJS(data: any): OenormNoteTextPropertiesDto {
    data = typeof data === "object" ? data : {};
    let result = new OenormNoteTextPropertiesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["originCode"] = this.originCode;
    return data;
  }
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. It is special for NoteTexts. */
export interface IOenormNoteTextPropertiesDto {
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode: OenormOriginCodeDto;
}

/** This is a grouping IElement that holds other IElements within. */
export class ServiceSpecificationGroupDto
  extends IElementDto
  implements IServiceSpecificationGroupDto
{
  /** The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements. */
  readonly projectHourlyWage!: number;
  /** The tax rate that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectTaxRate!: number;
  /** The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project. */
  projectPriceComponents?: string[] | undefined;
  /** The ItemNumberSchema that is used within this project. */
  projectItemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** The IElements within this ElementContainerBase. */
  elements?: IElementDto[] | undefined;
  /** The label used in the parent Project to mark labour time, e.g. "Hours" or "Stunden". */
  readonly projectLabourTimeLabel?: string | undefined;
  /** Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers. */
  readonly containsDuplicateItemNumbers!: boolean;
  /** Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers. */
  readonly containsDuplicateElementIds!: boolean;
  /** Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateItemNumbers!: boolean;
  /** Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateElementIds!: boolean;
  /** Price composition by tax rate. */
  totalPriceGrossByTaxRate?: GrossPriceComponentDto[] | undefined;
  /** Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once. */
  ignoreChildPriceUpdates!: boolean;
  /** Net price after applied deductions. */
  readonly deductedPrice!: number;
  /** Factor of applied deductions to the total price. For example, "0.03" means that a 3% deduction is to be applied. */
  deductionFactor!: number;
  /** The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum. */
  absoluteDeduction?: number | undefined;
  /** Will return this ElementContainerBase's total price. */
  readonly totalPrice!: number;
  /** The total gross price for this ElementContainerBase including all child elements. */
  readonly totalPriceGross!: number;
  /** Total gross price after applied deductions. */
  readonly totalPriceGrossDeducted!: number;
  /** Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not. */
  priceType!: PriceTypeDto;
  /** Description for this ServiceSpecificationGroup. */
  shortText?: string | undefined;
  /** Indicates if this service specification group is commissioned (and therefore should be executed), postponed for later or undefined. */
  comissionStatus!: ComissionStatusDto;
  /** The ItemNumber for this INumberedElement interface. */
  itemNumber?: ItemNumberDto | undefined;
  elementType?: string | undefined;
  /** This indicates if this group is the parent of a lot. See the documentation for more information about working with lots. */
  readonly isLot!: boolean;
  /** If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to "WithoutTotal" so this group does not factor into total costs. The PriceType is not changed when this property is set */
  alternativeTo?: string | undefined;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. */
  oenormProperties?: OenormPropertiesDto | undefined;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel!: number;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;

  constructor(data?: IServiceSpecificationGroupDto) {
    super(data);
    this._discriminator = "ServiceSpecificationGroupDto";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      (<any>this).projectHourlyWage = _data["projectHourlyWage"];
      this.projectTaxRate = _data["projectTaxRate"];
      if (Array.isArray(_data["projectPriceComponents"])) {
        this.projectPriceComponents = [] as any;
        for (let item of _data["projectPriceComponents"])
          this.projectPriceComponents!.push(item);
      }
      this.projectItemNumberSchema = _data["projectItemNumberSchema"]
        ? ItemNumberSchemaDto.fromJS(_data["projectItemNumberSchema"])
        : <any>undefined;
      if (Array.isArray(_data["elements"])) {
        this.elements = [] as any;
        for (let item of _data["elements"])
          this.elements!.push(IElementDto.fromJS(item));
      }
      (<any>this).projectLabourTimeLabel = _data["projectLabourTimeLabel"];
      (<any>this).containsDuplicateItemNumbers =
        _data["containsDuplicateItemNumbers"];
      (<any>this).containsDuplicateElementIds =
        _data["containsDuplicateElementIds"];
      this.ignoreDuplicateItemNumbers = _data["ignoreDuplicateItemNumbers"];
      this.ignoreDuplicateElementIds = _data["ignoreDuplicateElementIds"];
      if (Array.isArray(_data["totalPriceGrossByTaxRate"])) {
        this.totalPriceGrossByTaxRate = [] as any;
        for (let item of _data["totalPriceGrossByTaxRate"])
          this.totalPriceGrossByTaxRate!.push(
            GrossPriceComponentDto.fromJS(item)
          );
      }
      this.ignoreChildPriceUpdates = _data["ignoreChildPriceUpdates"];
      (<any>this).deductedPrice = _data["deductedPrice"];
      this.deductionFactor = _data["deductionFactor"];
      this.absoluteDeduction = _data["absoluteDeduction"];
      (<any>this).totalPrice = _data["totalPrice"];
      (<any>this).totalPriceGross = _data["totalPriceGross"];
      (<any>this).totalPriceGrossDeducted = _data["totalPriceGrossDeducted"];
      this.priceType = _data["priceType"];
      this.shortText = _data["shortText"];
      this.comissionStatus = _data["comissionStatus"];
      this.itemNumber = _data["itemNumber"]
        ? ItemNumberDto.fromJS(_data["itemNumber"])
        : <any>undefined;
      this.elementType = _data["elementType"];
      (<any>this).isLot = _data["isLot"];
      this.alternativeTo = _data["alternativeTo"];
      this.oenormProperties = _data["oenormProperties"]
        ? OenormPropertiesDto.fromJS(_data["oenormProperties"])
        : <any>undefined;
      this.hierarchyLevel = _data["hierarchyLevel"];
      this.addendumStatus = _data["addendumStatus"];
    }
  }

  static fromJS(data: any): ServiceSpecificationGroupDto {
    data = typeof data === "object" ? data : {};
    let result = new ServiceSpecificationGroupDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["projectHourlyWage"] = this.projectHourlyWage;
    data["projectTaxRate"] = this.projectTaxRate;
    if (Array.isArray(this.projectPriceComponents)) {
      data["projectPriceComponents"] = [];
      for (let item of this.projectPriceComponents)
        data["projectPriceComponents"].push(item);
    }
    data["projectItemNumberSchema"] = this.projectItemNumberSchema
      ? this.projectItemNumberSchema.toJSON()
      : <any>undefined;
    if (Array.isArray(this.elements)) {
      data["elements"] = [];
      for (let item of this.elements) data["elements"].push(item.toJSON());
    }
    data["projectLabourTimeLabel"] = this.projectLabourTimeLabel;
    data["containsDuplicateItemNumbers"] = this.containsDuplicateItemNumbers;
    data["containsDuplicateElementIds"] = this.containsDuplicateElementIds;
    data["ignoreDuplicateItemNumbers"] = this.ignoreDuplicateItemNumbers;
    data["ignoreDuplicateElementIds"] = this.ignoreDuplicateElementIds;
    if (Array.isArray(this.totalPriceGrossByTaxRate)) {
      data["totalPriceGrossByTaxRate"] = [];
      for (let item of this.totalPriceGrossByTaxRate)
        data["totalPriceGrossByTaxRate"].push(item.toJSON());
    }
    data["ignoreChildPriceUpdates"] = this.ignoreChildPriceUpdates;
    data["deductedPrice"] = this.deductedPrice;
    data["deductionFactor"] = this.deductionFactor;
    data["absoluteDeduction"] = this.absoluteDeduction;
    data["totalPrice"] = this.totalPrice;
    data["totalPriceGross"] = this.totalPriceGross;
    data["totalPriceGrossDeducted"] = this.totalPriceGrossDeducted;
    data["priceType"] = this.priceType;
    data["shortText"] = this.shortText;
    data["comissionStatus"] = this.comissionStatus;
    data["itemNumber"] = this.itemNumber
      ? this.itemNumber.toJSON()
      : <any>undefined;
    data["elementType"] = this.elementType;
    data["isLot"] = this.isLot;
    data["alternativeTo"] = this.alternativeTo;
    data["oenormProperties"] = this.oenormProperties
      ? this.oenormProperties.toJSON()
      : <any>undefined;
    data["hierarchyLevel"] = this.hierarchyLevel;
    data["addendumStatus"] = this.addendumStatus;
    super.toJSON(data);
    return data;
  }
}

/** This is a grouping IElement that holds other IElements within. */
export interface IServiceSpecificationGroupDto extends IIElementDto {
  /** The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectHourlyWage: number;
  /** The tax rate that is used within this ElementContainerBase. Will be propagated to child elements. */
  projectTaxRate: number;
  /** The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project. */
  projectPriceComponents?: string[] | undefined;
  /** The ItemNumberSchema that is used within this project. */
  projectItemNumberSchema?: ItemNumberSchemaDto | undefined;
  /** The IElements within this ElementContainerBase. */
  elements?: IElementDto[] | undefined;
  /** The label used in the parent Project to mark labour time, e.g. "Hours" or "Stunden". */
  projectLabourTimeLabel?: string | undefined;
  /** Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers. */
  containsDuplicateItemNumbers: boolean;
  /** Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers. */
  containsDuplicateElementIds: boolean;
  /** Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateItemNumbers: boolean;
  /** Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes. */
  ignoreDuplicateElementIds: boolean;
  /** Price composition by tax rate. */
  totalPriceGrossByTaxRate?: GrossPriceComponentDto[] | undefined;
  /** Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once. */
  ignoreChildPriceUpdates: boolean;
  /** Net price after applied deductions. */
  deductedPrice: number;
  /** Factor of applied deductions to the total price. For example, "0.03" means that a 3% deduction is to be applied. */
  deductionFactor: number;
  /** The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum. */
  absoluteDeduction?: number | undefined;
  /** Will return this ElementContainerBase's total price. */
  totalPrice: number;
  /** The total gross price for this ElementContainerBase including all child elements. */
  totalPriceGross: number;
  /** Total gross price after applied deductions. */
  totalPriceGrossDeducted: number;
  /** Indicates the PriceType of this ElementContainerBase, whether it should factor into total costs or not. */
  priceType: PriceTypeDto;
  /** Description for this ServiceSpecificationGroup. */
  shortText?: string | undefined;
  /** Indicates if this service specification group is commissioned (and therefore should be executed), postponed for later or undefined. */
  comissionStatus: ComissionStatusDto;
  /** The ItemNumber for this INumberedElement interface. */
  itemNumber?: ItemNumberDto | undefined;
  elementType?: string | undefined;
  /** This indicates if this group is the parent of a lot. See the documentation for more information about working with lots. */
  isLot: boolean;
  /** If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to "WithoutTotal" so this group does not factor into total costs. The PriceType is not changed when this property is set */
  alternativeTo?: string | undefined;
  /** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. */
  oenormProperties?: OenormPropertiesDto | undefined;
  /** This is a zero based hierarchy level. It's set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element. */
  hierarchyLevel: number;
  /** This indicates, if this element is part of an addendum an, if yes, with what status. */
  addendumStatus?: AddendumStatusDto | undefined;
}

/** This is used in an ElementContainerBase to hold the price composition. */
export class GrossPriceComponentDto implements IGrossPriceComponentDto {
  /** This components tax rate. */
  taxRate!: number;
  /** This is the factor of applied deductions for this component */
  deductionFactor!: number;
  /** The total net price for all components of a given tax rate. */
  totalNet!: number;
  /** The resulting price component after applied deductions */
  readonly totalDeducted!: number;
  /** The total tax amount for all components of a given tax rate. */
  readonly totalTax!: number;
  /** The total gross price for all components of a given tax rate. */
  readonly totalGross!: number;
  /** The total gross price for all components of a given tax rate, after applied deductions. */
  readonly totalGrossDeducted!: number;
  /** The total tax amount for all components of a given tax rate, after applied deductions. */
  readonly totalTaxDeducted!: number;

  constructor(data?: IGrossPriceComponentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.taxRate = _data["taxRate"];
      this.deductionFactor = _data["deductionFactor"];
      this.totalNet = _data["totalNet"];
      (<any>this).totalDeducted = _data["totalDeducted"];
      (<any>this).totalTax = _data["totalTax"];
      (<any>this).totalGross = _data["totalGross"];
      (<any>this).totalGrossDeducted = _data["totalGrossDeducted"];
      (<any>this).totalTaxDeducted = _data["totalTaxDeducted"];
    }
  }

  static fromJS(data: any): GrossPriceComponentDto {
    data = typeof data === "object" ? data : {};
    let result = new GrossPriceComponentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["taxRate"] = this.taxRate;
    data["deductionFactor"] = this.deductionFactor;
    data["totalNet"] = this.totalNet;
    data["totalDeducted"] = this.totalDeducted;
    data["totalTax"] = this.totalTax;
    data["totalGross"] = this.totalGross;
    data["totalGrossDeducted"] = this.totalGrossDeducted;
    data["totalTaxDeducted"] = this.totalTaxDeducted;
    return data;
  }
}

/** This is used in an ElementContainerBase to hold the price composition. */
export interface IGrossPriceComponentDto {
  /** This components tax rate. */
  taxRate: number;
  /** This is the factor of applied deductions for this component */
  deductionFactor: number;
  /** The total net price for all components of a given tax rate. */
  totalNet: number;
  /** The resulting price component after applied deductions */
  totalDeducted: number;
  /** The total tax amount for all components of a given tax rate. */
  totalTax: number;
  /** The total gross price for all components of a given tax rate. */
  totalGross: number;
  /** The total gross price for all components of a given tax rate, after applied deductions. */
  totalGrossDeducted: number;
  /** The total tax amount for all components of a given tax rate, after applied deductions. */
  totalTaxDeducted: number;
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. */
export class OenormPropertiesDto implements IOenormPropertiesDto {
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode!: OenormOriginCodeDto;
  /** This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in Ã–Norm. */
  openingTextIsFreeText!: boolean;

  constructor(data?: IOenormPropertiesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.originCode = _data["originCode"];
      this.openingTextIsFreeText = _data["openingTextIsFreeText"];
    }
  }

  static fromJS(data: any): OenormPropertiesDto {
    data = typeof data === "object" ? data : {};
    let result = new OenormPropertiesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["originCode"] = this.originCode;
    data["openingTextIsFreeText"] = this.openingTextIsFreeText;
    return data;
  }
}

/** This class models special properties that only apply to some exchange scenarios where Ã–Norm is used. */
export interface IOenormPropertiesDto {
  /** This indicates where the content of this element originates, if set. It corresponds to 'herkunftskennzeichen' in Ã–Norm */
  originCode: OenormOriginCodeDto;
  /** This marks if the opening texts within this element are considered free text. It corresponds to 'vorbemerkungskennzeichen' in Ã–Norm. */
  openingTextIsFreeText: boolean;
}

/** Indicates a ServiceSpecification's exchange phase, based on the GAEB exchange phases. */
export enum ExchangePhaseDto {
  Undefined = "Undefined",
  Base = "Base",
  CostEstimate = "CostEstimate",
  OfferRequest = "OfferRequest",
  Offer = "Offer",
  SideOffer = "SideOffer",
  Grant = "Grant",
}

/** Indicates where a service specification was originally created. */
export enum OriginDto {
  Self = "Self",
  Gaeb90 = "Gaeb90",
  Gaeb2000 = "Gaeb2000",
  GaebXml = "GaebXml",
  Oenorm = "Oenorm",
  Reb = "Reb",
  Sia = "Sia",
}

/** Holds global price information for a ServiceSpecification */
export class PriceInformationDto implements IPriceInformationDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The amount of currency per one hour of manual labour work in this project. */
  hourlyWage!: number;
  /** The final, total price will be deducted by this rate. */
  deductionFactor!: number;
  /** This is given when there is only one flat price for the whole service specification. */
  flatSum!: number;
  /** Global tax rate for the project. Note that certain elements may have a different, specific tax rate. */
  taxRate!: number;
  /** Trade discounts for offered in this ServiceSpecification. */
  tradeDiscounts?: TradeDiscountDto[] | undefined;

  constructor(data?: IPriceInformationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.hourlyWage = _data["hourlyWage"];
      this.deductionFactor = _data["deductionFactor"];
      this.flatSum = _data["flatSum"];
      this.taxRate = _data["taxRate"];
      if (Array.isArray(_data["tradeDiscounts"])) {
        this.tradeDiscounts = [] as any;
        for (let item of _data["tradeDiscounts"])
          this.tradeDiscounts!.push(TradeDiscountDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceInformationDto {
    data = typeof data === "object" ? data : {};
    let result = new PriceInformationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["hourlyWage"] = this.hourlyWage;
    data["deductionFactor"] = this.deductionFactor;
    data["flatSum"] = this.flatSum;
    data["taxRate"] = this.taxRate;
    if (Array.isArray(this.tradeDiscounts)) {
      data["tradeDiscounts"] = [];
      for (let item of this.tradeDiscounts)
        data["tradeDiscounts"].push(item.toJSON());
    }
    return data;
  }
}

/** Holds global price information for a ServiceSpecification */
export interface IPriceInformationDto {
  /** Elements GUID identifier. */
  id: string;
  /** The amount of currency per one hour of manual labour work in this project. */
  hourlyWage: number;
  /** The final, total price will be deducted by this rate. */
  deductionFactor: number;
  /** This is given when there is only one flat price for the whole service specification. */
  flatSum: number;
  /** Global tax rate for the project. Note that certain elements may have a different, specific tax rate. */
  taxRate: number;
  /** Trade discounts for offered in this ServiceSpecification. */
  tradeDiscounts?: TradeDiscountDto[] | undefined;
}

/** This class holds information about offered trade discounts (Skonto in German) */
export class TradeDiscountDto implements ITradeDiscountDto {
  /** Elements GUID identifier. */
  id!: string;
  /** The amount of days for how long a declared trade discount applies. Must be a positive number, negative values will be ignored and not set. */
  deadline!: number;
  /** The rate of the trade discount. */
  rate!: number;

  constructor(data?: ITradeDiscountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.deadline = _data["deadline"];
      this.rate = _data["rate"];
    }
  }

  static fromJS(data: any): TradeDiscountDto {
    data = typeof data === "object" ? data : {};
    let result = new TradeDiscountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["deadline"] = this.deadline;
    data["rate"] = this.rate;
    return data;
  }
}

/** This class holds information about offered trade discounts (Skonto in German) */
export interface ITradeDiscountDto {
  /** Elements GUID identifier. */
  id: string;
  /** The amount of days for how long a declared trade discount applies. Must be a positive number, negative values will be ignored and not set. */
  deadline: number;
  /** The rate of the trade discount. */
  rate: number;
}

/** This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months */
export class WarrantyDurationDto implements IWarrantyDurationDto {
  /** The scalar value of the duration. This value must be equal to or bigger than zero (>= 0). Negative values can not be set and will be ignored. */
  duration!: number;
  /** The unit of the duration */
  unit!: DurationUnitDto;

  constructor(data?: IWarrantyDurationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.duration = _data["duration"];
      this.unit = _data["unit"];
    }
  }

  static fromJS(data: any): WarrantyDurationDto {
    data = typeof data === "object" ? data : {};
    let result = new WarrantyDurationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["duration"] = this.duration;
    data["unit"] = this.unit;
    return data;
  }
}

/** This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months */
export interface IWarrantyDurationDto {
  /** The scalar value of the duration. This value must be equal to or bigger than zero (>= 0). Negative values can not be set and will be ignored. */
  duration: number;
  /** The unit of the duration */
  unit: DurationUnitDto;
}

/** This enumeration represents the unit of a duration */
export enum DurationUnitDto {
  Months = "Months",
  Years = "Years",
}

/** This class represents properties used in commerce exchange scenarios */
export class ServiceSpecificationCommercePropertiesDto
  implements IServiceSpecificationCommercePropertiesDto
{
  /** The date until the price is valid or fixed. */
  fixedPriceDate?: Date | undefined;
  /** The date of the delivery voucher note. */
  deliveryVoucherDate?: Date | undefined;
  /** The actual date of delivery. */
  deliveryDate?: Date | undefined;
  /** The number of the inquiry, usually in a context of offer requests. */
  inquiryNumber?: string | undefined;
  /** The number of the offer, usually in a context of an offer. */
  offerNumber?: string | undefined;
  /** The order number, usually in the context of a grant or contract. */
  orderNumber?: string | undefined;
  /** The order confirmation number */
  orderConfirmationNumber?: string | undefined;
  /** The number of the delivery, e.g. on the delivery note voucher. */
  deliveryNumber?: string | undefined;
  /** The reference number of the customer / buyer. */
  customerReferenceNumber?: string | undefined;
  /** The reference number of the supplier / bidder. */
  supplierReferenceNumber?: string | undefined;
  /** The type of shippment. */
  shippingType?: string | undefined;
  /** The type of the price inquiry. */
  inquiryType!: CommerceInquiryTypeDto;

  constructor(data?: IServiceSpecificationCommercePropertiesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fixedPriceDate = _data["fixedPriceDate"]
        ? new Date(_data["fixedPriceDate"].toString())
        : <any>undefined;
      this.deliveryVoucherDate = _data["deliveryVoucherDate"]
        ? new Date(_data["deliveryVoucherDate"].toString())
        : <any>undefined;
      this.deliveryDate = _data["deliveryDate"]
        ? new Date(_data["deliveryDate"].toString())
        : <any>undefined;
      this.inquiryNumber = _data["inquiryNumber"];
      this.offerNumber = _data["offerNumber"];
      this.orderNumber = _data["orderNumber"];
      this.orderConfirmationNumber = _data["orderConfirmationNumber"];
      this.deliveryNumber = _data["deliveryNumber"];
      this.customerReferenceNumber = _data["customerReferenceNumber"];
      this.supplierReferenceNumber = _data["supplierReferenceNumber"];
      this.shippingType = _data["shippingType"];
      this.inquiryType = _data["inquiryType"];
    }
  }

  static fromJS(data: any): ServiceSpecificationCommercePropertiesDto {
    data = typeof data === "object" ? data : {};
    let result = new ServiceSpecificationCommercePropertiesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["fixedPriceDate"] = this.fixedPriceDate
      ? this.fixedPriceDate.toISOString()
      : <any>undefined;
    data["deliveryVoucherDate"] = this.deliveryVoucherDate
      ? this.deliveryVoucherDate.toISOString()
      : <any>undefined;
    data["deliveryDate"] = this.deliveryDate
      ? this.deliveryDate.toISOString()
      : <any>undefined;
    data["inquiryNumber"] = this.inquiryNumber;
    data["offerNumber"] = this.offerNumber;
    data["orderNumber"] = this.orderNumber;
    data["orderConfirmationNumber"] = this.orderConfirmationNumber;
    data["deliveryNumber"] = this.deliveryNumber;
    data["customerReferenceNumber"] = this.customerReferenceNumber;
    data["supplierReferenceNumber"] = this.supplierReferenceNumber;
    data["shippingType"] = this.shippingType;
    data["inquiryType"] = this.inquiryType;
    return data;
  }
}

/** This class represents properties used in commerce exchange scenarios */
export interface IServiceSpecificationCommercePropertiesDto {
  /** The date until the price is valid or fixed. */
  fixedPriceDate?: Date | undefined;
  /** The date of the delivery voucher note. */
  deliveryVoucherDate?: Date | undefined;
  /** The actual date of delivery. */
  deliveryDate?: Date | undefined;
  /** The number of the inquiry, usually in a context of offer requests. */
  inquiryNumber?: string | undefined;
  /** The number of the offer, usually in a context of an offer. */
  offerNumber?: string | undefined;
  /** The order number, usually in the context of a grant or contract. */
  orderNumber?: string | undefined;
  /** The order confirmation number */
  orderConfirmationNumber?: string | undefined;
  /** The number of the delivery, e.g. on the delivery note voucher. */
  deliveryNumber?: string | undefined;
  /** The reference number of the customer / buyer. */
  customerReferenceNumber?: string | undefined;
  /** The reference number of the supplier / bidder. */
  supplierReferenceNumber?: string | undefined;
  /** The type of shippment. */
  shippingType?: string | undefined;
  /** The type of the price inquiry. */
  inquiryType: CommerceInquiryTypeDto;
}

/** This enum represents types of price inquiries */
export enum CommerceInquiryTypeDto {
  Unknown = "Unknown",
  Project = "Project",
  Immediate = "Immediate",
  Exhibition = "Exhibition",
}

/** Data transfer class to convey api errors */
export class ApiError implements IApiError {
  /** This dictionary contains a set of all errors and their messages */
  errors?: { [key: string]: string[] } | undefined;

  constructor(data?: IApiError) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data["errors"]) {
        this.errors = {} as any;
        for (let key in _data["errors"]) {
          if (_data["errors"].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data["errors"][key] !== undefined ? _data["errors"][key] : [];
        }
      }
    }
  }

  static fromJS(data: any): ApiError {
    data = typeof data === "object" ? data : {};
    let result = new ApiError();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (this.errors) {
      data["errors"] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data["errors"])[key] = (<any>this.errors)[key];
      }
    }
    return data;
  }
}

/** Data transfer class to convey api errors */
export interface IApiError {
  /** This dictionary contains a set of all errors and their messages */
  errors?: { [key: string]: string[] } | undefined;
}

/** Represents valid GAEB target types */
export enum DestinationGaebType {
  Gaeb90 = "Gaeb90",
  Gaeb2000 = "Gaeb2000",
  Gaeb2000Commerce = "Gaeb2000Commerce",
  GaebXml_V3_1 = "GaebXml_V3_1",
  GaebXml_V3_2 = "GaebXml_V3_2",
  GaebXml_V3_2_Commerce = "GaebXml_V3_2_Commerce",
  GaebXml_V3_3 = "GaebXml_V3_3",
  GaebXml_V3_3_Commerce = "GaebXml_V3_3_Commerce",
  GaebXml_V3_3_2019 = "GaebXml_V3_3_2019",
  GaebXml_V3_3_2019_Commerce = "GaebXml_V3_3_2019_Commerce",
}

/** The GAEB exchange phase to transform to */
export enum DestinationGaebExchangePhase {
  None = "None",
  Base = "Base",
  OfferRequest = "OfferRequest",
  Offer = "Offer",
  Grant = "Grant",
  CostEstimate = "CostEstimate",
  SideOffer = "SideOffer",
}

/** Represents valid Oenorm target types */
export enum DestinationOenormType {
  Lv2015 = "Lv2015",
  Lb2015 = "Lb2015",
  B2063 = "B2063",
  Lv2009 = "Lv2009",
  Lb2009 = "Lb2009",
  Lv2021 = "Lv2021",
  Lb2021 = "Lb2021",
}

/** Represents valid REB target types */
export enum DestinationRebType {
  D11 = "D11",
  X31GaebXmlV32 = "X31GaebXmlV32",
}

/** Indicates the status of the AVACloud service */
export class GetStatus implements IGetStatus {
  /** If any problems in the service health are known, this is set to false */
  isHealthy!: boolean;
  /** The current version of the AVACloud service */
  version?: string | undefined;
  /** The environment of the current instance */
  environment?: string | undefined;

  constructor(data?: IGetStatus) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isHealthy = _data["isHealthy"];
      this.version = _data["version"];
      this.environment = _data["environment"];
    }
  }

  static fromJS(data: any): GetStatus {
    data = typeof data === "object" ? data : {};
    let result = new GetStatus();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isHealthy"] = this.isHealthy;
    data["version"] = this.version;
    data["environment"] = this.environment;
    return data;
  }
}

/** Indicates the status of the AVACloud service */
export interface IGetStatus {
  /** If any problems in the service health are known, this is set to false */
  isHealthy: boolean;
  /** The current version of the AVACloud service */
  version?: string | undefined;
  /** The environment of the current instance */
  environment?: string | undefined;
}

/** This class represents the result of a validation operation */
export class ValidationResult implements IValidationResult {
  /** Indicates if the validation produced no errors */
  isSchemaCompliant!: boolean;
  /** List of validation check results, which are usually errors */
  checkResults?: ValidationCheckResult[] | undefined;
  /** The type of the validation that was performed */
  validationType!: ValidationType;
  /** Name of the validated file */
  fileName?: string | undefined;

  constructor(data?: IValidationResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSchemaCompliant = _data["isSchemaCompliant"];
      if (Array.isArray(_data["checkResults"])) {
        this.checkResults = [] as any;
        for (let item of _data["checkResults"])
          this.checkResults!.push(ValidationCheckResult.fromJS(item));
      }
      this.validationType = _data["validationType"];
      this.fileName = _data["fileName"];
    }
  }

  static fromJS(data: any): ValidationResult {
    data = typeof data === "object" ? data : {};
    let result = new ValidationResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["isSchemaCompliant"] = this.isSchemaCompliant;
    if (Array.isArray(this.checkResults)) {
      data["checkResults"] = [];
      for (let item of this.checkResults)
        data["checkResults"].push(item.toJSON());
    }
    data["validationType"] = this.validationType;
    data["fileName"] = this.fileName;
    return data;
  }
}

/** This class represents the result of a validation operation */
export interface IValidationResult {
  /** Indicates if the validation produced no errors */
  isSchemaCompliant: boolean;
  /** List of validation check results, which are usually errors */
  checkResults?: ValidationCheckResult[] | undefined;
  /** The type of the validation that was performed */
  validationType: ValidationType;
  /** Name of the validated file */
  fileName?: string | undefined;
}

/** This class models the results of a single check performed during a validation action */
export class ValidationCheckResult implements IValidationCheckResult {
  /** The severity for this check. Usually, low severity checks do not impact
data exchange with third party applications */
  severity!: ValidationSeverity;
  /** The actual check that is represented by this result. Additional information
may be found in other properties of this class, depending on the check. */
  checkType!: ValidationCheckType;
  /** A human readable message describing the result of the check. */
  message?: string | undefined;
  /** For CheckType of types ObjectValidation */
  objectValidationCheckDetails?: ObjectValidationCheckDetails | undefined;
  /** For CheckType of types XmlSchemaCheck */
  xmlSchemaValidationCheckDetails?: XmlSchemaValidationCheckDetails | undefined;
  /** For CheckType of types ProjectValidation */
  projectValidationCheckDetails?: ProjectValidationCheckDetails | undefined;

  constructor(data?: IValidationCheckResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.severity = _data["severity"];
      this.checkType = _data["checkType"];
      this.message = _data["message"];
      this.objectValidationCheckDetails = _data["objectValidationCheckDetails"]
        ? ObjectValidationCheckDetails.fromJS(
            _data["objectValidationCheckDetails"]
          )
        : <any>undefined;
      this.xmlSchemaValidationCheckDetails = _data[
        "xmlSchemaValidationCheckDetails"
      ]
        ? XmlSchemaValidationCheckDetails.fromJS(
            _data["xmlSchemaValidationCheckDetails"]
          )
        : <any>undefined;
      this.projectValidationCheckDetails = _data[
        "projectValidationCheckDetails"
      ]
        ? ProjectValidationCheckDetails.fromJS(
            _data["projectValidationCheckDetails"]
          )
        : <any>undefined;
    }
  }

  static fromJS(data: any): ValidationCheckResult {
    data = typeof data === "object" ? data : {};
    let result = new ValidationCheckResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["severity"] = this.severity;
    data["checkType"] = this.checkType;
    data["message"] = this.message;
    data["objectValidationCheckDetails"] = this.objectValidationCheckDetails
      ? this.objectValidationCheckDetails.toJSON()
      : <any>undefined;
    data["xmlSchemaValidationCheckDetails"] = this
      .xmlSchemaValidationCheckDetails
      ? this.xmlSchemaValidationCheckDetails.toJSON()
      : <any>undefined;
    data["projectValidationCheckDetails"] = this.projectValidationCheckDetails
      ? this.projectValidationCheckDetails.toJSON()
      : <any>undefined;
    return data;
  }
}

/** This class models the results of a single check performed during a validation action */
export interface IValidationCheckResult {
  /** The severity for this check. Usually, low severity checks do not impact
data exchange with third party applications */
  severity: ValidationSeverity;
  /** The actual check that is represented by this result. Additional information
may be found in other properties of this class, depending on the check. */
  checkType: ValidationCheckType;
  /** A human readable message describing the result of the check. */
  message?: string | undefined;
  /** For CheckType of types ObjectValidation */
  objectValidationCheckDetails?: ObjectValidationCheckDetails | undefined;
  /** For CheckType of types XmlSchemaCheck */
  xmlSchemaValidationCheckDetails?: XmlSchemaValidationCheckDetails | undefined;
  /** For CheckType of types ProjectValidation */
  projectValidationCheckDetails?: ProjectValidationCheckDetails | undefined;
}

/** Indicates the severity of a check */
export enum ValidationSeverity {
  Information = "Information",
  Warning = "Warning",
  Error = "Error",
  Critical = "Critical",
}

/** Enumeration for the different types of checks performed */
export enum ValidationCheckType {
  General = "General",
  XmlSchemaCheck = "XmlSchemaCheck",
  ObjectValidation = "ObjectValidation",
  ProjectValidation = "ProjectValidation",
}

/** Basic information about Object check validation details, commonly used when checking GAEB 2000 files */
export class ObjectValidationCheckDetails
  implements IObjectValidationCheckDetails
{
  /** The path under which the element with error was found. */
  elementPath?: string | undefined;

  constructor(data?: IObjectValidationCheckDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.elementPath = _data["elementPath"];
    }
  }

  static fromJS(data: any): ObjectValidationCheckDetails {
    data = typeof data === "object" ? data : {};
    let result = new ObjectValidationCheckDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["elementPath"] = this.elementPath;
    return data;
  }
}

/** Basic information about Object check validation details, commonly used when checking GAEB 2000 files */
export interface IObjectValidationCheckDetails {
  /** The path under which the element with error was found. */
  elementPath?: string | undefined;
}

/** Check details for an XML schema validation result */
export class XmlSchemaValidationCheckDetails
  implements IXmlSchemaValidationCheckDetails
{
  /** The line number on which the validation happened */
  lineNumber!: number;
  /** The position in the line */
  linePosition!: number;

  constructor(data?: IXmlSchemaValidationCheckDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lineNumber = _data["lineNumber"];
      this.linePosition = _data["linePosition"];
    }
  }

  static fromJS(data: any): XmlSchemaValidationCheckDetails {
    data = typeof data === "object" ? data : {};
    let result = new XmlSchemaValidationCheckDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["lineNumber"] = this.lineNumber;
    data["linePosition"] = this.linePosition;
    return data;
  }
}

/** Check details for an XML schema validation result */
export interface IXmlSchemaValidationCheckDetails {
  /** The line number on which the validation happened */
  lineNumber: number;
  /** The position in the line */
  linePosition: number;
}

/** Check details specificly for checking ProjectDto objects */
export class ProjectValidationCheckDetails
  implements IProjectValidationCheckDetails
{
  /** The id of the element */
  elementId!: string;

  constructor(data?: IProjectValidationCheckDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.elementId = _data["elementId"];
    }
  }

  static fromJS(data: any): ProjectValidationCheckDetails {
    data = typeof data === "object" ? data : {};
    let result = new ProjectValidationCheckDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["elementId"] = this.elementId;
    return data;
  }
}

/** Check details specificly for checking ProjectDto objects */
export interface IProjectValidationCheckDetails {
  /** The id of the element */
  elementId: string;
}

/** This enumeration represents the possible conversion targets when performing a validation */
export enum ValidationType {
  Project = "Project",
  Gaeb = "Gaeb",
  Oenorm = "Oenorm",
}

/** This enum represents the source type for a file based validation operation */
export enum FileValidationSourceType {
  Gaeb = "Gaeb",
  Oenorm = "Oenorm",
}

/** Options for validating an AVA project */
export class PostAvaProjectValidationSourceOptions
  implements IPostAvaProjectValidationSourceOptions
{
  /** The project that should be validated */
  avaProject!: ProjectDto;
  /** The index of the ServiceSpecification that should be validated. If not given, will default
to the first one in the project. */
  serviceSpecificationIndex?: number | undefined;
  /** This can optionally be specified to simulate a conversion to a specific target. */
  validationType!: ValidationType;
  /** This can optionally be supplied to test for a specific exchange phase. For example,
missing prices will only trigger errors in some specific exchange phases.
Please note: If a conversion to a specific format, e.g. GAEB or Ã–Norm, is given,
this parameter is not applied to the internal conversion. The converter options
must be set in the appropriate properties as well. */
  exchangePhase?: ExchangePhaseDto | undefined;
  /** Options for importing the AVA project */
  avaSourceOptions?: PostAvaSourceOptions | undefined;
  /** Options for conversion to Oenorm. Should be given if ValidationType is set to Oenorm. */
  oenormDestinationOptions?: PostOenormDestinationOptions | undefined;
  /** Options for conversion to GAEB. Should be given if ValidationType is set to GAEB. */
  gaebDestinationOptions?: PostGaebDestinationOptions | undefined;

  constructor(data?: IPostAvaProjectValidationSourceOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    if (!data) {
      this.avaProject = new ProjectDto();
    }
  }

  init(_data?: any) {
    if (_data) {
      this.avaProject = _data["avaProject"]
        ? ProjectDto.fromJS(_data["avaProject"])
        : new ProjectDto();
      this.serviceSpecificationIndex = _data["serviceSpecificationIndex"];
      this.validationType = _data["validationType"];
      this.exchangePhase = _data["exchangePhase"];
      this.avaSourceOptions = _data["avaSourceOptions"]
        ? PostAvaSourceOptions.fromJS(_data["avaSourceOptions"])
        : <any>undefined;
      this.oenormDestinationOptions = _data["oenormDestinationOptions"]
        ? PostOenormDestinationOptions.fromJS(_data["oenormDestinationOptions"])
        : <any>undefined;
      this.gaebDestinationOptions = _data["gaebDestinationOptions"]
        ? PostGaebDestinationOptions.fromJS(_data["gaebDestinationOptions"])
        : <any>undefined;
    }
  }

  static fromJS(data: any): PostAvaProjectValidationSourceOptions {
    data = typeof data === "object" ? data : {};
    let result = new PostAvaProjectValidationSourceOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["avaProject"] = this.avaProject
      ? this.avaProject.toJSON()
      : <any>undefined;
    data["serviceSpecificationIndex"] = this.serviceSpecificationIndex;
    data["validationType"] = this.validationType;
    data["exchangePhase"] = this.exchangePhase;
    data["avaSourceOptions"] = this.avaSourceOptions
      ? this.avaSourceOptions.toJSON()
      : <any>undefined;
    data["oenormDestinationOptions"] = this.oenormDestinationOptions
      ? this.oenormDestinationOptions.toJSON()
      : <any>undefined;
    data["gaebDestinationOptions"] = this.gaebDestinationOptions
      ? this.gaebDestinationOptions.toJSON()
      : <any>undefined;
    return data;
  }
}

/** Options for validating an AVA project */
export interface IPostAvaProjectValidationSourceOptions {
  /** The project that should be validated */
  avaProject: ProjectDto;
  /** The index of the ServiceSpecification that should be validated. If not given, will default
to the first one in the project. */
  serviceSpecificationIndex?: number | undefined;
  /** This can optionally be specified to simulate a conversion to a specific target. */
  validationType: ValidationType;
  /** This can optionally be supplied to test for a specific exchange phase. For example,
missing prices will only trigger errors in some specific exchange phases.
Please note: If a conversion to a specific format, e.g. GAEB or Ã–Norm, is given,
this parameter is not applied to the internal conversion. The converter options
must be set in the appropriate properties as well. */
  exchangePhase?: ExchangePhaseDto | undefined;
  /** Options for importing the AVA project */
  avaSourceOptions?: PostAvaSourceOptions | undefined;
  /** Options for conversion to Oenorm. Should be given if ValidationType is set to Oenorm. */
  oenormDestinationOptions?: PostOenormDestinationOptions | undefined;
  /** Options for conversion to GAEB. Should be given if ValidationType is set to GAEB. */
  gaebDestinationOptions?: PostGaebDestinationOptions | undefined;
}

/** Options for conversions from AVA */
export class PostAvaSourceOptions implements IPostAvaSourceOptions {
  /** If this is set to true, AVACloud will try to generate item numbers
and an item number schema automatically for the input project.
The operation will not have any effect if either an item number schema
is already present, or if any of the elements already has an item number. */
  tryAutoGenerateItemNumbersAndSchema!: boolean;

  constructor(data?: IPostAvaSourceOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tryAutoGenerateItemNumbersAndSchema =
        _data["tryAutoGenerateItemNumbersAndSchema"];
    }
  }

  static fromJS(data: any): PostAvaSourceOptions {
    data = typeof data === "object" ? data : {};
    let result = new PostAvaSourceOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["tryAutoGenerateItemNumbersAndSchema"] =
      this.tryAutoGenerateItemNumbersAndSchema;
    return data;
  }
}

/** Options for conversions from AVA */
export interface IPostAvaSourceOptions {
  /** If this is set to true, AVACloud will try to generate item numbers
and an item number schema automatically for the input project.
The operation will not have any effect if either an item number schema
is already present, or if any of the elements already has an item number. */
  tryAutoGenerateItemNumbersAndSchema: boolean;
}

/** Options for conversions to Oenorm */
export class PostOenormDestinationOptions
  implements IPostOenormDestinationOptions
{
  /** Defaults to Lv2015 */
  destinationOenormType!: DestinationOenormType;
  /** Defaults to false. If this is enabled, the converter will try to ensure that the project structure
can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target */
  tryRepairProjectStructure!: boolean;
  /** If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
can be disabled with this option. */
  skipTryEnforceSchemaCompliantXmlOutput!: boolean;
  /** If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
might fail in case some text content contains characters that are not allowed in XML output formats. */
  removeUnprintableCharactersFromTexts!: boolean;

  constructor(data?: IPostOenormDestinationOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.destinationOenormType = _data["destinationOenormType"];
      this.tryRepairProjectStructure = _data["tryRepairProjectStructure"];
      this.skipTryEnforceSchemaCompliantXmlOutput =
        _data["skipTryEnforceSchemaCompliantXmlOutput"];
      this.removeUnprintableCharactersFromTexts =
        _data["removeUnprintableCharactersFromTexts"];
    }
  }

  static fromJS(data: any): PostOenormDestinationOptions {
    data = typeof data === "object" ? data : {};
    let result = new PostOenormDestinationOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["destinationOenormType"] = this.destinationOenormType;
    data["tryRepairProjectStructure"] = this.tryRepairProjectStructure;
    data["skipTryEnforceSchemaCompliantXmlOutput"] =
      this.skipTryEnforceSchemaCompliantXmlOutput;
    data["removeUnprintableCharactersFromTexts"] =
      this.removeUnprintableCharactersFromTexts;
    return data;
  }
}

/** Options for conversions to Oenorm */
export interface IPostOenormDestinationOptions {
  /** Defaults to Lv2015 */
  destinationOenormType: DestinationOenormType;
  /** Defaults to false. If this is enabled, the converter will try to ensure that the project structure
can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target */
  tryRepairProjectStructure: boolean;
  /** If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for Ã–Norm targets that are Xml
based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior
can be disabled with this option. */
  skipTryEnforceSchemaCompliantXmlOutput: boolean;
  /** If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
might fail in case some text content contains characters that are not allowed in XML output formats. */
  removeUnprintableCharactersFromTexts: boolean;
}

/** Options for conversions to GAEB */
export class PostGaebDestinationOptions implements IPostGaebDestinationOptions {
  /** Defaults to GAEB XML V3.2 */
  destinationGaebType!: DestinationGaebType;
  /** Defaults to none, meaning no transformation will be done */
  targetExchangePhaseTransform!: DestinationGaebExchangePhase;
  /** Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
is exported in full to ensure that incorrectly used text additions are still preserved in the export. */
  enforceStrictOfferPhaseLongTextOutput!: boolean;
  /** Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
this might export data that was not intended to be exported, like internal quantity calculation details,
depending on what data you put in the 'QuantityComponents' property. */
  exportQuantityDetermination!: boolean;
  /** If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
might fail in case some text content contains characters that are not allowed in XML output formats. */
  removeUnprintableCharactersFromTexts!: boolean;
  /** If this is enabled, all description elements like texts and execution descriptions will be output
to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
typically not include descriptions. */
  forceIncludeDescriptions!: boolean;
  /** When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
reasons. */
  treatNullItemNumberSchemaAsInvalid!: boolean;

  constructor(data?: IPostGaebDestinationOptions) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.destinationGaebType = _data["destinationGaebType"];
      this.targetExchangePhaseTransform = _data["targetExchangePhaseTransform"];
      this.enforceStrictOfferPhaseLongTextOutput =
        _data["enforceStrictOfferPhaseLongTextOutput"];
      this.exportQuantityDetermination = _data["exportQuantityDetermination"];
      this.removeUnprintableCharactersFromTexts =
        _data["removeUnprintableCharactersFromTexts"];
      this.forceIncludeDescriptions = _data["forceIncludeDescriptions"];
      this.treatNullItemNumberSchemaAsInvalid =
        _data["treatNullItemNumberSchemaAsInvalid"];
    }
  }

  static fromJS(data: any): PostGaebDestinationOptions {
    data = typeof data === "object" ? data : {};
    let result = new PostGaebDestinationOptions();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["destinationGaebType"] = this.destinationGaebType;
    data["targetExchangePhaseTransform"] = this.targetExchangePhaseTransform;
    data["enforceStrictOfferPhaseLongTextOutput"] =
      this.enforceStrictOfferPhaseLongTextOutput;
    data["exportQuantityDetermination"] = this.exportQuantityDetermination;
    data["removeUnprintableCharactersFromTexts"] =
      this.removeUnprintableCharactersFromTexts;
    data["forceIncludeDescriptions"] = this.forceIncludeDescriptions;
    data["treatNullItemNumberSchemaAsInvalid"] =
      this.treatNullItemNumberSchemaAsInvalid;
    return data;
  }
}

/** Options for conversions to GAEB */
export interface IPostGaebDestinationOptions {
  /** Defaults to GAEB XML V3.2 */
  destinationGaebType: DestinationGaebType;
  /** Defaults to none, meaning no transformation will be done */
  targetExchangePhaseTransform: DestinationGaebExchangePhase;
  /** Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will
be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition
is exported in full to ensure that incorrectly used text additions are still preserved in the export. */
  enforceStrictOfferPhaseLongTextOutput: boolean;
  /** Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the
'QtyDeterm' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom
quantity calculations in the 'QuantityComponents' property of positions. Please see the entry for
'Quantity Determination' in the Dangl.AVA HowTo documentation section. Please be advised that enabling
this might export data that was not intended to be exported, like internal quantity calculation details,
depending on what data you put in the 'QuantityComponents' property. */
  exportQuantityDetermination: boolean;
  /** If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion
might fail in case some text content contains characters that are not allowed in XML output formats. */
  removeUnprintableCharactersFromTexts: boolean;
  /** If this is enabled, all description elements like texts and execution descriptions will be output
to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does
typically not include descriptions. */
  forceIncludeDescriptions: boolean;
  /** When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas.
With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored
and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility
reasons. */
  treatNullItemNumberSchemaAsInvalid: boolean;
}

export class LoginPost implements ILoginPost {
  identifier!: string;
  password!: string;
  staySignedIn!: boolean;

  constructor(data?: ILoginPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.identifier = _data["identifier"];
      this.password = _data["password"];
      this.staySignedIn = _data["staySignedIn"];
    }
  }

  static fromJS(data: any): LoginPost {
    data = typeof data === "object" ? data : {};
    let result = new LoginPost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["identifier"] = this.identifier;
    data["password"] = this.password;
    data["staySignedIn"] = this.staySignedIn;
    return data;
  }
}

export interface ILoginPost {
  identifier: string;
  password: string;
  staySignedIn: boolean;
}

export class TokenResponseGet implements ITokenResponseGet {
  accessToken?: string | undefined;
  error?: string | undefined;
  errorDescription?: string | undefined;
  expiresIn!: number;
  httpErrorReason?: string | undefined;
  httpStatusCode!: HttpStatusCode;
  identityToken?: string | undefined;
  isError!: boolean;
  refreshToken?: string | undefined;
  tokenType?: string | undefined;
  errorType!: ResponseErrorType;

  constructor(data?: ITokenResponseGet) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.error = _data["error"];
      this.errorDescription = _data["errorDescription"];
      this.expiresIn = _data["expiresIn"];
      this.httpErrorReason = _data["httpErrorReason"];
      this.httpStatusCode = _data["httpStatusCode"];
      this.identityToken = _data["identityToken"];
      this.isError = _data["isError"];
      this.refreshToken = _data["refreshToken"];
      this.tokenType = _data["tokenType"];
      this.errorType = _data["errorType"];
    }
  }

  static fromJS(data: any): TokenResponseGet {
    data = typeof data === "object" ? data : {};
    let result = new TokenResponseGet();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["error"] = this.error;
    data["errorDescription"] = this.errorDescription;
    data["expiresIn"] = this.expiresIn;
    data["httpErrorReason"] = this.httpErrorReason;
    data["httpStatusCode"] = this.httpStatusCode;
    data["identityToken"] = this.identityToken;
    data["isError"] = this.isError;
    data["refreshToken"] = this.refreshToken;
    data["tokenType"] = this.tokenType;
    data["errorType"] = this.errorType;
    return data;
  }
}

export interface ITokenResponseGet {
  accessToken?: string | undefined;
  error?: string | undefined;
  errorDescription?: string | undefined;
  expiresIn: number;
  httpErrorReason?: string | undefined;
  httpStatusCode: HttpStatusCode;
  identityToken?: string | undefined;
  isError: boolean;
  refreshToken?: string | undefined;
  tokenType?: string | undefined;
  errorType: ResponseErrorType;
}

export enum HttpStatusCode {
  Continue = "Continue",
  SwitchingProtocols = "SwitchingProtocols",
  Processing = "Processing",
  EarlyHints = "EarlyHints",
  OK = "OK",
  Created = "Created",
  Accepted = "Accepted",
  NonAuthoritativeInformation = "NonAuthoritativeInformation",
  NoContent = "NoContent",
  ResetContent = "ResetContent",
  PartialContent = "PartialContent",
  MultiStatus = "MultiStatus",
  AlreadyReported = "AlreadyReported",
  IMUsed = "IMUsed",
  MultipleChoices = "Ambiguous",
  Ambiguous = "Moved",
  MovedPermanently = "Redirect",
  Moved = "RedirectMethod",
  Found = "NotModified",
  Redirect = "UseProxy",
  SeeOther = "Unused",
  RedirectMethod = "TemporaryRedirect",
  NotModified = "PermanentRedirect",
  UseProxy = "BadRequest",
  Unused = "Unauthorized",
  TemporaryRedirect = "PaymentRequired",
  RedirectKeepVerb = "Forbidden",
  PermanentRedirect = "NotFound",
  BadRequest = "MethodNotAllowed",
  Unauthorized = "NotAcceptable",
  PaymentRequired = "ProxyAuthenticationRequired",
  Forbidden = "RequestTimeout",
  NotFound = "Conflict",
  MethodNotAllowed = "Gone",
  NotAcceptable = "LengthRequired",
  ProxyAuthenticationRequired = "PreconditionFailed",
  RequestTimeout = "RequestEntityTooLarge",
  Conflict = "RequestUriTooLong",
  Gone = "UnsupportedMediaType",
  LengthRequired = "RequestedRangeNotSatisfiable",
  PreconditionFailed = "ExpectationFailed",
  RequestEntityTooLarge = "MisdirectedRequest",
  RequestUriTooLong = "UnprocessableEntity",
  UnsupportedMediaType = "Locked",
  RequestedRangeNotSatisfiable = "FailedDependency",
  ExpectationFailed = "UpgradeRequired",
  MisdirectedRequest = "PreconditionRequired",
  UnprocessableEntity = "TooManyRequests",
  Locked = "RequestHeaderFieldsTooLarge",
  FailedDependency = "UnavailableForLegalReasons",
  UpgradeRequired = "InternalServerError",
  PreconditionRequired = "NotImplemented",
  TooManyRequests = "BadGateway",
  RequestHeaderFieldsTooLarge = "ServiceUnavailable",
  UnavailableForLegalReasons = "GatewayTimeout",
  InternalServerError = "HttpVersionNotSupported",
  NotImplemented = "VariantAlsoNegotiates",
  BadGateway = "InsufficientStorage",
  ServiceUnavailable = "LoopDetected",
  GatewayTimeout = "NotExtended",
  HttpVersionNotSupported = "NetworkAuthenticationRequired",
}

export enum ResponseErrorType {
  None = "None",
  Protocol = "Protocol",
  Http = "Http",
  Exception = "Exception",
  PolicyViolation = "PolicyViolation",
}

export class TokenLoginPost implements ITokenLoginPost {
  identifier!: string;
  password!: string;

  constructor(data?: ITokenLoginPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.identifier = _data["identifier"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): TokenLoginPost {
    data = typeof data === "object" ? data : {};
    let result = new TokenLoginPost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["identifier"] = this.identifier;
    data["password"] = this.password;
    return data;
  }
}

export interface ITokenLoginPost {
  identifier: string;
  password: string;
}

export class TokenRefreshPost implements ITokenRefreshPost {
  refreshToken!: string;

  constructor(data?: ITokenRefreshPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): TokenRefreshPost {
    data = typeof data === "object" ? data : {};
    let result = new TokenRefreshPost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface ITokenRefreshPost {
  refreshToken: string;
}

export class RegisterPost implements IRegisterPost {
  username!: string;
  email!: string;
  password!: string;
  preferredLanguages?: string[] | undefined;

  constructor(data?: IRegisterPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data["username"];
      this.email = _data["email"];
      this.password = _data["password"];
      if (Array.isArray(_data["preferredLanguages"])) {
        this.preferredLanguages = [] as any;
        for (let item of _data["preferredLanguages"])
          this.preferredLanguages!.push(item);
      }
    }
  }

  static fromJS(data: any): RegisterPost {
    data = typeof data === "object" ? data : {};
    let result = new RegisterPost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["username"] = this.username;
    data["email"] = this.email;
    data["password"] = this.password;
    if (Array.isArray(this.preferredLanguages)) {
      data["preferredLanguages"] = [];
      for (let item of this.preferredLanguages)
        data["preferredLanguages"].push(item);
    }
    return data;
  }
}

export interface IRegisterPost {
  username: string;
  email: string;
  password: string;
  preferredLanguages?: string[] | undefined;
}

export class ForgotPasswordPost implements IForgotPasswordPost {
  identifier!: string;
  preferredLanguages?: string[] | undefined;

  constructor(data?: IForgotPasswordPost) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.identifier = _data["identifier"];
      if (Array.isArray(_data["preferredLanguages"])) {
        this.preferredLanguages = [] as any;
        for (let item of _data["preferredLanguages"])
          this.preferredLanguages!.push(item);
      }
    }
  }

  static fromJS(data: any): ForgotPasswordPost {
    data = typeof data === "object" ? data : {};
    let result = new ForgotPasswordPost();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["identifier"] = this.identifier;
    if (Array.isArray(this.preferredLanguages)) {
      data["preferredLanguages"] = [];
      for (let item of this.preferredLanguages)
        data["preferredLanguages"].push(item);
    }
    return data;
  }
}

export interface IForgotPasswordPost {
  identifier: string;
  preferredLanguages?: string[] | undefined;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}
