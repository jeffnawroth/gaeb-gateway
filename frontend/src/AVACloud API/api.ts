/* tslint:disable */
/* eslint-disable */
/**
 * AVACloud API 1.37.2
 * AVACloud API specification
 *
 * The version of the OpenAPI document: 1.37.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * This enumeration represents the status of an addendum, \'Nachtrag\' in German
 * @export
 * @enum {string}
 */

export const AddendumStatusDto = {
    Unknown: 'Unknown',
    Recognized: 'Recognized',
    Filed: 'Filed',
    Offered: 'Offered',
    Withdrawn: 'Withdrawn',
    Rejected: 'Rejected',
    RejectionObjected: 'RejectionObjected',
    FormallyAcknowledged: 'FormallyAcknowledged',
    Approved: 'Approved'
} as const;

export type AddendumStatusDto = typeof AddendumStatusDto[keyof typeof AddendumStatusDto];


/**
 * Indicates the origin of an element.
 * @export
 * @enum {string}
 */

export const AdditionTypeDto = {
    None: 'None',
    ByBuyer: 'ByBuyer',
    ByBidder: 'ByBidder'
} as const;

export type AdditionTypeDto = typeof AdditionTypeDto[keyof typeof AdditionTypeDto];


/**
 * Data transfer class to convey api errors
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * This dictionary contains a set of all errors and their messages
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ApiError
     */
    'errors'?: { [key: string]: Array<string>; };
}
/**
 * This class represents a single article, usually used within ProductData
 * @export
 * @interface ArticleDataDto
 */
export interface ArticleDataDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'id': string;
    /**
     * The name (or brand name) for this article, usually given by the supplier or vendor.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'name'?: string;
    /**
     * An article number that describes it, useful when integrating other systems.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'articleNumber'?: string;
    /**
     * Quantity for this article. If this is used within a Position, the quantity here should be the quantity required for the full quantity of the position, not for a single unit.
     * @type {number}
     * @memberof ArticleDataDto
     */
    'quantity': number;
    /**
     * The unit tag for this single ArticleData.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'unitTag'?: string;
    /**
     * This is an optional text element that can be used to further describe the ArticleData.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'description'?: string;
    /**
     * Short description for this ITextElement element.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'shortText'?: string;
    /**
     * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof ArticleDataDto
     */
    'htmlLongText'?: string;
}
/**
 * This enumeration describes the type of the award / procurement process. If this is used in a GAEB context, more information about award types can be found in the German VOB/A rules and the GAEB standard
 * @export
 * @enum {string}
 */

export const AwardTypeDto = {
    Unspecified: 'Unspecified',
    OpenProcurement: 'OpenProcurement',
    ClosedProducrement: 'ClosedProducrement',
    NegotiationProcurementWithoutPublicAnnouncement: 'NegotiationProcurementWithoutPublicAnnouncement',
    NegotiationProcurement: 'NegotiationProcurement',
    OpenCall: 'OpenCall',
    SelectedCallWithoutPublicCompetition: 'SelectedCallWithoutPublicCompetition',
    SelectedCall: 'SelectedCall',
    DirectAward: 'DirectAward',
    InternationalNatoProcurement: 'InternationalNATOProcurement',
    CompetitiveDialog: 'CompetitiveDialog'
} as const;

export type AwardTypeDto = typeof AwardTypeDto[keyof typeof AwardTypeDto];


/**
 * This is a class that represents the information about a bank connection. It is usually used within a PartyInformation.
 * @export
 * @interface BankingInformationDto
 */
export interface BankingInformationDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'id': string;
    /**
     * The name of the bank.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'name'?: string;
    /**
     * The international identifier for the bank account.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'iban'?: string;
    /**
     * The account number. Typically no longer used since the introduction of IBAN within the SEPA area.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'accountNumber'?: string;
    /**
     * The international bank identifier.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'bic'?: string;
    /**
     * The routing number for the bank. Typically no longer used since the introduction of IBAN within the SEPA area.
     * @type {string}
     * @memberof BankingInformationDto
     */
    'routingNumber'?: string;
}
/**
 * This class holds means to calculate mathematical expressions from given strings.
 * @export
 * @interface CalculationDto
 */
export interface CalculationDto {
    /**
     * Descriptive text for this calculation.
     * @type {string}
     * @memberof CalculationDto
     */
    'description'?: string;
    /**
     * This Calculation\'s mathematical expression. Please note that thousands separators are not supported. Both comma and point will be treated as decimal separators.
     * @type {string}
     * @memberof CalculationDto
     */
    'formula'?: string;
    /**
     * The calculated result from the formula, 0 if invalid.
     * @type {number}
     * @memberof CalculationDto
     */
    'result': number;
    /**
     * Whether the Formula is a valid expression.
     * @type {boolean}
     * @memberof CalculationDto
     */
    'valid': boolean;
    /**
     * Will be -1 if the Formula is correct, else it will show the position in the formula where an error was encountered. This is a zero based index.
     * @type {number}
     * @memberof CalculationDto
     */
    'errorPositionInLine': number;
    /**
     * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
     * @type {Array<CatalogueDto>}
     * @memberof CalculationDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * Referenced catalogues for this Calculation.
     * @type {Array<CatalogueReferenceDto>}
     * @memberof CalculationDto
     */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
}
/**
 * This class describes an external catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
 * @export
 * @interface CatalogueDto
 */
export interface CatalogueDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof CatalogueDto
     */
    'id': string;
    /**
     * This is used to store the GAEB XML Id within this Catalogue. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
     * @type {string}
     * @memberof CatalogueDto
     */
    'gaebXmlId'?: string;
    /**
     * The name that is given for this catalogue.
     * @type {string}
     * @memberof CatalogueDto
     */
    'name'?: string;
    /**
     * Additional information about this catalogue.
     * @type {string}
     * @memberof CatalogueDto
     */
    'description'?: string;
    /**
     * 
     * @type {CatalogueTypeDto}
     * @memberof CatalogueDto
     */
    'catalogueType': CatalogueTypeDto;
}


/**
 * This class is used to link data between catalogues and objects.
 * @export
 * @interface CatalogueReferenceDto
 */
export interface CatalogueReferenceDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof CatalogueReferenceDto
     */
    'id': string;
    /**
     * This points to the item in the catalogue itself. This means that, for example when this quantity assignment references a \"DIN 276\" catalogue, this property indicates the number / identifier / key in DIN 276 that is referenced.
     * @type {string}
     * @memberof CatalogueReferenceDto
     */
    'catalogueReferenceKey'?: string;
    /**
     * The Id of the CatalogueReference that is targeted by this item. Set this property to set the referenced catalogue.
     * @type {string}
     * @memberof CatalogueReferenceDto
     */
    'catalogueReferenceId': string;
    /**
     * These are CatalogueReference that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
     * @type {Array<CatalogueDto>}
     * @memberof CatalogueReferenceDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * 
     * @type {CatalogueDto}
     * @memberof CatalogueReferenceDto
     */
    'catalogue'?: CatalogueDto;
}
/**
 * This enumeration describes the type of a catalogue. Catalogues, or collections, hold information to categorize and describe items. For example, the German DIN 276 cost group standards describe different types of costs for building projects. When referencing the DIN 276 catalogue and providing an item key or identifier, it is possible to reference data in this catalogue.
 * @export
 * @enum {string}
 */

export const CatalogueTypeDto = {
    Unknown: 'Unknown',
    Location: 'Location',
    Din276: 'DIN276',
    CostUnit: 'CostUnit',
    WorkCategory: 'WorkCategory',
    OenormB1801CostGroup: 'OenormB1801CostGroup',
    Bim: 'BIM'
} as const;

export type CatalogueTypeDto = typeof CatalogueTypeDto[keyof typeof CatalogueTypeDto];


/**
 * Indicates if this service specification item is commissioned (and therefore should be executed), postponed for later or undefined.
 * @export
 * @enum {string}
 */

export const ComissionStatusDto = {
    Undefined: 'Undefined',
    Commissioned: 'Commissioned',
    Postponed: 'Postponed',
    Removed: 'Removed'
} as const;

export type ComissionStatusDto = typeof ComissionStatusDto[keyof typeof ComissionStatusDto];


/**
 * This enum represents types of price inquiries
 * @export
 * @enum {string}
 */

export const CommerceInquiryTypeDto = {
    Unknown: 'Unknown',
    Project: 'Project',
    Immediate: 'Immediate',
    Exhibition: 'Exhibition'
} as const;

export type CommerceInquiryTypeDto = typeof CommerceInquiryTypeDto[keyof typeof CommerceInquiryTypeDto];


/**
 * This class holds specialized information that is relevant to trade or commerce based data exchange scenarios, e.g. between customers, vendors, suppliers and distributors. It is used when exporting to GAEB XML 9x exchange phases.
 * @export
 * @interface CommercePropertiesDto
 */
export interface CommercePropertiesDto {
    /**
     * This maps to ArtNo in GAEB XML and represents an article number given by the supplier.
     * @type {string}
     * @memberof CommercePropertiesDto
     */
    'articleNumber'?: string;
    /**
     * This maps to EAN in GAEB XML and represents an GTIN (formerly EAN) article number.
     * @type {string}
     * @memberof CommercePropertiesDto
     */
    'eanGtinArticleNumber'?: string;
    /**
     * This maps to ArtNoID in GAEB XML and represents an ILN article number.
     * @type {string}
     * @memberof CommercePropertiesDto
     */
    'ilnArticleNumber'?: string;
    /**
     * This maps to CatalogNo in GAEB XML and represents an identifier of a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
     * @type {string}
     * @memberof CommercePropertiesDto
     */
    'catalogueNumber'?: string;
    /**
     * This maps to CatalogArtNo in GAEB XML and represents a key that maps to an entry in a specific catalogue. The referenced catalogue is usually a customer specific one, not related to CatalogueReferences.
     * @type {string}
     * @memberof CommercePropertiesDto
     */
    'catalogueArticleNumber'?: string;
    /**
     * This optional property can be used to indicate the basis for prices for a single position. Price basis means that the price is given per unit of the basis, e.g. per a pack of five when this property is set to \'5\'.
     * @type {number}
     * @memberof CommercePropertiesDto
     */
    'priceBasis'?: number;
}
/**
 * This class represents the linking to a complementary position with a specific quantity set. For example, Position \'A\' could be complementing Position \'B\' with a total quantity of 20 units
 * @export
 * @interface ComplementedByQuantityDto
 */
export interface ComplementedByQuantityDto {
    /**
     * The quantity that is complemented. E.g., if the base position has a quantity of 100 m² of a brick wall, a complementing position might be for \'walls that exceed 3 m height\' and for a total quantity of 10 m².
     * @type {number}
     * @memberof ComplementedByQuantityDto
     */
    'quantity': number;
    /**
     * This is the reference to the Id of the Position that is complementing. This means it does NOT reference the base position but the one that contains the actual addition.
     * @type {string}
     * @memberof ComplementedByQuantityDto
     */
    'complementingPositionId'?: string;
}
/**
 * The GAEB exchange phase to transform to
 * @export
 * @enum {string}
 */

export const DestinationGaebExchangePhase = {
    None: 'None',
    Base: 'Base',
    OfferRequest: 'OfferRequest',
    Offer: 'Offer',
    Grant: 'Grant',
    CostEstimate: 'CostEstimate',
    SideOffer: 'SideOffer'
} as const;

export type DestinationGaebExchangePhase = typeof DestinationGaebExchangePhase[keyof typeof DestinationGaebExchangePhase];


/**
 * Represents valid GAEB target types
 * @export
 * @enum {string}
 */

export const DestinationGaebType = {
    Gaeb90: 'Gaeb90',
    Gaeb2000: 'Gaeb2000',
    Gaeb2000Commerce: 'Gaeb2000Commerce',
    GaebXmlV31: 'GaebXml_V3_1',
    GaebXmlV32: 'GaebXml_V3_2',
    GaebXmlV32Commerce: 'GaebXml_V3_2_Commerce',
    GaebXmlV33: 'GaebXml_V3_3',
    GaebXmlV33Commerce: 'GaebXml_V3_3_Commerce',
    GaebXmlV332019: 'GaebXml_V3_3_2019',
    GaebXmlV332019Commerce: 'GaebXml_V3_3_2019_Commerce'
} as const;

export type DestinationGaebType = typeof DestinationGaebType[keyof typeof DestinationGaebType];


/**
 * Represents valid Oenorm target types
 * @export
 * @enum {string}
 */

export const DestinationOenormType = {
    Lv2015: 'Lv2015',
    Lb2015: 'Lb2015',
    B2063: 'B2063',
    Lv2009: 'Lv2009',
    Lb2009: 'Lb2009',
    Lv2021: 'Lv2021',
    Lb2021: 'Lb2021'
} as const;

export type DestinationOenormType = typeof DestinationOenormType[keyof typeof DestinationOenormType];


/**
 * Represents valid REB target types
 * @export
 * @enum {string}
 */

export const DestinationRebType = {
    D11: 'D11',
    X31GaebXmlV32: 'X31GaebXmlV32'
} as const;

export type DestinationRebType = typeof DestinationRebType[keyof typeof DestinationRebType];


/**
 * This enumeration represents the unit of a duration
 * @export
 * @enum {string}
 */

export const DurationUnitDto = {
    Months: 'Months',
    Years: 'Years'
} as const;

export type DurationUnitDto = typeof DurationUnitDto[keyof typeof DurationUnitDto];


/**
 * Indicates a ServiceSpecification\'s exchange phase, based on the GAEB exchange phases.
 * @export
 * @enum {string}
 */

export const ExchangePhaseDto = {
    Undefined: 'Undefined',
    Base: 'Base',
    CostEstimate: 'CostEstimate',
    OfferRequest: 'OfferRequest',
    Offer: 'Offer',
    SideOffer: 'SideOffer',
    Grant: 'Grant'
} as const;

export type ExchangePhaseDto = typeof ExchangePhaseDto[keyof typeof ExchangePhaseDto];


/**
 * 
 * @export
 * @interface ExecutionDescriptionDto
 */
export interface ExecutionDescriptionDto extends IElementDto {
    /**
     * Blocks within an ExecutionDescription contain the actual information.
     * @type {Array<NoteTextDto>}
     * @memberof ExecutionDescriptionDto
     */
    'blocks'?: Array<NoteTextDto>;
    /**
     * Labels this ExecutionDescription.
     * @type {string}
     * @memberof ExecutionDescriptionDto
     */
    'label'?: string;
    /**
     * Uniquely identifies this ExecutionDescription.
     * @type {string}
     * @memberof ExecutionDescriptionDto
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionDescriptionDto
     */
    'elementType'?: string;
}
/**
 * An ExecutionDescription is used to give more details for certain items, especially on how they are meant to be executed.
 * @export
 * @interface ExecutionDescriptionDtoAllOf
 */
export interface ExecutionDescriptionDtoAllOf {
    /**
     * Blocks within an ExecutionDescription contain the actual information.
     * @type {Array<NoteTextDto>}
     * @memberof ExecutionDescriptionDtoAllOf
     */
    'blocks'?: Array<NoteTextDto>;
    /**
     * Labels this ExecutionDescription.
     * @type {string}
     * @memberof ExecutionDescriptionDtoAllOf
     */
    'label'?: string;
    /**
     * Uniquely identifies this ExecutionDescription.
     * @type {string}
     * @memberof ExecutionDescriptionDtoAllOf
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExecutionDescriptionDtoAllOf
     */
    'elementType'?: string;
}
/**
 * This enum represents the source type for a file based validation operation
 * @export
 * @enum {string}
 */

export const FileValidationSourceType = {
    Gaeb: 'Gaeb',
    Oenorm: 'Oenorm'
} as const;

export type FileValidationSourceType = typeof FileValidationSourceType[keyof typeof FileValidationSourceType];


/**
 * 
 * @export
 * @interface ForgotPasswordPost
 */
export interface ForgotPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordPost
     */
    'identifier': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ForgotPasswordPost
     */
    'preferredLanguages'?: Array<string>;
}
/**
 * Indicates the status of the AVACloud service
 * @export
 * @interface GetStatus
 */
export interface GetStatus {
    /**
     * If any problems in the service health are known, this is set to false
     * @type {boolean}
     * @memberof GetStatus
     */
    'isHealthy': boolean;
    /**
     * The current version of the AVACloud service
     * @type {string}
     * @memberof GetStatus
     */
    'version'?: string;
    /**
     * The environment of the current instance
     * @type {string}
     * @memberof GetStatus
     */
    'environment'?: string;
}
/**
 * This is used in an ElementContainerBase to hold the price composition.
 * @export
 * @interface GrossPriceComponentDto
 */
export interface GrossPriceComponentDto {
    /**
     * This components tax rate.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'taxRate': number;
    /**
     * This is the factor of applied deductions for this component
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'deductionFactor': number;
    /**
     * The total net price for all components of a given tax rate.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalNet': number;
    /**
     * The resulting price component after applied deductions
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalDeducted': number;
    /**
     * The total tax amount for all components of a given tax rate.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalTax': number;
    /**
     * The total gross price for all components of a given tax rate.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalGross': number;
    /**
     * The total gross price for all components of a given tax rate, after applied deductions.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalGrossDeducted': number;
    /**
     * The total tax amount for all components of a given tax rate, after applied deductions.
     * @type {number}
     * @memberof GrossPriceComponentDto
     */
    'totalTaxDeducted': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HttpStatusCode = {
    Continue: 'Continue',
    SwitchingProtocols: 'SwitchingProtocols',
    Processing: 'Processing',
    EarlyHints: 'EarlyHints',
    Ok: 'OK',
    Created: 'Created',
    Accepted: 'Accepted',
    NonAuthoritativeInformation: 'NonAuthoritativeInformation',
    NoContent: 'NoContent',
    ResetContent: 'ResetContent',
    PartialContent: 'PartialContent',
    MultiStatus: 'MultiStatus',
    AlreadyReported: 'AlreadyReported',
    ImUsed: 'IMUsed',
    Ambiguous: 'Ambiguous',
    Moved: 'Moved',
    Redirect: 'Redirect',
    RedirectMethod: 'RedirectMethod',
    NotModified: 'NotModified',
    UseProxy: 'UseProxy',
    Unused: 'Unused',
    TemporaryRedirect: 'TemporaryRedirect',
    PermanentRedirect: 'PermanentRedirect',
    BadRequest: 'BadRequest',
    Unauthorized: 'Unauthorized',
    PaymentRequired: 'PaymentRequired',
    Forbidden: 'Forbidden',
    NotFound: 'NotFound',
    MethodNotAllowed: 'MethodNotAllowed',
    NotAcceptable: 'NotAcceptable',
    ProxyAuthenticationRequired: 'ProxyAuthenticationRequired',
    RequestTimeout: 'RequestTimeout',
    Conflict: 'Conflict',
    Gone: 'Gone',
    LengthRequired: 'LengthRequired',
    PreconditionFailed: 'PreconditionFailed',
    RequestEntityTooLarge: 'RequestEntityTooLarge',
    RequestUriTooLong: 'RequestUriTooLong',
    UnsupportedMediaType: 'UnsupportedMediaType',
    RequestedRangeNotSatisfiable: 'RequestedRangeNotSatisfiable',
    ExpectationFailed: 'ExpectationFailed',
    MisdirectedRequest: 'MisdirectedRequest',
    UnprocessableEntity: 'UnprocessableEntity',
    Locked: 'Locked',
    FailedDependency: 'FailedDependency',
    UpgradeRequired: 'UpgradeRequired',
    PreconditionRequired: 'PreconditionRequired',
    TooManyRequests: 'TooManyRequests',
    RequestHeaderFieldsTooLarge: 'RequestHeaderFieldsTooLarge',
    UnavailableForLegalReasons: 'UnavailableForLegalReasons',
    InternalServerError: 'InternalServerError',
    NotImplemented: 'NotImplemented',
    BadGateway: 'BadGateway',
    ServiceUnavailable: 'ServiceUnavailable',
    GatewayTimeout: 'GatewayTimeout',
    HttpVersionNotSupported: 'HttpVersionNotSupported',
    VariantAlsoNegotiates: 'VariantAlsoNegotiates',
    InsufficientStorage: 'InsufficientStorage',
    LoopDetected: 'LoopDetected',
    NotExtended: 'NotExtended',
    NetworkAuthenticationRequired: 'NetworkAuthenticationRequired'
} as const;

export type HttpStatusCode = typeof HttpStatusCode[keyof typeof HttpStatusCode];


/**
 * Base interface definition for elements within an ElementContainerBase.
 * @export
 * @interface IElementDto
 */
export interface IElementDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof IElementDto
     */
    'id': string;
    /**
     * This is used to store the GAEB XML Id within this IElement. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
     * @type {string}
     * @memberof IElementDto
     */
    'gaebXmlId'?: string;
    /**
     * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a \'Nachtrag\' in German.
     * @type {string}
     * @memberof IElementDto
     */
    'addendumNumber'?: string;
    /**
     * 
     * @type {Array<CatalogueDto>}
     * @memberof IElementDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * 
     * @type {Array<CatalogueReferenceDto>}
     * @memberof IElementDto
     */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    /**
     * 
     * @type {string}
     * @memberof IElementDto
     */
    'elementTypeDiscriminator': string;
}
/**
 * This class represents as identifier of a certain service specification\'s element and is uniquely within the service specification.
 * @export
 * @interface ItemNumberDto
 */
export interface ItemNumberDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof ItemNumberDto
     */
    'id': string;
    /**
     * Will return this ItemNumber as point delimited string. Will not distinguish between upper- and lowercase and return an all-lowercase representation. Will consider first numbers, then characters, e.g. 1a is considered preceding aa.
     * @type {string}
     * @memberof ItemNumberDto
     */
    'stringRepresentation'?: string;
    /**
     * Indicates if the characters and the length of the Identifiers match the current ItemNumberSchema.
     * @type {boolean}
     * @memberof ItemNumberDto
     */
    'isSchemaCompliant': boolean;
    /**
     * 
     * @type {ItemNumberSchemaDto}
     * @memberof ItemNumberDto
     */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
     * Collection of the single identifiers in this ItemNumber. P.e., \"02.03.004\" will have three elements \"02\", \"03\", and \"004\". Since ReadOnlyObservableCollection`1 does have the event set to protected, it can be accessed like this: (itemNumber.Identifiers as INotifyCollectionChanged).CollectionChanged
     * @type {Array<string>}
     * @memberof ItemNumberDto
     */
    'identifiers'?: Array<string>;
    /**
     * This indicates if this item number is at the lot level. Find out more about lots in the documentation.
     * @type {boolean}
     * @memberof ItemNumberDto
     */
    'isLot': boolean;
    /**
     * This is a zero based hierarchy level. It\'s set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
     * @type {number}
     * @memberof ItemNumberDto
     */
    'hierarchyLevel': number;
    /**
     * This property indicates if this ItemNumber is attached to an object of the Position type.
     * @type {boolean}
     * @memberof ItemNumberDto
     */
    'isAttachedToPosition': boolean;
}
/**
 * The schema for ItemNumber\'s in a Project.
 * @export
 * @interface ItemNumberSchemaDto
 */
export interface ItemNumberSchemaDto {
    /**
     * The count of tiers in the ItemNumberSchema
     * @type {number}
     * @memberof ItemNumberSchemaDto
     */
    'totalLength': number;
    /**
     * The collection of tiers for this ItemNumberSchema.
     * @type {Array<ItemNumberSchemaTierDto>}
     * @memberof ItemNumberSchemaDto
     */
    'tiers'?: Array<ItemNumberSchemaTierDto>;
    /**
     * The separator to use for separiting the different levels in an ItemNumber. Defaults to DEFAULT_SEPARATOR, which is a point \'.\'. Setting this to a space or other whitespaces is discouraged, as this might not work correct in all situations and item numbers could be displayed not as intended. This can not be set to an empty or null string, trying that will default to the DEFAULT_SEPARATOR. If a value is set that has a different length than one \'1\', the DEFAULT_SEPARATOR will be used instead. You should also not use values for the separator that are also valid for the item numbers themselves, as that might also lead to incorrect results
     * @type {string}
     * @memberof ItemNumberSchemaDto
     */
    'separator'?: string;
    /**
     * This string is used to fill (left-pad) item numbers. For example, if a tier has a length of \'4\' but the given item number is \'12\', with a Filler of \'0\', then the final item number will be represented as \'0\'. This must be a single character string, if a value is given where the Length property does not evaluate to \'1\', the DEFAULT_FILLER \'0\' is used. A space is fine to use. You should ensure that you use a value different than Separator, as that might produce unexpected results. No attempt is done by the code to recover from such ambiguous configurations.
     * @type {string}
     * @memberof ItemNumberSchemaDto
     */
    'filler'?: string;
    /**
     * This is just a string property that can optionally be used to store additional data for this ItemNumberSchema, e.g. an identification or a type. It does not have any influence over how item numbers are generated, and is not supported in most exchange formats. However, it is used to store ÖNorm service specification structure types.
     * @type {string}
     * @memberof ItemNumberSchemaDto
     */
    'identifier'?: string;
    /**
     * This property indicates if ItemNumbers using this ItemNumberSchema should skip empty group levels. This is commonly only used in GAEB files, where there might be gaps in the hierarchy of elements and position identifiers should be placed at the end of the string representation.
     * @type {boolean}
     * @memberof ItemNumberSchemaDto
     */
    'skipNonExistingLevelsInPositionItemNumbers': boolean;
    /**
     * This string is used only when the property SkipNonExistingLevelsInPositionItemNumbers in this ItemNumberSchema is also set to true. It defaults to DEFAULT_SKIPPED_TIERS_FILLER, but can be set to any string with a lenght of one. Null values or values with a longer length will lead to this property reverting back to the default value. This is used to fill skipped tiers in item numbers where a position is placed in a higher hierarchy level than what would be defined in the Tiers. For example, it could produce an item number like \'01.__.02\', which would indicate a skipped second level. This should be using different values than Filler and Separator, since that could cause ambiguities in the code that generates the actual item numbers. No attempt is done by the code to recover from such ambiguous configurations.
     * @type {string}
     * @memberof ItemNumberSchemaDto
     */
    'skippedTiersFiller'?: string;
    /**
     * This is a read-only property that indicates if this schema has a valid structure. It internally just returns the result from IsCorrectlyDefined. This will return if the ItemNumberSchema is correctly defined. For it to be correctly defined, the following conditions must be true: There may only be one lot group, if there is one, it must be at the top. Following lot levels, there may be at least one group level. After the group levels, there must be one position level. After the position level, there may be one index level. If no tiers are defined at all, this will also return false.
     * @type {boolean}
     * @memberof ItemNumberSchemaDto
     */
    'schemaIsCorrectlyDefined': boolean;
}
/**
 * Represents information about a single Tier in an ItemNumber.
 * @export
 * @interface ItemNumberSchemaTierDto
 */
export interface ItemNumberSchemaTierDto {
    /**
     * The (maximum) length for this tier. Will not accept a length less than 1. Defaults to 1 if length less than one is specified.
     * @type {number}
     * @memberof ItemNumberSchemaTierDto
     */
    'length': number;
    /**
     * 
     * @type {ItemNumberTypeDto}
     * @memberof ItemNumberSchemaTierDto
     */
    'type': ItemNumberTypeDto;
    /**
     * 
     * @type {ItemNumberSchemaTierTypeDto}
     * @memberof ItemNumberSchemaTierDto
     */
    'tierType': ItemNumberSchemaTierTypeDto;
    /**
     * Indicates if this tier represents a lot. See the documentation for more information about lots.
     * @type {boolean}
     * @memberof ItemNumberSchemaTierDto
     */
    'isLot': boolean;
    /**
     * This value is the increment, or step size, that should be used for new item numbers. It defaults to DEFAULT_INCREMENT, but can be changed to any other positive number greater than zero. Invalid values make this be set to one \'1\'
     * @type {number}
     * @memberof ItemNumberSchemaTierDto
     */
    'increment': number;
    /**
     * This is an optional name for the given tier
     * @type {string}
     * @memberof ItemNumberSchemaTierDto
     */
    'tierName'?: string;
}


/**
 * Specifies the type an ItemNumberSchemaTier represents. For example, a tier may indicate to be used for positions or for groups.
 * @export
 * @enum {string}
 */

export const ItemNumberSchemaTierTypeDto = {
    Undefined: 'Undefined',
    Index: 'Index',
    Position: 'Position',
    Group: 'Group',
    Lot: 'Lot'
} as const;

export type ItemNumberSchemaTierTypeDto = typeof ItemNumberSchemaTierTypeDto[keyof typeof ItemNumberSchemaTierTypeDto];


/**
 * Determines the type of an ItemNumberSchema
 * @export
 * @enum {string}
 */

export const ItemNumberTypeDto = {
    Numeric: 'Numeric',
    Alphanumeric: 'Alphanumeric'
} as const;

export type ItemNumberTypeDto = typeof ItemNumberTypeDto[keyof typeof ItemNumberTypeDto];


/**
 * Based on the PriceComponent, this class is responsible for labour time components.
 * @export
 * @interface LabourPriceComponentDto
 */
export interface LabourPriceComponentDto {
    /**
     * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
     * @type {string}
     * @memberof LabourPriceComponentDto
     */
    'label'?: string;
    /**
     * The total, calculated price of this component. Will multiply the calculated amount of hours with the ServiceSpecifications hourly wage rate.
     * @type {number}
     * @memberof LabourPriceComponentDto
     */
    'price': number;
    /**
     * The cost per hour of manual labor.
     * @type {number}
     * @memberof LabourPriceComponentDto
     */
    'hourlyWage': number;
    /**
     * The single Calculation elements this price component is composed of.
     * @type {Array<CalculationDto>}
     * @memberof LabourPriceComponentDto
     */
    'values'?: Array<CalculationDto>;
    /**
     * Indicates if the ServiceSpecification\'s standard HourlyWage is to be used or a custom value.
     * @type {boolean}
     * @memberof LabourPriceComponentDto
     */
    'useOwnHourlyWage': boolean;
    /**
     * The total, calculated time of this component. Will return the result rounded to three decimal places.
     * @type {number}
     * @memberof LabourPriceComponentDto
     */
    'totalTime': number;
    /**
     * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
     * @type {Array<CatalogueDto>}
     * @memberof LabourPriceComponentDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
}
/**
 * 
 * @export
 * @interface LoginPost
 */
export interface LoginPost {
    /**
     * 
     * @type {string}
     * @memberof LoginPost
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPost
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginPost
     */
    'staySignedIn': boolean;
}
/**
 * 
 * @export
 * @interface NoteTextDto
 */
export interface NoteTextDto extends IElementDto {
    /**
     * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
     * @type {boolean}
     * @memberof NoteTextDto
     */
    'isOpeningText': boolean;
    /**
     * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
     * @type {boolean}
     * @memberof NoteTextDto
     */
    'isClosingText': boolean;
    /**
     * Short description for this DescriptionBase element.
     * @type {string}
     * @memberof NoteTextDto
     */
    'shortText'?: string;
    /**
     * 
     * @type {AdditionTypeDto}
     * @memberof NoteTextDto
     */
    'additionType': AdditionTypeDto;
    /**
     * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof NoteTextDto
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof NoteTextDto
     */
    'htmlLongText'?: string;
    /**
     * This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export.
     * @type {string}
     * @memberof NoteTextDto
     */
    'identifier'?: string;
    /**
     * 
     * @type {StandardizedDescriptionDto}
     * @memberof NoteTextDto
     */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
     * 
     * @type {string}
     * @memberof NoteTextDto
     */
    'elementType'?: string;
    /**
     * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It\'s different to an elements identifier in that it should only apply to the description component, meaning the text itself.
     * @type {string}
     * @memberof NoteTextDto
     */
    'descriptionId'?: string;
    /**
     * 
     * @type {OenormNoteTextPropertiesDto}
     * @memberof NoteTextDto
     */
    'oenormNoteTextProperties'?: OenormNoteTextPropertiesDto;
    /**
     * 
     * @type {boolean}
     * @memberof NoteTextDto
     */
    'hasBidderCommentInHtmlLongText': boolean;
}


/**
 * Represents an element that holds text information.
 * @export
 * @interface NoteTextDtoAllOf
 */
export interface NoteTextDtoAllOf {
    /**
     * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special opening text at the beginning of the project. For example, in GAEB XML, this would map to the GAEB.Award.AddText. Typically, such texts describe project-wide contractual definitions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
     * @type {boolean}
     * @memberof NoteTextDtoAllOf
     */
    'isOpeningText': boolean;
    /**
     * If this is set to true, this text is meant to not be seen as part of the regular elements hierarchy but as a special closing text at the end of the project. For Example, in GAEB XML, this would map to the GAEB.AddText. Typically, such texts are used to describe project wide finishing descriptions. If this is set to true, this NoteText should be placed at the top of the elements hierarchy directly in the ServiceSpecification.Elements group, otherwise it will likely not be treated correctly when exporting to GAEB. You can only set IsOpeningText or IsClosingText to true.
     * @type {boolean}
     * @memberof NoteTextDtoAllOf
     */
    'isClosingText': boolean;
    /**
     * Short description for this DescriptionBase element.
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'shortText'?: string;
    /**
     * 
     * @type {AdditionTypeDto}
     * @memberof NoteTextDtoAllOf
     */
    'additionType': AdditionTypeDto;
    /**
     * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'htmlLongText'?: string;
    /**
     * This is an optional internal identifier that may be used to add additional information to this NoteText. It is not supported in GAEB import or export.
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'identifier'?: string;
    /**
     * 
     * @type {StandardizedDescriptionDto}
     * @memberof NoteTextDtoAllOf
     */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
     * 
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'elementType'?: string;
    /**
     * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It\'s different to an elements identifier in that it should only apply to the description component, meaning the text itself.
     * @type {string}
     * @memberof NoteTextDtoAllOf
     */
    'descriptionId'?: string;
    /**
     * 
     * @type {OenormNoteTextPropertiesDto}
     * @memberof NoteTextDtoAllOf
     */
    'oenormNoteTextProperties'?: OenormNoteTextPropertiesDto;
    /**
     * 
     * @type {boolean}
     * @memberof NoteTextDtoAllOf
     */
    'hasBidderCommentInHtmlLongText': boolean;
}


/**
 * Basic information about Object check validation details, commonly used when checking GAEB 2000 files
 * @export
 * @interface ObjectValidationCheckDetails
 */
export interface ObjectValidationCheckDetails {
    /**
     * The path under which the element with error was found.
     * @type {string}
     * @memberof ObjectValidationCheckDetails
     */
    'elementPath'?: string;
}
/**
 * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for NoteTexts.
 * @export
 * @interface OenormNoteTextPropertiesDto
 */
export interface OenormNoteTextPropertiesDto {
    /**
     * 
     * @type {OenormOriginCodeDto}
     * @memberof OenormNoteTextPropertiesDto
     */
    'originCode': OenormOriginCodeDto;
}


/**
 * This indicates where the content of this element originates, if set. It corresponds to \'herkunftskennzeichen\' in ÖNorm
 * @export
 * @enum {string}
 */

export const OenormOriginCodeDto = {
    Unknown: 'Unknown',
    FreeText: 'FreeText',
    AdditionDescription: 'AdditionDescription'
} as const;

export type OenormOriginCodeDto = typeof OenormOriginCodeDto[keyof typeof OenormOriginCodeDto];


/**
 * This class models special properties that only apply to some exchange scenarios where ÖNorm is used. It is special for Positions and extends the OenormProperties base class.
 * @export
 * @interface OenormPositionPropertiesDto
 */
export interface OenormPositionPropertiesDto {
    /**
     * 
     * @type {OenormOriginCodeDto}
     * @memberof OenormPositionPropertiesDto
     */
    'originCode': OenormOriginCodeDto;
    /**
     * This marks if the opening texts within this element are considered free text. It corresponds to \'vorbemerkungskennzeichen\' in ÖNorm.
     * @type {boolean}
     * @memberof OenormPositionPropertiesDto
     */
    'openingTextIsFreeText': boolean;
    /**
     * This indicates if the ÖNorm \'wesentliche position\' mark is set
     * @type {boolean}
     * @memberof OenormPositionPropertiesDto
     */
    'isMainPosition': boolean;
    /**
     * This indicates if the ÖNorm position was a \'ungeteilteposition\' (undivided position). This will only be taken into account when the position is also the sole element inside it\'s parent group
     * @type {boolean}
     * @memberof OenormPositionPropertiesDto
     */
    'isUndividedPosition': boolean;
    /**
     * In some ÖNorm formats, the short text can have it\'s own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText \' \' OenormShortTextAddition needs to match the ShortText.
     * @type {string}
     * @memberof OenormPositionPropertiesDto
     */
    'oenormShortText'?: string;
    /**
     * In some ÖNorm formats, the short text can have it\'s own addition, so the text is split up in OenormShortText and OenormShortTextAddition To serialize this, either the ShortText property of the parent position needs to be null, or OenormShortText \' \' OenormShortTextAddition needs to match the ShortText.
     * @type {string}
     * @memberof OenormPositionPropertiesDto
     */
    'oenormShortTextAddition'?: string;
}


/**
 * This class models special properties that only apply to some exchange scenarios where ÖNorm is used.
 * @export
 * @interface OenormPropertiesDto
 */
export interface OenormPropertiesDto {
    /**
     * 
     * @type {OenormOriginCodeDto}
     * @memberof OenormPropertiesDto
     */
    'originCode': OenormOriginCodeDto;
    /**
     * This marks if the opening texts within this element are considered free text. It corresponds to \'vorbemerkungskennzeichen\' in ÖNorm.
     * @type {boolean}
     * @memberof OenormPropertiesDto
     */
    'openingTextIsFreeText': boolean;
}


/**
 * Indicates where a service specification was originally created.
 * @export
 * @enum {string}
 */

export const OriginDto = {
    Self: 'Self',
    Gaeb90: 'Gaeb90',
    Gaeb2000: 'Gaeb2000',
    GaebXml: 'GaebXml',
    Oenorm: 'Oenorm',
    Reb: 'Reb',
    Sia: 'Sia'
} as const;

export type OriginDto = typeof OriginDto[keyof typeof OriginDto];


/**
 * Represents information about a party (a site or an organization).
 * @export
 * @interface PartyInformationDto
 */
export interface PartyInformationDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'id': string;
    /**
     * This party\'s name.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'name'?: string;
    /**
     * This party\'s street.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'street'?: string;
    /**
     * This party\'s ZipCode.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'zipCode'?: string;
    /**
     * This party\'s City.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'city'?: string;
    /**
     * This party\'s Country.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'country'?: string;
    /**
     * This party\'s Identifier.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'identifier'?: string;
    /**
     * Remarks for this party.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'remarks'?: string;
    /**
     * An email address for this party.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'email'?: string;
    /**
     * A phone number for this party.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'phone'?: string;
    /**
     * The name of a contact person.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'contactPersonName'?: string;
    /**
     * This is an identifier related to this PartyInformation and their internal reference of the tender (or award). This might be used to assign an identifier (German \"Vergabenummer\") for the current project. This is typically only used in Buyer and Bidder representations and should map to the concept of \"Vergabenummer\" or \"AwardNo\" in GAEB.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'awardIdentifier'?: string;
    /**
     * This property indicates if the party is registered within the European Economic Area.
     * @type {boolean}
     * @memberof PartyInformationDto
     */
    'isInEuropeanEconomicArea': boolean;
    /**
     * If this is within the European Economic Area (see IsInEuropeanEconomicArea, then as a business entity it likely has an EU VAT Id.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'vatId'?: string;
    /**
     * The fax number for this party.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'fax'?: string;
    /**
     * The two letter ISO country code, e.g. DE for Germany.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'countryCode'?: string;
    /**
     * Depending on which party this class represents, it might have either a \'creditor\' or \'debtor\' number. This is often used in internal accounting systems.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'creditorOrDebtorIdentifier'?: string;
    /**
     * The Global Location Number (GLN) is issued by GS1 and is intended to be a unique identifier for the physical address of a party, e.g. a business office.
     * @type {string}
     * @memberof PartyInformationDto
     */
    'globalLocationNumber'?: string;
    /**
     * This list contains information about bank accounts associated with this PartyInformation. It\'s typically used for buyers and bidders.
     * @type {Array<BankingInformationDto>}
     * @memberof PartyInformationDto
     */
    'bankingInformation'?: Array<BankingInformationDto>;
}
/**
 * This enum represents the different ways in which a complementing position type can be specified. It is typically only used in GAEB exports, since in Dangl.AVA, complementing positions are always explicitly referenced.
 * @export
 * @enum {string}
 */

export const PositionComplementingTypeDto = {
    Undefined: 'Undefined',
    AllPreviousMarkedPositions: 'AllPreviousMarkedPositions',
    AllPreviousPositions: 'AllPreviousPositions',
    ReferencedPositions: 'ReferencedPositions'
} as const;

export type PositionComplementingTypeDto = typeof PositionComplementingTypeDto[keyof typeof PositionComplementingTypeDto];


/**
 * 
 * @export
 * @interface PositionDto
 */
export interface PositionDto extends IElementDto {
    /**
     * Will return the price per unit, rounded according to the project settings or the default value of three decimal places
     * @type {number}
     * @memberof PositionDto
     */
    'unitPrice': number;
    /**
     * You can use this property to directly set the unit price for this position. This will override any given PriceComponents
     * @type {number}
     * @memberof PositionDto
     */
    'unitPriceOverride'?: number;
    /**
     * Will return this Position\'s total quantity, rounded to three decimal places.
     * @type {number}
     * @memberof PositionDto
     */
    'quantity': number;
    /**
     * You can use this property to directly set the quantity for this position. This will override any given QuantityComponents
     * @type {number}
     * @memberof PositionDto
     */
    'quantityOverride'?: number;
    /**
     * This indicates true if this specific position is specified as a complementing position for any base position.
     * @type {boolean}
     * @memberof PositionDto
     */
    'isComplementingPosition': boolean;
    /**
     * If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position.
     * @type {Array<string>}
     * @memberof PositionDto
     */
    'complementsPositions'?: Array<string>;
    /**
     * You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride.
     * @type {number}
     * @memberof PositionDto
     */
    'complementingPricePercentageOverride'?: number;
    /**
     * This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null.
     * @type {number}
     * @memberof PositionDto
     */
    'complementingPricePercentage'?: number;
    /**
     * The tag of the unit used for this positions quantity.
     * @type {string}
     * @memberof PositionDto
     */
    'unitTag'?: string;
    /**
     * 
     * @type {LabourPriceComponentDto}
     * @memberof PositionDto
     */
    'labourComponents'?: LabourPriceComponentDto;
    /**
     * The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.
     * @type {Array<PriceComponentDto>}
     * @memberof PositionDto
     */
    'priceComponents'?: Array<PriceComponentDto>;
    /**
     * The quantity components of this Position.
     * @type {Array<CalculationDto>}
     * @memberof PositionDto
     */
    'quantityComponents'?: Array<CalculationDto>;
    /**
     * Further structuring of this Position.
     * @type {Array<SubDescriptionDto>}
     * @memberof PositionDto
     */
    'subDescriptions'?: Array<SubDescriptionDto>;
    /**
     * 
     * @type {ComissionStatusDto}
     * @memberof PositionDto
     */
    'comissionStatus': ComissionStatusDto;
    /**
     * A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.
     * @type {Array<string>}
     * @memberof PositionDto
     */
    'complementedBy'?: Array<string>;
    /**
     * Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.
     * @type {boolean}
     * @memberof PositionDto
     */
    'complemented': boolean;
    /**
     * Indicates that the amount for this Position is to be set by the bidder.
     * @type {boolean}
     * @memberof PositionDto
     */
    'amountToBeEnteredByBidder': boolean;
    /**
     * Indicates if the bidder demands for prices to be broken up into their price components.
     * @type {boolean}
     * @memberof PositionDto
     */
    'priceCompositionRequired': boolean;
    /**
     * Indicates if this Position should use a different TaxRate than what is the default for the Project.
     * @type {boolean}
     * @memberof PositionDto
     */
    'useDifferentTaxRate': boolean;
    /**
     * Will return either the parent ServiceSpecification\'s TaxRate or it\'s own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)
     * @type {number}
     * @memberof PositionDto
     */
    'taxRate': number;
    /**
     * 
     * @type {ItemNumberDto}
     * @memberof PositionDto
     */
    'itemNumber'?: ItemNumberDto;
    /**
     * The rate of deductions, i.e. 0.12m means 12% price deduction.
     * @type {number}
     * @memberof PositionDto
     */
    'deductionFactor': number;
    /**
     * Returns the product of UnitPrice times Quantity.
     * @type {number}
     * @memberof PositionDto
     */
    'totalPrice': number;
    /**
     * The total gross price for this Position.
     * @type {number}
     * @memberof PositionDto
     */
    'totalPriceGross': number;
    /**
     * Total gross price after applied deductions.
     * @type {number}
     * @memberof PositionDto
     */
    'totalPriceGrossDeducted': number;
    /**
     * Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.
     * @type {number}
     * @memberof PositionDto
     */
    'deductedPrice': number;
    /**
     * 
     * @type {PositionTypeDto}
     * @memberof PositionDto
     */
    'positionType': PositionTypeDto;
    /**
     * 
     * @type {PriceTypeDto}
     * @memberof PositionDto
     */
    'priceType': PriceTypeDto;
    /**
     * 
     * @type {ServiceTypeDto}
     * @memberof PositionDto
     */
    'serviceType': ServiceTypeDto;
    /**
     * 
     * @type {ProductDataDto}
     * @memberof PositionDto
     */
    'productData'?: ProductDataDto;
    /**
     * Short description for this DescriptionBase element.
     * @type {string}
     * @memberof PositionDto
     */
    'shortText'?: string;
    /**
     * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof PositionDto
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof PositionDto
     */
    'htmlLongText'?: string;
    /**
     * 
     * @type {AdditionTypeDto}
     * @memberof PositionDto
     */
    'additionType': AdditionTypeDto;
    /**
     * 
     * @type {string}
     * @memberof PositionDto
     */
    'elementType'?: string;
    /**
     * Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
     * @type {Array<QuantityAssignmentDto>}
     * @memberof PositionDto
     */
    'quantityAssignments'?: Array<QuantityAssignmentDto>;
    /**
     * 
     * @type {CommercePropertiesDto}
     * @memberof PositionDto
     */
    'commerceProperties'?: CommercePropertiesDto;
    /**
     * If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.
     * @type {string}
     * @memberof PositionDto
     */
    'alternativeTo'?: string;
    /**
     * This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
     * @type {number}
     * @memberof PositionDto
     */
    'alternativeIdentifier'?: number;
    /**
     * This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It\'s different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
     * @type {number}
     * @memberof PositionDto
     */
    'alternativeGroupIdentifier'?: number;
    /**
     * If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.
     * @type {boolean}
     * @memberof PositionDto
     */
    'isLumpSum': boolean;
    /**
     * This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together
     * @type {string}
     * @memberof PositionDto
     */
    'repetitionTo'?: string;
    /**
     * 
     * @type {StandardizedDescriptionDto}
     * @memberof PositionDto
     */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
     * This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it\'s up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.
     * @type {Array<ComplementedByQuantityDto>}
     * @memberof PositionDto
     */
    'complementedByQuantities'?: Array<ComplementedByQuantityDto>;
    /**
     * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.
     * @type {string}
     * @memberof PositionDto
     */
    'executionDescriptionReference'?: string;
    /**
     * This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.
     * @type {boolean}
     * @memberof PositionDto
     */
    'notOffered': boolean;
    /**
     * 
     * @type {OenormPositionPropertiesDto}
     * @memberof PositionDto
     */
    'oenormPositionProperties'?: OenormPositionPropertiesDto;
    /**
     * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It\'s different to an elements identifier in that it should only apply to the description component, meaning the text itself.
     * @type {string}
     * @memberof PositionDto
     */
    'descriptionId'?: string;
    /**
     * This is a zero based hierarchy level. It\'s set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
     * @type {number}
     * @memberof PositionDto
     */
    'hierarchyLevel': number;
    /**
     * 
     * @type {AddendumStatusDto}
     * @memberof PositionDto
     */
    'addendumStatus'?: AddendumStatusDto;
    /**
     * 
     * @type {boolean}
     * @memberof PositionDto
     */
    'hasBidderCommentInHtmlLongText': boolean;
    /**
     * 
     * @type {PositionComplementingTypeDto}
     * @memberof PositionDto
     */
    'gaebComplementingType': PositionComplementingTypeDto;
}


/**
 * A Position is the main item type in a ServiceSpecification, holding information about tasks to be done, their prices, description, amounts etc.
 * @export
 * @interface PositionDtoAllOf
 */
export interface PositionDtoAllOf {
    /**
     * Will return the price per unit, rounded according to the project settings or the default value of three decimal places
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'unitPrice': number;
    /**
     * You can use this property to directly set the unit price for this position. This will override any given PriceComponents
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'unitPriceOverride'?: number;
    /**
     * Will return this Position\'s total quantity, rounded to three decimal places.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'quantity': number;
    /**
     * You can use this property to directly set the quantity for this position. This will override any given QuantityComponents
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'quantityOverride'?: number;
    /**
     * This indicates true if this specific position is specified as a complementing position for any base position.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'isComplementingPosition': boolean;
    /**
     * If IsComplementingPosition is set to true, this will indicate which base positions are targeted by this complementing position.
     * @type {Array<string>}
     * @memberof PositionDtoAllOf
     */
    'complementsPositions'?: Array<string>;
    /**
     * You can use this property to directly specify the total price of this position as a percentage of the sum of the total prices of base positions that this position complements. It will essentially set the total price for this position to the sum of all total prices of the positions specified in ComplementsPositions multiplied by the percentage here. If present, this has precedence over UnitPriceOverride as well as QuantityOverride.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'complementingPricePercentageOverride'?: number;
    /**
     * This is a read only property showing the total price of this positions as a percentage of the sum of the total prices of all base positions, in case this position is a complementing positions. If this position is not a complementing position, this will be null. Also, if no prices are present, this will also be null.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'complementingPricePercentage'?: number;
    /**
     * The tag of the unit used for this positions quantity.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'unitTag'?: string;
    /**
     * 
     * @type {LabourPriceComponentDto}
     * @memberof PositionDtoAllOf
     */
    'labourComponents'?: LabourPriceComponentDto;
    /**
     * The single price components in this Position. Price components should not be handled directly on a per-position basis but set globally in the parent Projects ProjectInformation.
     * @type {Array<PriceComponentDto>}
     * @memberof PositionDtoAllOf
     */
    'priceComponents'?: Array<PriceComponentDto>;
    /**
     * The quantity components of this Position.
     * @type {Array<CalculationDto>}
     * @memberof PositionDtoAllOf
     */
    'quantityComponents'?: Array<CalculationDto>;
    /**
     * Further structuring of this Position.
     * @type {Array<SubDescriptionDto>}
     * @memberof PositionDtoAllOf
     */
    'subDescriptions'?: Array<SubDescriptionDto>;
    /**
     * 
     * @type {ComissionStatusDto}
     * @memberof PositionDtoAllOf
     */
    'comissionStatus': ComissionStatusDto;
    /**
     * A list of positions that complement this Position. The positions are referenced by their GUIDs. It might be used together with ComplementedByQuantities in case that only a given quantity is complemented by positions.
     * @type {Array<string>}
     * @memberof PositionDtoAllOf
     */
    'complementedBy'?: Array<string>;
    /**
     * Will indicate if this Position is complemented in this ServiceSpecification by other Positions. It can not be set to false when there are entries in the ComplementedBy property.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'complemented': boolean;
    /**
     * Indicates that the amount for this Position is to be set by the bidder.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'amountToBeEnteredByBidder': boolean;
    /**
     * Indicates if the bidder demands for prices to be broken up into their price components.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'priceCompositionRequired': boolean;
    /**
     * Indicates if this Position should use a different TaxRate than what is the default for the Project.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'useDifferentTaxRate': boolean;
    /**
     * Will return either the parent ServiceSpecification\'s TaxRate or it\'s own if it has a different value. (For example, in Germany Water has a different TaxRate than regular Positions)
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'taxRate': number;
    /**
     * 
     * @type {ItemNumberDto}
     * @memberof PositionDtoAllOf
     */
    'itemNumber'?: ItemNumberDto;
    /**
     * The rate of deductions, i.e. 0.12m means 12% price deduction.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'deductionFactor': number;
    /**
     * Returns the product of UnitPrice times Quantity.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'totalPrice': number;
    /**
     * The total gross price for this Position.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'totalPriceGross': number;
    /**
     * Total gross price after applied deductions.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'totalPriceGrossDeducted': number;
    /**
     * Net price after applied deductions. Please be aware that this is the total price, from TotalPrice, not the unit price of the position.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'deductedPrice': number;
    /**
     * 
     * @type {PositionTypeDto}
     * @memberof PositionDtoAllOf
     */
    'positionType': PositionTypeDto;
    /**
     * 
     * @type {PriceTypeDto}
     * @memberof PositionDtoAllOf
     */
    'priceType': PriceTypeDto;
    /**
     * 
     * @type {ServiceTypeDto}
     * @memberof PositionDtoAllOf
     */
    'serviceType': ServiceTypeDto;
    /**
     * 
     * @type {ProductDataDto}
     * @memberof PositionDtoAllOf
     */
    'productData'?: ProductDataDto;
    /**
     * Short description for this DescriptionBase element.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'shortText'?: string;
    /**
     * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'htmlLongText'?: string;
    /**
     * 
     * @type {AdditionTypeDto}
     * @memberof PositionDtoAllOf
     */
    'additionType': AdditionTypeDto;
    /**
     * 
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'elementType'?: string;
    /**
     * Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of this Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
     * @type {Array<QuantityAssignmentDto>}
     * @memberof PositionDtoAllOf
     */
    'quantityAssignments'?: Array<QuantityAssignmentDto>;
    /**
     * 
     * @type {CommercePropertiesDto}
     * @memberof PositionDtoAllOf
     */
    'commerceProperties'?: CommercePropertiesDto;
    /**
     * If this position is an Alternative, then this property should point to the id of the position in this service specification that it can replace. If this is set to a value, you can optionally also specify an identifier via AlternativeIdentifier to specifiy multiple positions that must be used together to be an alternative to a single base position.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'alternativeTo'?: string;
    /**
     * This is an optional property that can be used together with AlternativeTo. If this is set, you can indicate which alternative group a specific position is assigned to. That way, if you specifiy multiple alternative Positions with the same AlternativeIdentifier, you can indicate that to replace a single base Position, multiple alternative Positions should be used. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'alternativeIdentifier'?: number;
    /**
     * This is an optional property that can be used together with AlternativeTo and AlternativeGroupIdentifier. If this is set, you can indicate which alternative group a specific position is assigned to. That way, you can specify the id (in integer format) for the alternative group this position belongs to. It\'s different to AlternativeIdentifier in that the other property describes the id of the group, while this property here describes the group itself. If a position only has set AlternativeGroupIdentifier but not AlternativeIdentifier, then it likely is a base position for a specific group. This was introduced in version v2.9.0 to be able to model both position and group ids for alternative group combinations. This property is not checked or managed automatically, so it is possible for this property to become invalid, by for example setting this property but not setting a base position via AlternativeTo.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'alternativeGroupIdentifier'?: number;
    /**
     * If this is true, it indicates that the position is intended to be a lump sum, \"Pauschal\" in German. This means the position total price that is being invoiced should not depend on the actual quantity. In practice, partial invoices are still often used for partial services rendered. This property does not affect the price calculation for this position. Typically, the Quantity should be set to 1.0 when this flag is used.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'isLumpSum': boolean;
    /**
     * This identifier can be used to point to the Id of a position in the same ServiceSpecification that acts as a base position. It matches \"Bezugsposition\" in GAEB. This can be used for positions that repeat partially or are linked together
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'repetitionTo'?: string;
    /**
     * 
     * @type {StandardizedDescriptionDto}
     * @memberof PositionDtoAllOf
     */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
     * This list contains references to positions that complement this one, additionally also specifying a quantity for which the addition is intended. This does not replace the ComplementedBy property and there are no automatic checks being done between these two properties, so it\'s up to the user code to ensure deletions (and additions, if desired) are performed for both properties. When copying withing keeping Ids, this list will not be part of the copy process, since it would only contain quantities without actual position references. Containers, however, will rebuild the list with updated position references when copying positions that contain entries here.
     * @type {Array<ComplementedByQuantityDto>}
     * @memberof PositionDtoAllOf
     */
    'complementedByQuantities'?: Array<ComplementedByQuantityDto>;
    /**
     * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions should be executed in practice. Often, the position itself still has text of its own to highlight deviations from that or add more details.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'executionDescriptionReference'?: string;
    /**
     * This indicates if a position has not been offered. This is typically only expected to be true when the exchange phase of the parent ServiceSpecification is Offer, and it means that the position has not been offered at all.
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'notOffered': boolean;
    /**
     * 
     * @type {OenormPositionPropertiesDto}
     * @memberof PositionDtoAllOf
     */
    'oenormPositionProperties'?: OenormPositionPropertiesDto;
    /**
     * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It\'s different to an elements identifier in that it should only apply to the description component, meaning the text itself.
     * @type {string}
     * @memberof PositionDtoAllOf
     */
    'descriptionId'?: string;
    /**
     * This is a zero based hierarchy level. It\'s set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
     * @type {number}
     * @memberof PositionDtoAllOf
     */
    'hierarchyLevel': number;
    /**
     * 
     * @type {AddendumStatusDto}
     * @memberof PositionDtoAllOf
     */
    'addendumStatus'?: AddendumStatusDto;
    /**
     * 
     * @type {boolean}
     * @memberof PositionDtoAllOf
     */
    'hasBidderCommentInHtmlLongText': boolean;
    /**
     * 
     * @type {PositionComplementingTypeDto}
     * @memberof PositionDtoAllOf
     */
    'gaebComplementingType': PositionComplementingTypeDto;
}


/**
 * This is a classification for Position elements.
 * @export
 * @enum {string}
 */

export const PositionTypeDto = {
    Regular: 'Regular',
    Optional: 'Optional',
    Alternative: 'Alternative'
} as const;

export type PositionTypeDto = typeof PositionTypeDto[keyof typeof PositionTypeDto];


/**
 * Options for validating an AVA project
 * @export
 * @interface PostAvaProjectValidationSourceOptions
 */
export interface PostAvaProjectValidationSourceOptions {
    /**
     * 
     * @type {ProjectDto}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'avaProject': ProjectDto;
    /**
     * The index of the ServiceSpecification that should be validated. If not given, will default to the first one in the project.
     * @type {number}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'serviceSpecificationIndex'?: number;
    /**
     * 
     * @type {ValidationType}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'validationType': ValidationType;
    /**
     * 
     * @type {ExchangePhaseDto}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'exchangePhase'?: ExchangePhaseDto;
    /**
     * 
     * @type {PostAvaSourceOptions}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'avaSourceOptions'?: PostAvaSourceOptions;
    /**
     * 
     * @type {PostOenormDestinationOptions}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'oenormDestinationOptions'?: PostOenormDestinationOptions;
    /**
     * 
     * @type {PostGaebDestinationOptions}
     * @memberof PostAvaProjectValidationSourceOptions
     */
    'gaebDestinationOptions'?: PostGaebDestinationOptions;
}


/**
 * Options for conversions from AVA
 * @export
 * @interface PostAvaSourceOptions
 */
export interface PostAvaSourceOptions {
    /**
     * If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @type {boolean}
     * @memberof PostAvaSourceOptions
     */
    'tryAutoGenerateItemNumbersAndSchema': boolean;
}
/**
 * Options for conversions to GAEB
 * @export
 * @interface PostGaebDestinationOptions
 */
export interface PostGaebDestinationOptions {
    /**
     * 
     * @type {DestinationGaebType}
     * @memberof PostGaebDestinationOptions
     */
    'destinationGaebType': DestinationGaebType;
    /**
     * 
     * @type {DestinationGaebExchangePhase}
     * @memberof PostGaebDestinationOptions
     */
    'targetExchangePhaseTransform': DestinationGaebExchangePhase;
    /**
     * Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @type {boolean}
     * @memberof PostGaebDestinationOptions
     */
    'enforceStrictOfferPhaseLongTextOutput': boolean;
    /**
     * Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \'QtyDeterm\' (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \'QuantityComponents\' property of positions. Please see the entry for \'Quantity Determination\' in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \'QuantityComponents\' property.
     * @type {boolean}
     * @memberof PostGaebDestinationOptions
     */
    'exportQuantityDetermination': boolean;
    /**
     * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @type {boolean}
     * @memberof PostGaebDestinationOptions
     */
    'removeUnprintableCharactersFromTexts': boolean;
    /**
     * If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @type {boolean}
     * @memberof PostGaebDestinationOptions
     */
    'forceIncludeDescriptions': boolean;
    /**
     * When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @type {boolean}
     * @memberof PostGaebDestinationOptions
     */
    'treatNullItemNumberSchemaAsInvalid': boolean;
}


/**
 * Options for conversions to Oenorm
 * @export
 * @interface PostOenormDestinationOptions
 */
export interface PostOenormDestinationOptions {
    /**
     * 
     * @type {DestinationOenormType}
     * @memberof PostOenormDestinationOptions
     */
    'destinationOenormType': DestinationOenormType;
    /**
     * Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @type {boolean}
     * @memberof PostOenormDestinationOptions
     */
    'tryRepairProjectStructure': boolean;
    /**
     * If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @type {boolean}
     * @memberof PostOenormDestinationOptions
     */
    'skipTryEnforceSchemaCompliantXmlOutput': boolean;
    /**
     * If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @type {boolean}
     * @memberof PostOenormDestinationOptions
     */
    'removeUnprintableCharactersFromTexts': boolean;
}


/**
 * This class provides means to store information about a price and it\'s composition. Note that this is referencing to a single price component, so for example a Position would have a list of PriceComponents, one for Material, one for Labour etc.
 * @export
 * @interface PriceComponentDto
 */
export interface PriceComponentDto {
    /**
     * The total, calculated price of this component.
     * @type {number}
     * @memberof PriceComponentDto
     */
    'price': number;
    /**
     * The label associated with this price component. Will be taken from the parent Projects ProjectInformation.
     * @type {string}
     * @memberof PriceComponentDto
     */
    'label'?: string;
    /**
     * The single Calculation elements this price component is composed of.
     * @type {Array<CalculationDto>}
     * @memberof PriceComponentDto
     */
    'values'?: Array<CalculationDto>;
    /**
     * These are Catalogues that are used within this PriceComponent. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
     * @type {Array<CatalogueDto>}
     * @memberof PriceComponentDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
}
/**
 * This enumeration models types of price components for better classification.
 * @export
 * @enum {string}
 */

export const PriceComponentTypeDto = {
    Unknown: 'Unknown',
    Wages: 'Wages',
    Materials: 'Materials',
    Plant: 'Plant',
    Miscellaneous: 'Miscellaneous'
} as const;

export type PriceComponentTypeDto = typeof PriceComponentTypeDto[keyof typeof PriceComponentTypeDto];


/**
 * Holds global price information for a ServiceSpecification
 * @export
 * @interface PriceInformationDto
 */
export interface PriceInformationDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof PriceInformationDto
     */
    'id': string;
    /**
     * The amount of currency per one hour of manual labour work in this project.
     * @type {number}
     * @memberof PriceInformationDto
     */
    'hourlyWage': number;
    /**
     * The final, total price will be deducted by this rate.
     * @type {number}
     * @memberof PriceInformationDto
     */
    'deductionFactor': number;
    /**
     * This is given when there is only one flat price for the whole service specification.
     * @type {number}
     * @memberof PriceInformationDto
     */
    'flatSum': number;
    /**
     * Global tax rate for the project. Note that certain elements may have a different, specific tax rate.
     * @type {number}
     * @memberof PriceInformationDto
     */
    'taxRate': number;
    /**
     * Trade discounts for offered in this ServiceSpecification.
     * @type {Array<TradeDiscountDto>}
     * @memberof PriceInformationDto
     */
    'tradeDiscounts'?: Array<TradeDiscountDto>;
}
/**
 * This enum configures rounding modes for price calculations in projects
 * @export
 * @enum {string}
 */

export const PriceRoundingModeDto = {
    Normal: 'Normal',
    Floor: 'Floor',
    Ceiling: 'Ceiling'
} as const;

export type PriceRoundingModeDto = typeof PriceRoundingModeDto[keyof typeof PriceRoundingModeDto];


/**
 * This indicates the price type of a IPricedElement.
 * @export
 * @enum {string}
 */

export const PriceTypeDto = {
    WithTotal: 'WithTotal',
    WithoutTotal: 'WithoutTotal'
} as const;

export type PriceTypeDto = typeof PriceTypeDto[keyof typeof PriceTypeDto];


/**
 * This class represents data about products and their vendor
 * @export
 * @interface ProductDataDto
 */
export interface ProductDataDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof ProductDataDto
     */
    'id': string;
    /**
     * 
     * @type {PartyInformationDto}
     * @memberof ProductDataDto
     */
    'vendor'?: PartyInformationDto;
    /**
     * The collection of ArticleData that describe this product, e.g. a pipe product could be composed out of multiple pipe segments and fittings.
     * @type {Array<ArticleDataDto>}
     * @memberof ProductDataDto
     */
    'articles'?: Array<ArticleDataDto>;
    /**
     * Short description for this ITextElement element.
     * @type {string}
     * @memberof ProductDataDto
     */
    'shortText'?: string;
    /**
     * Detailed description for this ITextElement element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof ProductDataDto
     */
    'longText'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof ProductDataDto
     */
    'htmlLongText'?: string;
}
/**
 * A Project contains all relevant information for a construction project.
 * @export
 * @interface ProjectDto
 */
export interface ProjectDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof ProjectDto
     */
    'id': string;
    /**
     * This property controls the accuracy of all price properties, meaning how many decimal places are preserved in calculations. It defaults to DEFAULT_PRICE_ACCURACY. Please see the Dangl.AVA documentation for further information about decimal precision.
     * @type {number}
     * @memberof ProjectDto
     */
    'priceAccuracy': number;
    /**
     * This forces total prices to be the strict product of quantities times unit price in positions. It is enabled by default. If this is disabled, both the unit price and the total price of positions is calculated from the non-rounded values. Please see the documentation for a more detailed explanation of this setting.
     * @type {boolean}
     * @memberof ProjectDto
     */
    'forceStrictTotals': boolean;
    /**
     * 
     * @type {PriceRoundingModeDto}
     * @memberof ProjectDto
     */
    'priceRoundingMode': PriceRoundingModeDto;
    /**
     * 
     * @type {ProjectInformationDto}
     * @memberof ProjectDto
     */
    'projectInformation'?: ProjectInformationDto;
    /**
     * The ServiceSpecifications in this Project.
     * @type {Array<ServiceSpecificationDto>}
     * @memberof ProjectDto
     */
    'serviceSpecifications'?: Array<ServiceSpecificationDto>;
    /**
     * This is used to store the GAEB XML Id within this Project. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
     * @type {string}
     * @memberof ProjectDto
     */
    'gaebXmlId'?: string;
}


/**
 * General information about a Project.
 * @export
 * @interface ProjectInformationDto
 */
export interface ProjectInformationDto {
    /**
     * 
     * @type {PartyInformationDto}
     * @memberof ProjectInformationDto
     */
    'buyer'?: PartyInformationDto;
    /**
     * Description for the project.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'description'?: string;
    /**
     * Short description for the project.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'descriptionShort'?: string;
    /**
     * Name of the project.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'name'?: string;
    /**
     * 
     * @type {PartyInformationDto}
     * @memberof ProjectInformationDto
     */
    'site'?: PartyInformationDto;
    /**
     * 
     * @type {ItemNumberSchemaDto}
     * @memberof ProjectInformationDto
     */
    'itemNumberSchema'?: ItemNumberSchemaDto;
    /**
     * Short label for the currency used.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'currencyShort'?: string;
    /**
     * Full label of the currency used.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'currencyLong'?: string;
    /**
     * Label for the labour time part of prices used in the project.
     * @type {string}
     * @memberof ProjectInformationDto
     */
    'labourTimeLabel'?: string;
    /**
     * Labels for the price components used in the project. Caution: Removal of a price component will trigger to have dependent price informations be deleted in IElements that use this property. If this property is changed or altered after the project has already been used, it is strongly advised to do operations step by step, e.g. if renaming and reordering multiple price components, this should be done one by one. Otherwise, a combination of rename and reordering will not be correctly propagated downwards to child objects in this Project.
     * @type {Array<string>}
     * @memberof ProjectInformationDto
     */
    'priceComponents'?: Array<string>;
    /**
     * This dictionary specifies actual types used for the PriceComponents. For example, a single price component might have the name \'Material\' as a string, ans this dictionary would then have a key \'Material\' and a value of Materials. You can not add keys here that are not also present in the PriceComponents property, and removing price components will also remove them from this dictionary here.
     * @type {{ [key: string]: PriceComponentTypeDto; }}
     * @memberof ProjectInformationDto
     */
    'priceComponentTypes'?: { [key: string]: PriceComponentTypeDto; };
    /**
     * This bool indicates if this project allows the bidder to add bidder comments. Bidder comments are a way to attach clarifying information when submitting an offer.
     * @type {boolean}
     * @memberof ProjectInformationDto
     */
    'bidderCommentAllowed': boolean;
    /**
     * This property indicates if the project should allow side offers from contractors. In GAEB, a side offer would typically be in exchange phase 85.
     * @type {boolean}
     * @memberof ProjectInformationDto
     */
    'sideOffersAllowed': boolean;
    /**
     * 
     * @type {AwardTypeDto}
     * @memberof ProjectInformationDto
     */
    'awardType': AwardTypeDto;
    /**
     * 
     * @type {SpecialAwardKindDto}
     * @memberof ProjectInformationDto
     */
    'specialAwardKind': SpecialAwardKindDto;
}


/**
 * Check details specificly for checking ProjectDto objects
 * @export
 * @interface ProjectValidationCheckDetails
 */
export interface ProjectValidationCheckDetails {
    /**
     * The id of the element
     * @type {string}
     * @memberof ProjectValidationCheckDetails
     */
    'elementId': string;
}
/**
 * Quantity assignments are, in contrast to SubDescriptions, used to categorize parts of their parent Position. For example, it could be categorized by cost group - e.g. a Position describing concrete walls could follow the German DIN 276 Cost Groups Standard and specify that of the total 1.000m² wall, 500m² are classified as exterior walls and 500m² are classified as interior walls. They would then have different cost groups associated, e.g. for accounting purposes.
 * @export
 * @interface QuantityAssignmentDto
 */
export interface QuantityAssignmentDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof QuantityAssignmentDto
     */
    'id': string;
    /**
     * The total quantity in this quantity assignment
     * @type {number}
     * @memberof QuantityAssignmentDto
     */
    'quantity': number;
    /**
     * These are Catalogue that are used within this ServiceSpecification. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
     * @type {Array<CatalogueDto>}
     * @memberof QuantityAssignmentDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * Referenced catalogues for this QuantityAssignment.
     * @type {Array<CatalogueReferenceDto>}
     * @memberof QuantityAssignmentDto
     */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
}
/**
 * 
 * @export
 * @interface RegisterPost
 */
export interface RegisterPost {
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterPost
     */
    'preferredLanguages'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResponseErrorType = {
    None: 'None',
    Protocol: 'Protocol',
    Http: 'Http',
    Exception: 'Exception',
    PolicyViolation: 'PolicyViolation'
} as const;

export type ResponseErrorType = typeof ResponseErrorType[keyof typeof ResponseErrorType];


/**
 * This class represents a single key reference within the German STLB \"Standardleistungsbuch Bau\"
 * @export
 * @interface STLBKeyDto
 */
export interface STLBKeyDto {
    /**
     * This identifier is required and uniquely describes a single reference within the STLB standard. It maps to \"ArtChrIdent\" in GAEB XML
     * @type {number}
     * @memberof STLBKeyDto
     */
    'artIdentifier': number;
    /**
     * This optional index property further categorizes a single reference within the STLB standard. It maps to \"ArtChIdx\" in GAEB XML
     * @type {number}
     * @memberof STLBKeyDto
     */
    'artIndex'?: number;
    /**
     * This optional identifier further specifies the execution kind of the reference in the STLB standard. It maps to \"ChVIdent\" in GAEB XML
     * @type {number}
     * @memberof STLBKeyDto
     */
    'kindIdentifier'?: number;
}
/**
 * This class represents a specialized reference to the German STLB \"Standardleistungsbuch Bau\". The STLB is a commercial offering and describes common services in the construction sector. When this is used, this describes the exact type of a service via a reference to this standard
 * @export
 * @interface STLBReferenceDto
 */
export interface STLBReferenceDto {
    /**
     * The date of the STLB version. Typically, only the Year and Month are used
     * @type {string}
     * @memberof STLBReferenceDto
     */
    'versionDate'?: string;
    /**
     * The name of the catalogue within the STLB
     * @type {string}
     * @memberof STLBReferenceDto
     */
    'catalogueName'?: string;
    /**
     * The name of the group in STLB
     * @type {string}
     * @memberof STLBReferenceDto
     */
    'group'?: string;
    /**
     * The cost group this service is associated with
     * @type {string}
     * @memberof STLBReferenceDto
     */
    'costGroup'?: string;
    /**
     * The service area (or type) in the STLB
     * @type {string}
     * @memberof STLBReferenceDto
     */
    'serviceArea'?: string;
    /**
     * These keys may optionally be used to further reference multiple, specific items within the STLB
     * @type {Array<STLBKeyDto>}
     * @memberof STLBReferenceDto
     */
    'keys'?: Array<STLBKeyDto>;
}
/**
 * This class represents properties used in commerce exchange scenarios
 * @export
 * @interface ServiceSpecificationCommercePropertiesDto
 */
export interface ServiceSpecificationCommercePropertiesDto {
    /**
     * The date until the price is valid or fixed.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'fixedPriceDate'?: string;
    /**
     * The date of the delivery voucher note.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'deliveryVoucherDate'?: string;
    /**
     * The actual date of delivery.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'deliveryDate'?: string;
    /**
     * The number of the inquiry, usually in a context of offer requests.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'inquiryNumber'?: string;
    /**
     * The number of the offer, usually in a context of an offer.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'offerNumber'?: string;
    /**
     * The order number, usually in the context of a grant or contract.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'orderNumber'?: string;
    /**
     * The order confirmation number
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'orderConfirmationNumber'?: string;
    /**
     * The number of the delivery, e.g. on the delivery note voucher.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'deliveryNumber'?: string;
    /**
     * The reference number of the customer / buyer.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'customerReferenceNumber'?: string;
    /**
     * The reference number of the supplier / bidder.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'supplierReferenceNumber'?: string;
    /**
     * The type of shippment.
     * @type {string}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'shippingType'?: string;
    /**
     * 
     * @type {CommerceInquiryTypeDto}
     * @memberof ServiceSpecificationCommercePropertiesDto
     */
    'inquiryType': CommerceInquiryTypeDto;
}


/**
 * This is the base class that holds information about a whole service specification.
 * @export
 * @interface ServiceSpecificationDto
 */
export interface ServiceSpecificationDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'id': string;
    /**
     * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'projectHourlyWage': number;
    /**
     * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'projectTaxRate': number;
    /**
     * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
     * @type {Array<string>}
     * @memberof ServiceSpecificationDto
     */
    'projectPriceComponents'?: Array<string>;
    /**
     * 
     * @type {ItemNumberSchemaDto}
     * @memberof ServiceSpecificationDto
     */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
     * The IElements within this ElementContainerBase.
     * @type {Array<IElementDto>}
     * @memberof ServiceSpecificationDto
     */
    'elements'?: Array<IElementDto>;
    /**
     * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'projectLabourTimeLabel'?: string;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationDto
     */
    'containsDuplicateItemNumbers': boolean;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationDto
     */
    'containsDuplicateElementIds': boolean;
    /**
     * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationDto
     */
    'ignoreDuplicateItemNumbers': boolean;
    /**
     * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationDto
     */
    'ignoreDuplicateElementIds': boolean;
    /**
     * Price composition by tax rate.
     * @type {Array<GrossPriceComponentDto>}
     * @memberof ServiceSpecificationDto
     */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
     * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
     * @type {boolean}
     * @memberof ServiceSpecificationDto
     */
    'ignoreChildPriceUpdates': boolean;
    /**
     * Net price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'deductedPrice': number;
    /**
     * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'deductionFactor': number;
    /**
     * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'absoluteDeduction'?: number;
    /**
     * Will return this ElementContainerBase\'s total price.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'totalPrice': number;
    /**
     * The total gross price for this ElementContainerBase including all child elements.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'totalPriceGross': number;
    /**
     * Total gross price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationDto
     */
    'totalPriceGrossDeducted': number;
    /**
     * 
     * @type {PriceTypeDto}
     * @memberof ServiceSpecificationDto
     */
    'priceType': PriceTypeDto;
    /**
     * 
     * @type {PartyInformationDto}
     * @memberof ServiceSpecificationDto
     */
    'bidder'?: PartyInformationDto;
    /**
     * This discriminator is used to identify different bidders in a project. It is different from the Identifier property in the Bidder in that the BidderDiscriminator is intended to be a numerical identifier within a project, while the Identifier does uniquely identify a bidder in the system independent of a specific project. This property should map to \"Bieternummer\" or \"BidderNo\" in GAEB.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'bidderDiscriminator'?: string;
    /**
     * This is used to store the GAEB XML Id within this ServiceSpecification. This data is not used for any calculations or evaluations but only for GAEB serialization and deserialization.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'gaebXmlId'?: string;
    /**
     * 
     * @type {ProjectInformationDto}
     * @memberof ServiceSpecificationDto
     */
    'projectInformation'?: ProjectInformationDto;
    /**
     * 
     * @type {ExchangePhaseDto}
     * @memberof ServiceSpecificationDto
     */
    'exchangePhase': ExchangePhaseDto;
    /**
     * 
     * @type {OriginDto}
     * @memberof ServiceSpecificationDto
     */
    'origin': OriginDto;
    /**
     * This property complements the Origin property. Some formats, e.g. GaebXml might have additional information attached, e.g. GAEB XML V3.2 oder GAEB XML V3.1. This string property is used to hold such data. The Dangl.AVA module does not have a list of possible values, since this is defined in the native format assemblies, e.g. Dangl.GAEB or Dangl.Oenorm.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'originDetail'?: string;
    /**
     * Creation date of this ServiceSpecification.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'creationDate'?: string;
    /**
     * Date indicating until when an offer has to be submitted. In German, this is often called the \"Eröffnungstermin\"
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'offerByDate'?: string;
    /**
     * Date indicating by when the buyer will select a contractor.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'decisionDate'?: string;
    /**
     * String indicating where the physical submission of the offer is taking place.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'submissionLocation'?: string;
    /**
     * Description of this ServiceSpecification.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'description'?: string;
    /**
     * The name of this ServiceSpecification.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'name'?: string;
    /**
     * 
     * @type {PriceInformationDto}
     * @memberof ServiceSpecificationDto
     */
    'priceInformation'?: PriceInformationDto;
    /**
     * These are Catalogue that are used within this ElementContainerBase. Catalogue references are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves.
     * @type {Array<CatalogueDto>}
     * @memberof ServiceSpecificationDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * Referenced catalogues for this ElementContainerBase.
     * @type {Array<CatalogueReferenceDto>}
     * @memberof ServiceSpecificationDto
     */
    'catalogueReferences'?: Array<CatalogueReferenceDto>;
    /**
     * The date when the execution of the services is scheduled to start
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'plannedExecutionStart'?: string;
    /**
     * The date then the execution of the services is scheduled to be finished
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'plannedExecutionEnd'?: string;
    /**
     * The date on which the contract has been awarded. This matches \"Auftragsdatum\" in GAEB
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'contractDate'?: string;
    /**
     * This value can be used to indicate the number or identifier of the contract. It matches \"Auftragsnummer\" in GAEB
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'contractIdentifier'?: string;
    /**
     * 
     * @type {WarrantyDurationDto}
     * @memberof ServiceSpecificationDto
     */
    'warrantyDuration'?: WarrantyDurationDto;
    /**
     * The date on which the warranty period ends
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'warrantyEnd'?: string;
    /**
     * The date on which the services rendered by the bidder are scheduled to be approved by the buyer
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'approvalDate'?: string;
    /**
     * This should specify how the approval is performed by the buyer. This matches \"AcceptType\" in GAEB
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'typeOfApproval'?: string;
    /**
     * This optional string property is shared by all IElements, and indicates if the element is part of an addendum, a \'Nachtrag\' in German.
     * @type {string}
     * @memberof ServiceSpecificationDto
     */
    'addendumNumber'?: string;
    /**
     * 
     * @type {AddendumStatusDto}
     * @memberof ServiceSpecificationDto
     */
    'addendumStatus'?: AddendumStatusDto;
    /**
     * 
     * @type {ServiceSpecificationCommercePropertiesDto}
     * @memberof ServiceSpecificationDto
     */
    'commerceProperties'?: ServiceSpecificationCommercePropertiesDto;
}


/**
 * 
 * @export
 * @interface ServiceSpecificationGroupDto
 */
export interface ServiceSpecificationGroupDto extends IElementDto {
    /**
     * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'projectHourlyWage': number;
    /**
     * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'projectTaxRate': number;
    /**
     * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
     * @type {Array<string>}
     * @memberof ServiceSpecificationGroupDto
     */
    'projectPriceComponents'?: Array<string>;
    /**
     * 
     * @type {ItemNumberSchemaDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
     * The IElements within this ElementContainerBase.
     * @type {Array<IElementDto>}
     * @memberof ServiceSpecificationGroupDto
     */
    'elements'?: Array<IElementDto>;
    /**
     * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
     * @type {string}
     * @memberof ServiceSpecificationGroupDto
     */
    'projectLabourTimeLabel'?: string;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'containsDuplicateItemNumbers': boolean;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'containsDuplicateElementIds': boolean;
    /**
     * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'ignoreDuplicateItemNumbers': boolean;
    /**
     * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'ignoreDuplicateElementIds': boolean;
    /**
     * Price composition by tax rate.
     * @type {Array<GrossPriceComponentDto>}
     * @memberof ServiceSpecificationGroupDto
     */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
     * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'ignoreChildPriceUpdates': boolean;
    /**
     * Net price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'deductedPrice': number;
    /**
     * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'deductionFactor': number;
    /**
     * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'absoluteDeduction'?: number;
    /**
     * Will return this ElementContainerBase\'s total price.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'totalPrice': number;
    /**
     * The total gross price for this ElementContainerBase including all child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'totalPriceGross': number;
    /**
     * Total gross price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'totalPriceGrossDeducted': number;
    /**
     * 
     * @type {PriceTypeDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'priceType': PriceTypeDto;
    /**
     * Description for this ServiceSpecificationGroup.
     * @type {string}
     * @memberof ServiceSpecificationGroupDto
     */
    'shortText'?: string;
    /**
     * 
     * @type {ComissionStatusDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'comissionStatus': ComissionStatusDto;
    /**
     * 
     * @type {ItemNumberDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'itemNumber'?: ItemNumberDto;
    /**
     * 
     * @type {string}
     * @memberof ServiceSpecificationGroupDto
     */
    'elementType'?: string;
    /**
     * This indicates if this group is the parent of a lot. See the documentation for more information about working with lots.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDto
     */
    'isLot': boolean;
    /**
     * If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to \"WithoutTotal\" so this group does not factor into total costs. The PriceType is not changed when this property is set
     * @type {string}
     * @memberof ServiceSpecificationGroupDto
     */
    'alternativeTo'?: string;
    /**
     * 
     * @type {OenormPropertiesDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'oenormProperties'?: OenormPropertiesDto;
    /**
     * This is a zero based hierarchy level. It\'s set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
     * @type {number}
     * @memberof ServiceSpecificationGroupDto
     */
    'hierarchyLevel': number;
    /**
     * 
     * @type {AddendumStatusDto}
     * @memberof ServiceSpecificationGroupDto
     */
    'addendumStatus'?: AddendumStatusDto;
}


/**
 * This is a grouping IElement that holds other IElements within.
 * @export
 * @interface ServiceSpecificationGroupDtoAllOf
 */
export interface ServiceSpecificationGroupDtoAllOf {
    /**
     * The hourly wage that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'projectHourlyWage': number;
    /**
     * The tax rate that is used within this ElementContainerBase. Will be propagated to child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'projectTaxRate': number;
    /**
     * The price components that are used within this project. They are ignored during Json deserialization because they will be set from the parent project.
     * @type {Array<string>}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'projectPriceComponents'?: Array<string>;
    /**
     * 
     * @type {ItemNumberSchemaDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'projectItemNumberSchema'?: ItemNumberSchemaDto;
    /**
     * The IElements within this ElementContainerBase.
     * @type {Array<IElementDto>}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'elements'?: Array<IElementDto>;
    /**
     * The label used in the parent Project to mark labour time, e.g. \"Hours\" or \"Stunden\".
     * @type {string}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'projectLabourTimeLabel'?: string;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated ItemNumbers or if any child ElementContainerBase elements themselves contain duplicate ItemNumber s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'containsDuplicateItemNumbers': boolean;
    /**
     * Indicates if there are child IElements that have conflicting, duplicated Ids or if any child ElementContainerBase elements themselves contain duplicate Id s. Will always indicate false when told to ignore duplicate item numbers.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'containsDuplicateElementIds': boolean;
    /**
     * Indicate if duplicated ItemNumbers within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'ignoreDuplicateItemNumbers': boolean;
    /**
     * Indicate if duplicated Ids within child elements are to be ignored. Will not perform checks for duplicates if yes.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'ignoreDuplicateElementIds': boolean;
    /**
     * Price composition by tax rate.
     * @type {Array<GrossPriceComponentDto>}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'totalPriceGrossByTaxRate'?: Array<GrossPriceComponentDto>;
    /**
     * Internally used to indicate that a propagation is currently done, this is done to not recalculate every single result from a lot of changes when it is sufficient to calculate the total price at once.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'ignoreChildPriceUpdates': boolean;
    /**
     * Net price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'deductedPrice': number;
    /**
     * Factor of applied deductions to the total price. For example, \"0.03\" means that a 3% deduction is to be applied.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'deductionFactor': number;
    /**
     * The exact amount of the discount as an absolute value. For backwards compatibility reasons, setting this value will also set a calculated value to DeductionFactor, which will also be updated in case the total price is changed to reflect a relative value of the absolute discount sum.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'absoluteDeduction'?: number;
    /**
     * Will return this ElementContainerBase\'s total price.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'totalPrice': number;
    /**
     * The total gross price for this ElementContainerBase including all child elements.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'totalPriceGross': number;
    /**
     * Total gross price after applied deductions.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'totalPriceGrossDeducted': number;
    /**
     * 
     * @type {PriceTypeDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'priceType': PriceTypeDto;
    /**
     * Description for this ServiceSpecificationGroup.
     * @type {string}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'shortText'?: string;
    /**
     * 
     * @type {ComissionStatusDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'comissionStatus': ComissionStatusDto;
    /**
     * 
     * @type {ItemNumberDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'itemNumber'?: ItemNumberDto;
    /**
     * 
     * @type {string}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'elementType'?: string;
    /**
     * This indicates if this group is the parent of a lot. See the documentation for more information about working with lots.
     * @type {boolean}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'isLot': boolean;
    /**
     * If this group is an alternative for a base group, then this property should point to the id of the group in this service specification that it can replace. If this is an alternative group to a base group, the PriceType should typically be set to \"WithoutTotal\" so this group does not factor into total costs. The PriceType is not changed when this property is set
     * @type {string}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'alternativeTo'?: string;
    /**
     * 
     * @type {OenormPropertiesDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'oenormProperties'?: OenormPropertiesDto;
    /**
     * This is a zero based hierarchy level. It\'s set automatically when used in the context of a Project, and can be used to identify the hierarchy level of the current element.
     * @type {number}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'hierarchyLevel': number;
    /**
     * 
     * @type {AddendumStatusDto}
     * @memberof ServiceSpecificationGroupDtoAllOf
     */
    'addendumStatus'?: AddendumStatusDto;
}


/**
 * The service type describes the type of service a Position represents.
 * @export
 * @enum {string}
 */

export const ServiceTypeDto = {
    Regular: 'Regular',
    HourlyPaidWork: 'HourlyPaidWork'
} as const;

export type ServiceTypeDto = typeof ServiceTypeDto[keyof typeof ServiceTypeDto];


/**
 * This enumeration describes awards for project that are not just a regular procurement. For example, it can be used to describe recurring maintenance or an outline contract (German: Rahmenvertrag) which just specifies services and prices but may be requested on demand when necessary
 * @export
 * @enum {string}
 */

export const SpecialAwardKindDto = {
    Unspecified: 'Unspecified',
    MaintenanceContract: 'MaintenanceContract',
    OutlineContract: 'OutlineContract',
    OutlineForMaintenanceContract: 'OutlineForMaintenanceContract'
} as const;

export type SpecialAwardKindDto = typeof SpecialAwardKindDto[keyof typeof SpecialAwardKindDto];


/**
 * This enumeration identifies a pre-known standard used for referencing standardized descriptions.
 * @export
 * @enum {string}
 */

export const StandardReferenceTypeDto = {
    Unknown: 'Unknown',
    StLb: 'StLB',
    StLk: 'StLK',
    StlbBauZ: 'STLBBauZ'
} as const;

export type StandardReferenceTypeDto = typeof StandardReferenceTypeDto[keyof typeof StandardReferenceTypeDto];


/**
 * This class represents a standardized description. This means that instead of solely relying on texts to describe a service, external standards and definitions are referenced for a common understanding.
 * @export
 * @interface StandardizedDescriptionDto
 */
export interface StandardizedDescriptionDto {
    /**
     * 
     * @type {StandardReferenceTypeDto}
     * @memberof StandardizedDescriptionDto
     */
    'standardReferenceType': StandardReferenceTypeDto;
    /**
     * This string property is the identifier to map to the references standard. Its type is given in the StandardReferenceType
     * @type {string}
     * @memberof StandardizedDescriptionDto
     */
    'standardReference'?: string;
    /**
     * 
     * @type {STLBReferenceDto}
     * @memberof StandardizedDescriptionDto
     */
    'stlbReference'?: STLBReferenceDto;
}


/**
 * This is appended to a Position and is used to separate the complete Position into smaller amounts to be described separately, for example concrete walls could be attached to different building storeys.
 * @export
 * @interface SubDescriptionDto
 */
export interface SubDescriptionDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'id': string;
    /**
     * Returns the total calculated sum of all quantity assignments. Will return the result rounded to three decimal places.
     * @type {number}
     * @memberof SubDescriptionDto
     */
    'quantity': number;
    /**
     * You can use this property to directly set the quantity for this sub description. This will override any given QuantityComponents
     * @type {number}
     * @memberof SubDescriptionDto
     */
    'quantityOverride'?: number;
    /**
     * Holds quantity information for this sub description. Quantity is listening to changes here and is reporting the total sum of all quantity components.
     * @type {Array<CalculationDto>}
     * @memberof SubDescriptionDto
     */
    'quantityComponents'?: Array<CalculationDto>;
    /**
     * Indicates if the bidder is asked to specify an amount.
     * @type {boolean}
     * @memberof SubDescriptionDto
     */
    'amountToBeEnteredByBidder': boolean;
    /**
     * Identifier for this SubDescription.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'identifier'?: string;
    /**
     * Short description for this DescriptionBase element.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'shortText'?: string;
    /**
     * Detailed description for this DescriptionBase element. When the HtmlLongText is set, this is automatically overwritten and filled with the appropriate plain text representation of the Html text. Vice versa, setting this property overrides the HtmlLongText.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'longText'?: string;
    /**
     * If this is given, then the sub description has a different unit tag than the parent position.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'unitTag'?: string;
    /**
     * This contains the Html representation of the Longtext. When the LongText is set, this is automatically overwritten and filled with the appropriate Html representation of the plaintext. Vice versa, setting this property overrides the LongText. GAEB 90 and GAEB 2000 exports do not support any image functionality. In GAEB XML, only images that use an embedded Base64 data uri are exported, regular url references are cleared before written out.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'htmlLongText'?: string;
    /**
     * 
     * @type {AdditionTypeDto}
     * @memberof SubDescriptionDto
     */
    'additionType': AdditionTypeDto;
    /**
     * 
     * @type {StandardizedDescriptionDto}
     * @memberof SubDescriptionDto
     */
    'standardizedDescription'?: StandardizedDescriptionDto;
    /**
     * This identifier can be used to point to the Id of an ExecutionDescription in the same ServiceSpecification. ExecutionDescriptions act as a way to centrally describe how positions (or sub descriptions) should be executed in practice. Often, the position (or sub description) itself still has text of its own to highlight deviations from that or add more details. When working with import and export features, this property is only supported in GAEB 90 data exchange.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'executionDescriptionReference'?: string;
    /**
     * These are Catalogues that are used within this Calculation. Catalogues are used to describe catalogues, or collections, that can be used to describe elements with commonly known properties. For example, QuantityAssignments use these to categorize themselves. They are propagate to all child elements, e.g. other containers and QuantityAssignments. In the context of a ServiceSpecification, all elements share the same instance of the collection.
     * @type {Array<CatalogueDto>}
     * @memberof SubDescriptionDto
     */
    'projectCatalogues'?: Array<CatalogueDto>;
    /**
     * This is an identifier specific for this description. Some exchange formats, like GAEB XML, use it to identify descriptions. It\'s different to an elements identifier in that it should only apply to the description component, meaning the text itself.
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'descriptionId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubDescriptionDto
     */
    'hasBidderCommentInHtmlLongText': boolean;
    /**
     * 
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'elementType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubDescriptionDto
     */
    'elementTypeDiscriminator'?: string;
}


/**
 * 
 * @export
 * @interface TokenLoginPost
 */
export interface TokenLoginPost {
    /**
     * 
     * @type {string}
     * @memberof TokenLoginPost
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof TokenLoginPost
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshPost
 */
export interface TokenRefreshPost {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshPost
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface TokenResponseGet
 */
export interface TokenResponseGet {
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'accessToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'errorDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenResponseGet
     */
    'expiresIn': number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'httpErrorReason'?: string;
    /**
     * 
     * @type {HttpStatusCode}
     * @memberof TokenResponseGet
     */
    'httpStatusCode': HttpStatusCode;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'identityToken'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenResponseGet
     */
    'isError': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'tokenType'?: string;
    /**
     * 
     * @type {ResponseErrorType}
     * @memberof TokenResponseGet
     */
    'errorType': ResponseErrorType;
}


/**
 * This class holds information about offered trade discounts (Skonto in German)
 * @export
 * @interface TradeDiscountDto
 */
export interface TradeDiscountDto {
    /**
     * Elements GUID identifier.
     * @type {string}
     * @memberof TradeDiscountDto
     */
    'id': string;
    /**
     * The amount of days for how long a declared trade discount applies. Must be a positive number, negative values will be ignored and not set.
     * @type {number}
     * @memberof TradeDiscountDto
     */
    'deadline': number;
    /**
     * The rate of the trade discount.
     * @type {number}
     * @memberof TradeDiscountDto
     */
    'rate': number;
}
/**
 * This class models the results of a single check performed during a validation action
 * @export
 * @interface ValidationCheckResult
 */
export interface ValidationCheckResult {
    /**
     * 
     * @type {ValidationSeverity}
     * @memberof ValidationCheckResult
     */
    'severity': ValidationSeverity;
    /**
     * 
     * @type {ValidationCheckType}
     * @memberof ValidationCheckResult
     */
    'checkType': ValidationCheckType;
    /**
     * A human readable message describing the result of the check.
     * @type {string}
     * @memberof ValidationCheckResult
     */
    'message'?: string;
    /**
     * 
     * @type {ObjectValidationCheckDetails}
     * @memberof ValidationCheckResult
     */
    'objectValidationCheckDetails'?: ObjectValidationCheckDetails;
    /**
     * 
     * @type {XmlSchemaValidationCheckDetails}
     * @memberof ValidationCheckResult
     */
    'xmlSchemaValidationCheckDetails'?: XmlSchemaValidationCheckDetails;
    /**
     * 
     * @type {ProjectValidationCheckDetails}
     * @memberof ValidationCheckResult
     */
    'projectValidationCheckDetails'?: ProjectValidationCheckDetails;
}


/**
 * Enumeration for the different types of checks performed
 * @export
 * @enum {string}
 */

export const ValidationCheckType = {
    General: 'General',
    XmlSchemaCheck: 'XmlSchemaCheck',
    ObjectValidation: 'ObjectValidation',
    ProjectValidation: 'ProjectValidation'
} as const;

export type ValidationCheckType = typeof ValidationCheckType[keyof typeof ValidationCheckType];


/**
 * This class represents the result of a validation operation
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
    /**
     * Indicates if the validation produced no errors
     * @type {boolean}
     * @memberof ValidationResult
     */
    'isSchemaCompliant': boolean;
    /**
     * List of validation check results, which are usually errors
     * @type {Array<ValidationCheckResult>}
     * @memberof ValidationResult
     */
    'checkResults'?: Array<ValidationCheckResult>;
    /**
     * 
     * @type {ValidationType}
     * @memberof ValidationResult
     */
    'validationType': ValidationType;
    /**
     * Name of the validated file
     * @type {string}
     * @memberof ValidationResult
     */
    'fileName'?: string;
}


/**
 * Indicates the severity of a check
 * @export
 * @enum {string}
 */

export const ValidationSeverity = {
    Information: 'Information',
    Warning: 'Warning',
    Error: 'Error',
    Critical: 'Critical'
} as const;

export type ValidationSeverity = typeof ValidationSeverity[keyof typeof ValidationSeverity];


/**
 * This enumeration represents the possible conversion targets when performing a validation
 * @export
 * @enum {string}
 */

export const ValidationType = {
    Project: 'Project',
    Gaeb: 'Gaeb',
    Oenorm: 'Oenorm'
} as const;

export type ValidationType = typeof ValidationType[keyof typeof ValidationType];


/**
 * This class does not represent a typical `TimeSpan` but has a scalar value int Duration and a DurationUnit Unit to represent durations as typically used in contracts, e.g. 5 Months
 * @export
 * @interface WarrantyDurationDto
 */
export interface WarrantyDurationDto {
    /**
     * The scalar value of the duration. This value must be equal to or bigger than zero (>= 0). Negative values can not be set and will be ignored.
     * @type {number}
     * @memberof WarrantyDurationDto
     */
    'duration': number;
    /**
     * 
     * @type {DurationUnitDto}
     * @memberof WarrantyDurationDto
     */
    'unit': DurationUnitDto;
}


/**
 * Check details for an XML schema validation result
 * @export
 * @interface XmlSchemaValidationCheckDetails
 */
export interface XmlSchemaValidationCheckDetails {
    /**
     * The line number on which the validation happened
     * @type {number}
     * @memberof XmlSchemaValidationCheckDetails
     */
    'lineNumber': number;
    /**
     * The position in the line
     * @type {number}
     * @memberof XmlSchemaValidationCheckDetails
     */
    'linePosition': number;
}

/**
 * AslvConversionApi - axios parameter creator
 * @export
 */
export const AslvConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts Aslv files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToAva: async (removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, aslvFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/aslv/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (aslvFile !== undefined) { 
                localVarFormParams.append('aslvFile', aslvFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Aslv files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToExcel: async (writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, aslvFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/aslv/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (aslvFile !== undefined) { 
                localVarFormParams.append('aslvFile', aslvFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Aslv files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToGaeb: async (destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, aslvFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/aslv/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (aslvFile !== undefined) { 
                localVarFormParams.append('aslvFile', aslvFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Aslv files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToOenorm: async (destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, aslvFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/aslv/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (aslvFile !== undefined) { 
                localVarFormParams.append('aslvFile', aslvFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AslvConversionApi - functional programming interface
 * @export
 */
export const AslvConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AslvConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts Aslv files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aslvConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, aslvFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aslvConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, aslvFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Aslv files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aslvConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, aslvFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aslvConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, aslvFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Aslv files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aslvConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, aslvFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aslvConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, aslvFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Aslv files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aslvConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, aslvFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aslvConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, aslvFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AslvConversionApi - factory interface
 * @export
 */
export const AslvConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AslvConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts Aslv files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, aslvFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.aslvConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, aslvFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Aslv files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, aslvFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.aslvConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, aslvFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Aslv files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, aslvFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.aslvConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, aslvFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Aslv files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [aslvFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aslvConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, aslvFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.aslvConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, aslvFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AslvConversionApi - object-oriented interface
 * @export
 * @class AslvConversionApi
 * @extends {BaseAPI}
 */
export class AslvConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts Aslv files to Dangl.AVA projects
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [aslvFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AslvConversionApi
     */
    public aslvConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, aslvFile?: File, options?: AxiosRequestConfig) {
        return AslvConversionApiFp(this.configuration).aslvConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, aslvFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Aslv files to Excel
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [aslvFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AslvConversionApi
     */
    public aslvConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, aslvFile?: File, options?: AxiosRequestConfig) {
        return AslvConversionApiFp(this.configuration).aslvConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, aslvFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Aslv files to GAEB files
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [aslvFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AslvConversionApi
     */
    public aslvConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, aslvFile?: File, options?: AxiosRequestConfig) {
        return AslvConversionApiFp(this.configuration).aslvConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, aslvFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Aslv files to Oenorm files
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [aslvFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AslvConversionApi
     */
    public aslvConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, aslvFile?: File, options?: AxiosRequestConfig) {
        return AslvConversionApiFp(this.configuration).aslvConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, aslvFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AvaConversionApi - axios parameter creator
 * @export
 */
export const AvaConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToAva: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToAva', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Excel
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToExcel: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToExcel', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to GAEB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToGaeb: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToGaeb', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Oenorm
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToOenorm: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToOenorm', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to REB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'D11' | 'X31GaebXmlV32'} [destinationRebType] Defaults to D11
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToReb: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToReb', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/reb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }

            if (destinationRebType !== undefined) {
                localVarQueryParameter['DestinationRebType'] = destinationRebType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to SIA 451
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToSia: async (avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProject' is not null or undefined
            assertParamExists('avaConversionConvertToSia', 'avaProject', avaProject)
            const localVarPath = `/conversion/ava/sia`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (tryAutoGenerateItemNumbersAndSchema !== undefined) {
                localVarQueryParameter['TryAutoGenerateItemNumbersAndSchema'] = tryAutoGenerateItemNumbersAndSchema;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvaConversionApi - functional programming interface
 * @export
 */
export const AvaConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvaConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToAva(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToAva(avaProject, tryAutoGenerateItemNumbersAndSchema, removePlainTextLongTexts, removeHtmlLongTexts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Excel
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToExcel(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToExcel(avaProject, tryAutoGenerateItemNumbersAndSchema, writePrices, writeLongTexts, conversionCulture, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to GAEB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToGaeb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToGaeb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Oenorm
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToOenorm(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToOenorm(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to REB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'D11' | 'X31GaebXmlV32'} [destinationRebType] Defaults to D11
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToReb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToReb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationRebType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to SIA 451
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async avaConversionConvertToSia(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.avaConversionConvertToSia(avaProject, tryAutoGenerateItemNumbersAndSchema, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AvaConversionApi - factory interface
 * @export
 */
export const AvaConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvaConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToAva(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.avaConversionConvertToAva(avaProject, tryAutoGenerateItemNumbersAndSchema, removePlainTextLongTexts, removeHtmlLongTexts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Excel
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToExcel(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: any): AxiosPromise<File> {
            return localVarFp.avaConversionConvertToExcel(avaProject, tryAutoGenerateItemNumbersAndSchema, writePrices, writeLongTexts, conversionCulture, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to GAEB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToGaeb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.avaConversionConvertToGaeb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to Oenorm
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToOenorm(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.avaConversionConvertToOenorm(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to REB
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {'D11' | 'X31GaebXmlV32'} [destinationRebType] Defaults to D11
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToReb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options?: any): AxiosPromise<File> {
            return localVarFp.avaConversionConvertToReb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationRebType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Dangl.AVA projects to SIA 451
         * @param {ProjectDto} avaProject The Dangl.AVA project
         * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        avaConversionConvertToSia(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.avaConversionConvertToSia(avaProject, tryAutoGenerateItemNumbersAndSchema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvaConversionApi - object-oriented interface
 * @export
 * @class AvaConversionApi
 * @extends {BaseAPI}
 */
export class AvaConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts Dangl.AVA projects to Dangl.AVA. This is useful when you want to generate the calculated properties.
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToAva(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToAva(avaProject, tryAutoGenerateItemNumbersAndSchema, removePlainTextLongTexts, removeHtmlLongTexts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Dangl.AVA projects to Excel
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToExcel(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToExcel(avaProject, tryAutoGenerateItemNumbersAndSchema, writePrices, writeLongTexts, conversionCulture, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Dangl.AVA projects to GAEB
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToGaeb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToGaeb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Dangl.AVA projects to Oenorm
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToOenorm(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToOenorm(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Dangl.AVA projects to REB
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {'D11' | 'X31GaebXmlV32'} [destinationRebType] Defaults to D11
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToReb(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, destinationRebType?: 'D11' | 'X31GaebXmlV32', options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToReb(avaProject, tryAutoGenerateItemNumbersAndSchema, destinationRebType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Dangl.AVA projects to SIA 451
     * @param {ProjectDto} avaProject The Dangl.AVA project
     * @param {boolean} [tryAutoGenerateItemNumbersAndSchema] If this is set to true, AVACloud will try to generate item numbers and an item number schema automatically for the input project. The operation will not have any effect if either an item number schema is already present, or if any of the elements already has an item number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvaConversionApi
     */
    public avaConversionConvertToSia(avaProject: ProjectDto, tryAutoGenerateItemNumbersAndSchema?: boolean, options?: AxiosRequestConfig) {
        return AvaConversionApiFp(this.configuration).avaConversionConvertToSia(avaProject, tryAutoGenerateItemNumbersAndSchema, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DanglIdentityApi - axios parameter creator
 * @export
 */
export const DanglIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TokenLoginPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginAndReturnToken: async (model: TokenLoginPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('danglIdentityLoginAndReturnToken', 'model', model)
            const localVarPath = `/identity/token-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginPost} model 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginWithCookie: async (model: LoginPost, redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('danglIdentityLoginWithCookie', 'model', model)
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenRefreshPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRefreshToken: async (model: TokenRefreshPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('danglIdentityRefreshToken', 'model', model)
            const localVarPath = `/identity/token-refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterPost} registerModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRegister: async (registerModel: RegisterPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerModel' is not null or undefined
            assertParamExists('danglIdentityRegister', 'registerModel', registerModel)
            const localVarPath = `/identity/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRequestPasswordReset: async (forgotPasswordModel: ForgotPasswordPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordModel' is not null or undefined
            assertParamExists('danglIdentityRequestPasswordReset', 'forgotPasswordModel', forgotPasswordModel)
            const localVarPath = `/identity/password-forgotten`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentitySignOutWithSignInManager: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DanglIdentityApi - functional programming interface
 * @export
 */
export const DanglIdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DanglIdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TokenLoginPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityLoginAndReturnToken(model: TokenLoginPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityLoginAndReturnToken(model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginPost} model 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityLoginWithCookie(model: LoginPost, redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityLoginWithCookie(model, redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenRefreshPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRefreshToken(model: TokenRefreshPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRefreshToken(model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterPost} registerModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRegister(registerModel: RegisterPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRegister(registerModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRequestPasswordReset(forgotPasswordModel: ForgotPasswordPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRequestPasswordReset(forgotPasswordModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentitySignOutWithSignInManager(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentitySignOutWithSignInManager(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DanglIdentityApi - factory interface
 * @export
 */
export const DanglIdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DanglIdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {TokenLoginPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginAndReturnToken(model: TokenLoginPost, options?: any): AxiosPromise<TokenResponseGet> {
            return localVarFp.danglIdentityLoginAndReturnToken(model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginPost} model 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginWithCookie(model: LoginPost, redirectUrl?: string, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityLoginWithCookie(model, redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenRefreshPost} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRefreshToken(model: TokenRefreshPost, options?: any): AxiosPromise<TokenResponseGet> {
            return localVarFp.danglIdentityRefreshToken(model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterPost} registerModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRegister(registerModel: RegisterPost, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityRegister(registerModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRequestPasswordReset(forgotPasswordModel: ForgotPasswordPost, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityRequestPasswordReset(forgotPasswordModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentitySignOutWithSignInManager(options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentitySignOutWithSignInManager(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DanglIdentityApi - object-oriented interface
 * @export
 * @class DanglIdentityApi
 * @extends {BaseAPI}
 */
export class DanglIdentityApi extends BaseAPI {
    /**
     * 
     * @param {TokenLoginPost} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityLoginAndReturnToken(model: TokenLoginPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityLoginAndReturnToken(model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginPost} model 
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityLoginWithCookie(model: LoginPost, redirectUrl?: string, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityLoginWithCookie(model, redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenRefreshPost} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRefreshToken(model: TokenRefreshPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRefreshToken(model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterPost} registerModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRegister(registerModel: RegisterPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRegister(registerModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordPost} forgotPasswordModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRequestPasswordReset(forgotPasswordModel: ForgotPasswordPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRequestPasswordReset(forgotPasswordModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentitySignOutWithSignInManager(options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentitySignOutWithSignInManager(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExcelConversionApi - axios parameter creator
 * @export
 */
export const ExcelConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts Excel files to Dangl.AVA projects.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToAva: async (readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, excelFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/excel/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (readNewElements !== undefined) {
                localVarQueryParameter['ReadNewElements'] = readNewElements;
            }

            if (rebuildItemNumberSchema !== undefined) {
                localVarQueryParameter['RebuildItemNumberSchema'] = rebuildItemNumberSchema;
            }

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (excelFile !== undefined) { 
                localVarFormParams.append('excelFile', excelFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToExcel: async (readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, excelFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/excel/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (readNewElements !== undefined) {
                localVarQueryParameter['ReadNewElements'] = readNewElements;
            }

            if (rebuildItemNumberSchema !== undefined) {
                localVarQueryParameter['RebuildItemNumberSchema'] = rebuildItemNumberSchema;
            }

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (excelFile !== undefined) { 
                localVarFormParams.append('excelFile', excelFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Excel files to GAEB files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToGaeb: async (readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, excelFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/excel/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (readNewElements !== undefined) {
                localVarQueryParameter['ReadNewElements'] = readNewElements;
            }

            if (rebuildItemNumberSchema !== undefined) {
                localVarQueryParameter['RebuildItemNumberSchema'] = rebuildItemNumberSchema;
            }

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (excelFile !== undefined) { 
                localVarFormParams.append('excelFile', excelFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts Excel files to Oenorm files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToOenorm: async (readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, excelFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/excel/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (readNewElements !== undefined) {
                localVarQueryParameter['ReadNewElements'] = readNewElements;
            }

            if (rebuildItemNumberSchema !== undefined) {
                localVarQueryParameter['RebuildItemNumberSchema'] = rebuildItemNumberSchema;
            }

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (excelFile !== undefined) { 
                localVarFormParams.append('excelFile', excelFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExcelConversionApi - functional programming interface
 * @export
 */
export const ExcelConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExcelConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts Excel files to Dangl.AVA projects.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excelConversionConvertToAva(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, excelFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excelConversionConvertToAva(readNewElements, rebuildItemNumberSchema, removePlainTextLongTexts, removeHtmlLongTexts, excelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excelConversionConvertToExcel(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, excelFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excelConversionConvertToExcel(readNewElements, rebuildItemNumberSchema, writePrices, writeLongTexts, conversionCulture, excelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Excel files to GAEB files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excelConversionConvertToGaeb(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, excelFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excelConversionConvertToGaeb(readNewElements, rebuildItemNumberSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, excelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts Excel files to Oenorm files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excelConversionConvertToOenorm(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, excelFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excelConversionConvertToOenorm(readNewElements, rebuildItemNumberSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, excelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExcelConversionApi - factory interface
 * @export
 */
export const ExcelConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExcelConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts Excel files to Dangl.AVA projects.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToAva(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, excelFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.excelConversionConvertToAva(readNewElements, rebuildItemNumberSchema, removePlainTextLongTexts, removeHtmlLongTexts, excelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToExcel(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, excelFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.excelConversionConvertToExcel(readNewElements, rebuildItemNumberSchema, writePrices, writeLongTexts, conversionCulture, excelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Excel files to GAEB files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToGaeb(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, excelFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.excelConversionConvertToGaeb(readNewElements, rebuildItemNumberSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, excelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts Excel files to Oenorm files.
         * @param {boolean} [readNewElements] Defaults to false
         * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [excelFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelConversionConvertToOenorm(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, excelFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.excelConversionConvertToOenorm(readNewElements, rebuildItemNumberSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, excelFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExcelConversionApi - object-oriented interface
 * @export
 * @class ExcelConversionApi
 * @extends {BaseAPI}
 */
export class ExcelConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts Excel files to Dangl.AVA projects.
     * @param {boolean} [readNewElements] Defaults to false
     * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [excelFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExcelConversionApi
     */
    public excelConversionConvertToAva(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, excelFile?: File, options?: AxiosRequestConfig) {
        return ExcelConversionApiFp(this.configuration).excelConversionConvertToAva(readNewElements, rebuildItemNumberSchema, removePlainTextLongTexts, removeHtmlLongTexts, excelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Excel files to Excel files. Used, for example, when elements were added in excel to generate or modify a project. The Excel file can then be shared containing the full project with all formattings, formulas and styles applied.
     * @param {boolean} [readNewElements] Defaults to false
     * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [excelFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExcelConversionApi
     */
    public excelConversionConvertToExcel(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, excelFile?: File, options?: AxiosRequestConfig) {
        return ExcelConversionApiFp(this.configuration).excelConversionConvertToExcel(readNewElements, rebuildItemNumberSchema, writePrices, writeLongTexts, conversionCulture, excelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Excel files to GAEB files.
     * @param {boolean} [readNewElements] Defaults to false
     * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [excelFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExcelConversionApi
     */
    public excelConversionConvertToGaeb(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, excelFile?: File, options?: AxiosRequestConfig) {
        return ExcelConversionApiFp(this.configuration).excelConversionConvertToGaeb(readNewElements, rebuildItemNumberSchema, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, excelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts Excel files to Oenorm files.
     * @param {boolean} [readNewElements] Defaults to false
     * @param {boolean} [rebuildItemNumberSchema] When importing new elements from Excel, sometimes the ItemNumberSchema in the file is not in compliance with the GAEB requirements. Enabling this option tries to repair the ItemNumberSchema. Defaults to false.
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [excelFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExcelConversionApi
     */
    public excelConversionConvertToOenorm(readNewElements?: boolean, rebuildItemNumberSchema?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, excelFile?: File, options?: AxiosRequestConfig) {
        return ExcelConversionApiFp(this.configuration).excelConversionConvertToOenorm(readNewElements, rebuildItemNumberSchema, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, excelFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GaebConversionApi - axios parameter creator
 * @export
 */
export const GaebConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts GAEB files to Dangl.AVA projects
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToAva: async (supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, gaebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/gaeb/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (supportSkippedItemNumberLevelsInPositions !== undefined) {
                localVarQueryParameter['SupportSkippedItemNumberLevelsInPositions'] = supportSkippedItemNumberLevelsInPositions;
            }

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (gaebFile !== undefined) { 
                localVarFormParams.append('gaebFile', gaebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts GAEB files to Excel
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToExcel: async (supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, gaebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/gaeb/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (supportSkippedItemNumberLevelsInPositions !== undefined) {
                localVarQueryParameter['SupportSkippedItemNumberLevelsInPositions'] = supportSkippedItemNumberLevelsInPositions;
            }

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (gaebFile !== undefined) { 
                localVarFormParams.append('gaebFile', gaebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToGaeb: async (supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, gaebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/gaeb/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (supportSkippedItemNumberLevelsInPositions !== undefined) {
                localVarQueryParameter['SupportSkippedItemNumberLevelsInPositions'] = supportSkippedItemNumberLevelsInPositions;
            }

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (gaebFile !== undefined) { 
                localVarFormParams.append('gaebFile', gaebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts GAEB files to Oenorm files
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToOenorm: async (supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, gaebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/gaeb/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (supportSkippedItemNumberLevelsInPositions !== undefined) {
                localVarQueryParameter['SupportSkippedItemNumberLevelsInPositions'] = supportSkippedItemNumberLevelsInPositions;
            }

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (gaebFile !== undefined) { 
                localVarFormParams.append('gaebFile', gaebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GaebConversionApi - functional programming interface
 * @export
 */
export const GaebConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GaebConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts GAEB files to Dangl.AVA projects
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, gaebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions, removePlainTextLongTexts, removeHtmlLongTexts, gaebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts GAEB files to Excel
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, gaebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions, writePrices, writeLongTexts, conversionCulture, gaebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, gaebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, gaebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts GAEB files to Oenorm files
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, gaebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, gaebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GaebConversionApi - factory interface
 * @export
 */
export const GaebConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GaebConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts GAEB files to Dangl.AVA projects
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, gaebFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions, removePlainTextLongTexts, removeHtmlLongTexts, gaebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts GAEB files to Excel
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, gaebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions, writePrices, writeLongTexts, conversionCulture, gaebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, gaebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, gaebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts GAEB files to Oenorm files
         * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [gaebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, gaebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, gaebFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GaebConversionApi - object-oriented interface
 * @export
 * @class GaebConversionApi
 * @extends {BaseAPI}
 */
export class GaebConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts GAEB files to Dangl.AVA projects
     * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [gaebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaebConversionApi
     */
    public gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions?: boolean, removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, gaebFile?: File, options?: AxiosRequestConfig) {
        return GaebConversionApiFp(this.configuration).gaebConversionConvertToAva(supportSkippedItemNumberLevelsInPositions, removePlainTextLongTexts, removeHtmlLongTexts, gaebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts GAEB files to Excel
     * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [gaebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaebConversionApi
     */
    public gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions?: boolean, writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, gaebFile?: File, options?: AxiosRequestConfig) {
        return GaebConversionApiFp(this.configuration).gaebConversionConvertToExcel(supportSkippedItemNumberLevelsInPositions, writePrices, writeLongTexts, conversionCulture, gaebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts GAEB files to GAEB files. Used for example when transforming or repairing GAEB files.
     * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [gaebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaebConversionApi
     */
    public gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions?: boolean, destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, gaebFile?: File, options?: AxiosRequestConfig) {
        return GaebConversionApiFp(this.configuration).gaebConversionConvertToGaeb(supportSkippedItemNumberLevelsInPositions, destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, gaebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts GAEB files to Oenorm files
     * @param {boolean} [supportSkippedItemNumberLevelsInPositions] Defaults to \&#39;false\&#39;. This controls if, when deserializing GAEB files, skipped levels in position item numbers should be supported. For example, if an ItemNumberSchema defines three levels - two group levels and one position levels - but the ItemNumber of the position is just \&#39;01.02\&#39;, then it will be displayed as \&#39;01.__.02\&#39; if this is set to true.
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [gaebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GaebConversionApi
     */
    public gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions?: boolean, destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, gaebFile?: File, options?: AxiosRequestConfig) {
        return GaebConversionApiFp(this.configuration).gaebConversionConvertToOenorm(supportSkippedItemNumberLevelsInPositions, destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, gaebFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OenormConversionApi - axios parameter creator
 * @export
 */
export const OenormConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts ÖNorm files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToAva: async (removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, oenormFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/oenorm/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (oenormFile !== undefined) { 
                localVarFormParams.append('oenormFile', oenormFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts ÖNorm files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToExcel: async (writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, oenormFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/oenorm/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (oenormFile !== undefined) { 
                localVarFormParams.append('oenormFile', oenormFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts ÖNorm files to GAEB files.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToGaeb: async (destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, oenormFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/oenorm/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (oenormFile !== undefined) { 
                localVarFormParams.append('oenormFile', oenormFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts ÖNorm files to Oenorm files.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToOenorm: async (destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, oenormFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/oenorm/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (oenormFile !== undefined) { 
                localVarFormParams.append('oenormFile', oenormFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OenormConversionApi - functional programming interface
 * @export
 */
export const OenormConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OenormConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts ÖNorm files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oenormConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, oenormFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oenormConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, oenormFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts ÖNorm files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oenormConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, oenormFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oenormConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, oenormFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts ÖNorm files to GAEB files.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oenormConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, oenormFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oenormConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, oenormFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts ÖNorm files to Oenorm files.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oenormConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, oenormFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oenormConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, oenormFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OenormConversionApi - factory interface
 * @export
 */
export const OenormConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OenormConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts ÖNorm files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, oenormFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.oenormConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, oenormFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts ÖNorm files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, oenormFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.oenormConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, oenormFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts ÖNorm files to GAEB files.
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, oenormFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.oenormConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, oenormFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts ÖNorm files to Oenorm files.
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [oenormFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oenormConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, oenormFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.oenormConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, oenormFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OenormConversionApi - object-oriented interface
 * @export
 * @class OenormConversionApi
 * @extends {BaseAPI}
 */
export class OenormConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts ÖNorm files to Dangl.AVA projects
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [oenormFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OenormConversionApi
     */
    public oenormConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, oenormFile?: File, options?: AxiosRequestConfig) {
        return OenormConversionApiFp(this.configuration).oenormConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, oenormFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts ÖNorm files to Excel
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [oenormFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OenormConversionApi
     */
    public oenormConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, oenormFile?: File, options?: AxiosRequestConfig) {
        return OenormConversionApiFp(this.configuration).oenormConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, oenormFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts ÖNorm files to GAEB files.
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [oenormFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OenormConversionApi
     */
    public oenormConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, oenormFile?: File, options?: AxiosRequestConfig) {
        return OenormConversionApiFp(this.configuration).oenormConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, oenormFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts ÖNorm files to Oenorm files.
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [oenormFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OenormConversionApi
     */
    public oenormConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, oenormFile?: File, options?: AxiosRequestConfig) {
        return OenormConversionApiFp(this.configuration).oenormConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, oenormFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RebConversionApi - axios parameter creator
 * @export
 */
export const RebConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts REB files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToAva: async (removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, rebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/reb/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (rebFile !== undefined) { 
                localVarFormParams.append('rebFile', rebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts REB files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToExcel: async (writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, rebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/reb/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (rebFile !== undefined) { 
                localVarFormParams.append('rebFile', rebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts REB files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToGaeb: async (destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, rebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/reb/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (rebFile !== undefined) { 
                localVarFormParams.append('rebFile', rebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts REB files to Oenorm
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToOenorm: async (destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, rebFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/reb/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (rebFile !== undefined) { 
                localVarFormParams.append('rebFile', rebFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RebConversionApi - functional programming interface
 * @export
 */
export const RebConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RebConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts REB files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, rebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, rebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts REB files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, rebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, rebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts REB files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, rebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, rebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts REB files to Oenorm
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rebConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, rebFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rebConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, rebFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RebConversionApi - factory interface
 * @export
 */
export const RebConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RebConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts REB files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, rebFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.rebConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, rebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts REB files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, rebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.rebConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, rebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts REB files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, rebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.rebConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, rebFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts REB files to Oenorm
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [rebFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, rebFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.rebConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, rebFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RebConversionApi - object-oriented interface
 * @export
 * @class RebConversionApi
 * @extends {BaseAPI}
 */
export class RebConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts REB files to Dangl.AVA projects
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [rebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RebConversionApi
     */
    public rebConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, rebFile?: File, options?: AxiosRequestConfig) {
        return RebConversionApiFp(this.configuration).rebConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, rebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts REB files to Excel
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [rebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RebConversionApi
     */
    public rebConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, rebFile?: File, options?: AxiosRequestConfig) {
        return RebConversionApiFp(this.configuration).rebConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, rebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts REB files to GAEB files
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [rebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RebConversionApi
     */
    public rebConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, rebFile?: File, options?: AxiosRequestConfig) {
        return RebConversionApiFp(this.configuration).rebConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, rebFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts REB files to Oenorm
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [rebFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RebConversionApi
     */
    public rebConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, rebFile?: File, options?: AxiosRequestConfig) {
        return RebConversionApiFp(this.configuration).rebConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, rebFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SiaConversionApi - axios parameter creator
 * @export
 */
export const SiaConversionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Converts SIA 451 files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToAva: async (removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, siaFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/sia/ava`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (removePlainTextLongTexts !== undefined) {
                localVarQueryParameter['RemovePlainTextLongTexts'] = removePlainTextLongTexts;
            }

            if (removeHtmlLongTexts !== undefined) {
                localVarQueryParameter['RemoveHtmlLongTexts'] = removeHtmlLongTexts;
            }


            if (siaFile !== undefined) { 
                localVarFormParams.append('siaFile', siaFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts SIA 451 files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToExcel: async (writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, siaFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/sia/excel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (writePrices !== undefined) {
                localVarQueryParameter['WritePrices'] = writePrices;
            }

            if (writeLongTexts !== undefined) {
                localVarQueryParameter['WriteLongTexts'] = writeLongTexts;
            }

            if (conversionCulture !== undefined) {
                localVarQueryParameter['ConversionCulture'] = conversionCulture;
            }


            if (siaFile !== undefined) { 
                localVarFormParams.append('siaFile', siaFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts SIA 451 files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToGaeb: async (destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, siaFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/sia/gaeb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationGaebType !== undefined) {
                localVarQueryParameter['DestinationGaebType'] = destinationGaebType;
            }

            if (targetExchangePhaseTransform !== undefined) {
                localVarQueryParameter['TargetExchangePhaseTransform'] = targetExchangePhaseTransform;
            }

            if (enforceStrictOfferPhaseLongTextOutput !== undefined) {
                localVarQueryParameter['EnforceStrictOfferPhaseLongTextOutput'] = enforceStrictOfferPhaseLongTextOutput;
            }

            if (exportQuantityDetermination !== undefined) {
                localVarQueryParameter['ExportQuantityDetermination'] = exportQuantityDetermination;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }

            if (forceIncludeDescriptions !== undefined) {
                localVarQueryParameter['ForceIncludeDescriptions'] = forceIncludeDescriptions;
            }

            if (treatNullItemNumberSchemaAsInvalid !== undefined) {
                localVarQueryParameter['TreatNullItemNumberSchemaAsInvalid'] = treatNullItemNumberSchemaAsInvalid;
            }


            if (siaFile !== undefined) { 
                localVarFormParams.append('siaFile', siaFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Converts SIA 451 files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToOenorm: async (destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, siaFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/conversion/sia/oenorm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (destinationOenormType !== undefined) {
                localVarQueryParameter['DestinationOenormType'] = destinationOenormType;
            }

            if (tryRepairProjectStructure !== undefined) {
                localVarQueryParameter['TryRepairProjectStructure'] = tryRepairProjectStructure;
            }

            if (skipTryEnforceSchemaCompliantXmlOutput !== undefined) {
                localVarQueryParameter['SkipTryEnforceSchemaCompliantXmlOutput'] = skipTryEnforceSchemaCompliantXmlOutput;
            }

            if (removeUnprintableCharactersFromTexts !== undefined) {
                localVarQueryParameter['RemoveUnprintableCharactersFromTexts'] = removeUnprintableCharactersFromTexts;
            }


            if (siaFile !== undefined) { 
                localVarFormParams.append('siaFile', siaFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiaConversionApi - functional programming interface
 * @export
 */
export const SiaConversionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiaConversionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Converts SIA 451 files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siaConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, siaFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siaConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, siaFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts SIA 451 files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siaConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, siaFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siaConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, siaFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts SIA 451 files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siaConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, siaFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siaConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, siaFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Converts SIA 451 files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async siaConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, siaFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.siaConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, siaFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SiaConversionApi - factory interface
 * @export
 */
export const SiaConversionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiaConversionApiFp(configuration)
    return {
        /**
         * 
         * @summary Converts SIA 451 files to Dangl.AVA projects
         * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
         * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, siaFile?: File, options?: any): AxiosPromise<ProjectDto> {
            return localVarFp.siaConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, siaFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts SIA 451 files to Excel
         * @param {boolean} [writePrices] Defaults to true
         * @param {boolean} [writeLongTexts] Defaults to true
         * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, siaFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.siaConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, siaFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts SIA 451 files to GAEB files
         * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
         * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
         * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
         * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
         * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, siaFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.siaConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, siaFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Converts SIA 451 files to Oenorm files
         * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
         * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
         * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
         * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
         * @param {File} [siaFile] The input file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        siaConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, siaFile?: File, options?: any): AxiosPromise<File> {
            return localVarFp.siaConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, siaFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiaConversionApi - object-oriented interface
 * @export
 * @class SiaConversionApi
 * @extends {BaseAPI}
 */
export class SiaConversionApi extends BaseAPI {
    /**
     * 
     * @summary Converts SIA 451 files to Dangl.AVA projects
     * @param {boolean} [removePlainTextLongTexts] If set to true, plain text long texts will be removed from the output to reduce response sizes
     * @param {boolean} [removeHtmlLongTexts] If set to true, html long texts will be removed from the output to reduce response sizes
     * @param {File} [siaFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiaConversionApi
     */
    public siaConversionConvertToAva(removePlainTextLongTexts?: boolean, removeHtmlLongTexts?: boolean, siaFile?: File, options?: AxiosRequestConfig) {
        return SiaConversionApiFp(this.configuration).siaConversionConvertToAva(removePlainTextLongTexts, removeHtmlLongTexts, siaFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts SIA 451 files to Excel
     * @param {boolean} [writePrices] Defaults to true
     * @param {boolean} [writeLongTexts] Defaults to true
     * @param {string} [conversionCulture] The culture that should be used for the conversion process, to have localized Excel files
     * @param {File} [siaFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiaConversionApi
     */
    public siaConversionConvertToExcel(writePrices?: boolean, writeLongTexts?: boolean, conversionCulture?: string, siaFile?: File, options?: AxiosRequestConfig) {
        return SiaConversionApiFp(this.configuration).siaConversionConvertToExcel(writePrices, writeLongTexts, conversionCulture, siaFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts SIA 451 files to GAEB files
     * @param {'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce'} [destinationGaebType] Defaults to GAEB XML V3.2
     * @param {'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer'} [targetExchangePhaseTransform] Defaults to none, meaning no transformation will be done
     * @param {boolean} [enforceStrictOfferPhaseLongTextOutput] Defaults to false. If this is enabled, exported long texts to GAEB XML that use text additions will be strictly schema compliant. If this is not enabled, any text that is marked to contain a text addition is exported in full to ensure that incorrectly used text additions are still preserved in the export.
     * @param {boolean} [exportQuantityDetermination] Defaults to false. If this is enabled, quantities are exported in detail in GAEB XML targets via the \&#39;QtyDeterm\&#39; (Quantity Determination, or Quantity Take Off) fields. To control this, you can set custom quantity calculations in the \&#39;QuantityComponents\&#39; property of positions. Please see the entry for \&#39;Quantity Determination\&#39; in the Dangl.AVA HowTo documentation section. Please be advised that enabling this might export data that was not intended to be exported, like internal quantity calculation details, depending on what data you put in the \&#39;QuantityComponents\&#39; property.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {boolean} [forceIncludeDescriptions] If this is enabled, all description elements like texts and execution descriptions will be output to the result. This is mostly only applicable to GAEB exports to phase 84 - Offer, which does typically not include descriptions.
     * @param {boolean} [treatNullItemNumberSchemaAsInvalid] When exporting to GAEB, an item number schema is usually required. AVACloud will try to fix invalid item number schemas. With this setting, you can also tell AVACloud to treat a null value as invalid. Otherwise, null schemas will simply be ignored and not lead to any schema being generated. It is recommended to enable this option, but it is disabled by default for compatibility reasons.
     * @param {File} [siaFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiaConversionApi
     */
    public siaConversionConvertToGaeb(destinationGaebType?: 'Gaeb90' | 'Gaeb2000' | 'Gaeb2000Commerce' | 'GaebXml_V3_1' | 'GaebXml_V3_2' | 'GaebXml_V3_2_Commerce' | 'GaebXml_V3_3' | 'GaebXml_V3_3_Commerce' | 'GaebXml_V3_3_2019' | 'GaebXml_V3_3_2019_Commerce', targetExchangePhaseTransform?: 'None' | 'Base' | 'OfferRequest' | 'Offer' | 'Grant' | 'CostEstimate' | 'SideOffer', enforceStrictOfferPhaseLongTextOutput?: boolean, exportQuantityDetermination?: boolean, removeUnprintableCharactersFromTexts?: boolean, forceIncludeDescriptions?: boolean, treatNullItemNumberSchemaAsInvalid?: boolean, siaFile?: File, options?: AxiosRequestConfig) {
        return SiaConversionApiFp(this.configuration).siaConversionConvertToGaeb(destinationGaebType, targetExchangePhaseTransform, enforceStrictOfferPhaseLongTextOutput, exportQuantityDetermination, removeUnprintableCharactersFromTexts, forceIncludeDescriptions, treatNullItemNumberSchemaAsInvalid, siaFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Converts SIA 451 files to Oenorm files
     * @param {'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021'} [destinationOenormType] Defaults to Lv2015
     * @param {boolean} [tryRepairProjectStructure] Defaults to false. If this is enabled, the converter will try to ensure that the project structure can be mapped to Oenorm. It might introduce additional group levels to ensure a compatible target
     * @param {boolean} [skipTryEnforceSchemaCompliantXmlOutput] If this option is enabled, AVACloud will not attempt to force a schema-compliant Xml output for ÖNorm targets that are Xml based. By default, AVACloud will try to add required fields, even if no data is present, with sensible defaults. This behavior can be disabled with this option.
     * @param {boolean} [removeUnprintableCharactersFromTexts] If this is enabled, unprintable characters are removed from text elements. Otherwise, the conversion might fail in case some text content contains characters that are not allowed in XML output formats. Defaults to true.
     * @param {File} [siaFile] The input file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiaConversionApi
     */
    public siaConversionConvertToOenorm(destinationOenormType?: 'Lv2015' | 'Lb2015' | 'B2063' | 'Lv2009' | 'Lb2009' | 'Lv2021' | 'Lb2021', tryRepairProjectStructure?: boolean, skipTryEnforceSchemaCompliantXmlOutput?: boolean, removeUnprintableCharactersFromTexts?: boolean, siaFile?: File, options?: AxiosRequestConfig) {
        return SiaConversionApiFp(this.configuration).siaConversionConvertToOenorm(destinationOenormType, tryRepairProjectStructure, skipTryEnforceSchemaCompliantXmlOutput, removeUnprintableCharactersFromTexts, siaFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Reports the health status of the AVACloud API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGetStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Reports the health status of the AVACloud API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGetStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGetStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Reports the health status of the AVACloud API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGetStatus(options?: any): AxiosPromise<GetStatus> {
            return localVarFp.statusGetStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Reports the health status of the AVACloud API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGetStatus(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGetStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidationApi - axios parameter creator
 * @export
 */
export const ValidationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
         * @param {'Gaeb' | 'Oenorm'} [fileValidationSourceType] You need to indicate which type of file is being provided, there is no auto detection mechanism
         * @param {File} [avaFile] The file to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationValidateFile: async (fileValidationSourceType?: 'Gaeb' | 'Oenorm', avaFile?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/validation/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (fileValidationSourceType !== undefined) {
                localVarQueryParameter['fileValidationSourceType'] = fileValidationSourceType;
            }


            if (avaFile !== undefined) { 
                localVarFormParams.append('avaFile', avaFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
         * @param {PostAvaProjectValidationSourceOptions} avaProjectValidationSourceOptions The options used for the validation operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationValidateProject: async (avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avaProjectValidationSourceOptions' is not null or undefined
            assertParamExists('validationValidateProject', 'avaProjectValidationSourceOptions', avaProjectValidationSourceOptions)
            const localVarPath = `/validation/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(avaProjectValidationSourceOptions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidationApi - functional programming interface
 * @export
 */
export const ValidationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
         * @param {'Gaeb' | 'Oenorm'} [fileValidationSourceType] You need to indicate which type of file is being provided, there is no auto detection mechanism
         * @param {File} [avaFile] The file to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationValidateFile(fileValidationSourceType?: 'Gaeb' | 'Oenorm', avaFile?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationValidateFile(fileValidationSourceType, avaFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
         * @param {PostAvaProjectValidationSourceOptions} avaProjectValidationSourceOptions The options used for the validation operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validationValidateProject(avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validationValidateProject(avaProjectValidationSourceOptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidationApi - factory interface
 * @export
 */
export const ValidationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidationApiFp(configuration)
    return {
        /**
         * 
         * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
         * @param {'Gaeb' | 'Oenorm'} [fileValidationSourceType] You need to indicate which type of file is being provided, there is no auto detection mechanism
         * @param {File} [avaFile] The file to validate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationValidateFile(fileValidationSourceType?: 'Gaeb' | 'Oenorm', avaFile?: File, options?: any): AxiosPromise<ValidationResult> {
            return localVarFp.validationValidateFile(fileValidationSourceType, avaFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
         * @param {PostAvaProjectValidationSourceOptions} avaProjectValidationSourceOptions The options used for the validation operation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validationValidateProject(avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options?: any): AxiosPromise<ValidationResult> {
            return localVarFp.validationValidateProject(avaProjectValidationSourceOptions, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidationApi - object-oriented interface
 * @export
 * @class ValidationApi
 * @extends {BaseAPI}
 */
export class ValidationApi extends BaseAPI {
    /**
     * 
     * @summary This endpoint validates AVA files, typically GAEB or ÖNorm. The type of file needs to be provided as a query parameter, since there is no auto detection of the uploaded file type.
     * @param {'Gaeb' | 'Oenorm'} [fileValidationSourceType] You need to indicate which type of file is being provided, there is no auto detection mechanism
     * @param {File} [avaFile] The file to validate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationApi
     */
    public validationValidateFile(fileValidationSourceType?: 'Gaeb' | 'Oenorm', avaFile?: File, options?: AxiosRequestConfig) {
        return ValidationApiFp(this.configuration).validationValidateFile(fileValidationSourceType, avaFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary This endpoint provides a full validation of a provided ProjectDto. It will take the given exchange phase into account and do some general project validation. Optionally, a conversion to a desired target can also be done, in which case the target file will also be validated.
     * @param {PostAvaProjectValidationSourceOptions} avaProjectValidationSourceOptions The options used for the validation operation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidationApi
     */
    public validationValidateProject(avaProjectValidationSourceOptions: PostAvaProjectValidationSourceOptions, options?: AxiosRequestConfig) {
        return ValidationApiFp(this.configuration).validationValidateProject(avaProjectValidationSourceOptions, options).then((request) => request(this.axios, this.basePath));
    }
}


