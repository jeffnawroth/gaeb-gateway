/* tslint:disable */
/* eslint-disable */
/**
 * API 0.1.1-beta0219
 * Dangl.OpenCDE API Specification
 *
 * The version of the OpenAPI document: 0.1.1-beta0219
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ApiError
     */
    'errors'?: { [key: string]: Array<string>; } | null;
}
/**
 * 
 * @export
 * @interface AuthGet
 */
export interface AuthGet {
    /**
     * 
     * @type {string}
     * @memberof AuthGet
     */
    'oauth2_auth_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthGet
     */
    'oauth2_token_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthGet
     */
    'oauth2_dynamic_client_reg_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AuthGet
     */
    'http_basic_supported'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthGet
     */
    'supported_oauth2_flows': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AuthGet
     */
    'oauth2_required_scopes'?: string | null;
}
/**
 * 
 * @export
 * @interface CallbackLink
 */
export interface CallbackLink {
    /**
     * 
     * @type {string}
     * @memberof CallbackLink
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof CallbackLink
     */
    'expires_in': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DataTypeEnum = {
    String: 'string',
    Boolean: 'boolean',
    DateTime: 'date-time',
    Date: 'date',
    Integer32: 'integer32',
    Integer64: 'integer64',
    Number: 'number',
    Url: 'url'
} as const;

export type DataTypeEnum = typeof DataTypeEnum[keyof typeof DataTypeEnum];


/**
 * 
 * @export
 * @interface DocumentContentPreparationPost
 */
export interface DocumentContentPreparationPost {
    /**
     * 
     * @type {string}
     * @memberof DocumentContentPreparationPost
     */
    'fileName': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentContentPreparationPost
     */
    'contentType': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentContentPreparationPost
     */
    'sizeInBytes': number;
}
/**
 * 
 * @export
 * @interface DocumentContentSasUploadResultGet
 */
export interface DocumentContentSasUploadResultGet {
    /**
     * 
     * @type {SasUploadLink}
     * @memberof DocumentContentSasUploadResultGet
     */
    'sasUploadLink': SasUploadLink;
    /**
     * 
     * @type {Array<DocumentContentSasUploadResultHeaderGet>}
     * @memberof DocumentContentSasUploadResultGet
     */
    'customHeaders': Array<DocumentContentSasUploadResultHeaderGet>;
}
/**
 * 
 * @export
 * @interface DocumentContentSasUploadResultHeaderGet
 */
export interface DocumentContentSasUploadResultHeaderGet {
    /**
     * 
     * @type {string}
     * @memberof DocumentContentSasUploadResultHeaderGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentContentSasUploadResultHeaderGet
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface DocumentDiscoverySessionInitialization
 */
export interface DocumentDiscoverySessionInitialization {
    /**
     * 
     * @type {string}
     * @memberof DocumentDiscoverySessionInitialization
     */
    'select_documents_url': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentDiscoverySessionInitialization
     */
    'expires_in': number;
}
/**
 * 
 * @export
 * @interface DocumentGet
 */
export interface DocumentGet {
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'projectId': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'createdAtUtc': string;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentGet
     */
    'contentAvailable': boolean;
    /**
     * 
     * @type {string}
     * @memberof DocumentGet
     */
    'fileName'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentGet
     */
    'fileSizeInBytes'?: number | null;
}
/**
 * 
 * @export
 * @interface DocumentMetadata
 */
export interface DocumentMetadata {
    /**
     * 
     * @type {Array<DocumentMetadataEntry>}
     * @memberof DocumentMetadata
     */
    'metadata': Array<DocumentMetadataEntry>;
}
/**
 * 
 * @export
 * @interface DocumentMetadataEntry
 */
export interface DocumentMetadataEntry {
    /**
     * 
     * @type {string}
     * @memberof DocumentMetadataEntry
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentMetadataEntry
     */
    'value': Array<string>;
    /**
     * 
     * @type {DataTypeEnum}
     * @memberof DocumentMetadataEntry
     */
    'data_type': DataTypeEnum;
}


/**
 * 
 * @export
 * @interface DocumentPost
 */
export interface DocumentPost {
    /**
     * 
     * @type {string}
     * @memberof DocumentPost
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentPost
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface DocumentQuery
 */
export interface DocumentQuery {
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentQuery
     */
    'document_ids': Array<string>;
}
/**
 * 
 * @export
 * @interface DocumentSelectionGet
 */
export interface DocumentSelectionGet {
    /**
     * 
     * @type {string}
     * @memberof DocumentSelectionGet
     */
    'callbackUrl': string;
}
/**
 * 
 * @export
 * @interface DocumentSelectionPost
 */
export interface DocumentSelectionPost {
    /**
     * 
     * @type {string}
     * @memberof DocumentSelectionPost
     */
    'documentId': string;
}
/**
 * 
 * @export
 * @interface DocumentToUpload
 */
export interface DocumentToUpload {
    /**
     * 
     * @type {string}
     * @memberof DocumentToUpload
     */
    'session_file_id': string;
    /**
     * 
     * @type {Array<UploadFilePartInstruction>}
     * @memberof DocumentToUpload
     */
    'upload_file_parts': Array<UploadFilePartInstruction>;
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentToUpload
     */
    'upload_completion': LinkData;
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentToUpload
     */
    'upload_cancellation': LinkData;
}
/**
 * 
 * @export
 * @interface DocumentUploadSessionInitialization
 */
export interface DocumentUploadSessionInitialization {
    /**
     * 
     * @type {string}
     * @memberof DocumentUploadSessionInitialization
     */
    'upload_ui_url': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentUploadSessionInitialization
     */
    'expires_in': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentUploadSessionInitialization
     */
    'max_size_in_bytes': number;
}
/**
 * 
 * @export
 * @interface DocumentVersion
 */
export interface DocumentVersion {
    /**
     * 
     * @type {DocumentVersionLinks}
     * @memberof DocumentVersion
     */
    'links': DocumentVersionLinks;
    /**
     * 
     * @type {string}
     * @memberof DocumentVersion
     */
    'version_number': string;
    /**
     * 
     * @type {number}
     * @memberof DocumentVersion
     */
    'version_index': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentVersion
     */
    'creation_date': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentVersion
     */
    'title': string;
    /**
     * 
     * @type {FileDescription}
     * @memberof DocumentVersion
     */
    'file_description': FileDescription;
    /**
     * 
     * @type {string}
     * @memberof DocumentVersion
     */
    'document_id': string;
}
/**
 * 
 * @export
 * @interface DocumentVersionLinks
 */
export interface DocumentVersionLinks {
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentVersionLinks
     */
    'document_version': LinkData;
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentVersionLinks
     */
    'document_version_metadata': LinkData;
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentVersionLinks
     */
    'document_version_download': LinkData;
    /**
     * 
     * @type {LinkData}
     * @memberof DocumentVersionLinks
     */
    'document_versions': LinkData;
    /**
     * 
     * @type {DocumentVersionLinksDocumentDetails}
     * @memberof DocumentVersionLinks
     */
    'document_details'?: DocumentVersionLinksDocumentDetails | null;
}
/**
 * @type DocumentVersionLinksDocumentDetails
 * @export
 */
export type DocumentVersionLinksDocumentDetails = LinkData;

/**
 * 
 * @export
 * @interface DocumentVersions
 */
export interface DocumentVersions {
    /**
     * 
     * @type {Array<DocumentVersion>}
     * @memberof DocumentVersions
     */
    'documents': Array<DocumentVersion>;
}
/**
 * 
 * @export
 * @interface DocumentsToUpload
 */
export interface DocumentsToUpload {
    /**
     * 
     * @type {string}
     * @memberof DocumentsToUpload
     */
    'server_context'?: string | null;
    /**
     * 
     * @type {Array<DocumentToUpload>}
     * @memberof DocumentsToUpload
     */
    'documents_to_upload': Array<DocumentToUpload>;
}
/**
 * 
 * @export
 * @interface FileDescription
 */
export interface FileDescription {
    /**
     * 
     * @type {string}
     * @memberof FileDescription
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof FileDescription
     */
    'size_in_bytes': number;
}
/**
 * 
 * @export
 * @interface FileToUpload
 */
export interface FileToUpload {
    /**
     * 
     * @type {string}
     * @memberof FileToUpload
     */
    'file_name': string;
    /**
     * 
     * @type {string}
     * @memberof FileToUpload
     */
    'session_file_id': string;
    /**
     * 
     * @type {string}
     * @memberof FileToUpload
     */
    'document_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ForgotPasswordPost
 */
export interface ForgotPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordPost
     */
    'identifier': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ForgotPasswordPost
     */
    'preferredLanguages'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface FrontendConfigGet
 */
export interface FrontendConfigGet {
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'danglIconsBaseUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'danglIdentityUrl': string;
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'applicationInsightsInstrumentationKey'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'environment': string;
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'danglIdentityClientId': string;
    /**
     * 
     * @type {string}
     * @memberof FrontendConfigGet
     */
    'requiredScope': string;
}
/**
 * 
 * @export
 * @interface HeaderValue
 */
export interface HeaderValue {
    /**
     * 
     * @type {string}
     * @memberof HeaderValue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HeaderValue
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface Headers
 */
export interface Headers {
    /**
     * 
     * @type {Array<HeaderValue>}
     * @memberof Headers
     */
    'values': Array<HeaderValue>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HttpMethodEnum = {
    Post: 'POST',
    Put: 'PUT'
} as const;

export type HttpMethodEnum = typeof HttpMethodEnum[keyof typeof HttpMethodEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const HttpStatusCode = {
    Continue: 'Continue',
    SwitchingProtocols: 'SwitchingProtocols',
    Processing: 'Processing',
    EarlyHints: 'EarlyHints',
    Ok: 'OK',
    Created: 'Created',
    Accepted: 'Accepted',
    NonAuthoritativeInformation: 'NonAuthoritativeInformation',
    NoContent: 'NoContent',
    ResetContent: 'ResetContent',
    PartialContent: 'PartialContent',
    MultiStatus: 'MultiStatus',
    AlreadyReported: 'AlreadyReported',
    ImUsed: 'IMUsed',
    Ambiguous: 'Ambiguous',
    Moved: 'Moved',
    Redirect: 'Redirect',
    RedirectMethod: 'RedirectMethod',
    NotModified: 'NotModified',
    UseProxy: 'UseProxy',
    Unused: 'Unused',
    TemporaryRedirect: 'TemporaryRedirect',
    PermanentRedirect: 'PermanentRedirect',
    BadRequest: 'BadRequest',
    Unauthorized: 'Unauthorized',
    PaymentRequired: 'PaymentRequired',
    Forbidden: 'Forbidden',
    NotFound: 'NotFound',
    MethodNotAllowed: 'MethodNotAllowed',
    NotAcceptable: 'NotAcceptable',
    ProxyAuthenticationRequired: 'ProxyAuthenticationRequired',
    RequestTimeout: 'RequestTimeout',
    Conflict: 'Conflict',
    Gone: 'Gone',
    LengthRequired: 'LengthRequired',
    PreconditionFailed: 'PreconditionFailed',
    RequestEntityTooLarge: 'RequestEntityTooLarge',
    RequestUriTooLong: 'RequestUriTooLong',
    UnsupportedMediaType: 'UnsupportedMediaType',
    RequestedRangeNotSatisfiable: 'RequestedRangeNotSatisfiable',
    ExpectationFailed: 'ExpectationFailed',
    MisdirectedRequest: 'MisdirectedRequest',
    UnprocessableEntity: 'UnprocessableEntity',
    Locked: 'Locked',
    FailedDependency: 'FailedDependency',
    UpgradeRequired: 'UpgradeRequired',
    PreconditionRequired: 'PreconditionRequired',
    TooManyRequests: 'TooManyRequests',
    RequestHeaderFieldsTooLarge: 'RequestHeaderFieldsTooLarge',
    UnavailableForLegalReasons: 'UnavailableForLegalReasons',
    InternalServerError: 'InternalServerError',
    NotImplemented: 'NotImplemented',
    BadGateway: 'BadGateway',
    ServiceUnavailable: 'ServiceUnavailable',
    GatewayTimeout: 'GatewayTimeout',
    HttpVersionNotSupported: 'HttpVersionNotSupported',
    VariantAlsoNegotiates: 'VariantAlsoNegotiates',
    InsufficientStorage: 'InsufficientStorage',
    LoopDetected: 'LoopDetected',
    NotExtended: 'NotExtended',
    NetworkAuthenticationRequired: 'NetworkAuthenticationRequired'
} as const;

export type HttpStatusCode = typeof HttpStatusCode[keyof typeof HttpStatusCode];


/**
 * 
 * @export
 * @interface LinkData
 */
export interface LinkData {
    /**
     * 
     * @type {string}
     * @memberof LinkData
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface LoginPost
 */
export interface LoginPost {
    /**
     * 
     * @type {string}
     * @memberof LoginPost
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPost
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof LoginPost
     */
    'staySignedIn'?: boolean;
}
/**
 * 
 * @export
 * @interface MultipartFormData
 */
export interface MultipartFormData {
    /**
     * 
     * @type {string}
     * @memberof MultipartFormData
     */
    'prefix': string;
    /**
     * 
     * @type {string}
     * @memberof MultipartFormData
     */
    'suffix': string;
}
/**
 * 
 * @export
 * @interface PaginationResultOfDocumentGet
 */
export interface PaginationResultOfDocumentGet {
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfDocumentGet
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfDocumentGet
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfDocumentGet
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<DocumentGet>}
     * @memberof PaginationResultOfDocumentGet
     */
    'data'?: Array<DocumentGet> | null;
}
/**
 * 
 * @export
 * @interface PaginationResultOfProjectGet
 */
export interface PaginationResultOfProjectGet {
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfProjectGet
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfProjectGet
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationResultOfProjectGet
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<ProjectGet>}
     * @memberof PaginationResultOfProjectGet
     */
    'data'?: Array<ProjectGet> | null;
}
/**
 * 
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProblemDetails
     */
    'extensions'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ProjectGet
 */
export interface ProjectGet {
    /**
     * 
     * @type {string}
     * @memberof ProjectGet
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectGet
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectGet
     */
    'identiconId': string;
}
/**
 * 
 * @export
 * @interface ProjectPost
 */
export interface ProjectPost {
    /**
     * 
     * @type {string}
     * @memberof ProjectPost
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectPost
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface RegisterPost
 */
export interface RegisterPost {
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPost
     */
    'password': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterPost
     */
    'preferredLanguages'?: Array<string> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ResponseErrorType = {
    None: 'None',
    Protocol: 'Protocol',
    Http: 'Http',
    Exception: 'Exception',
    PolicyViolation: 'PolicyViolation'
} as const;

export type ResponseErrorType = typeof ResponseErrorType[keyof typeof ResponseErrorType];


/**
 * 
 * @export
 * @interface SasUploadLink
 */
export interface SasUploadLink {
    /**
     * 
     * @type {string}
     * @memberof SasUploadLink
     */
    'uploadLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SasUploadLink
     */
    'validUntil'?: string;
}
/**
 * 
 * @export
 * @interface SelectDocuments
 */
export interface SelectDocuments {
    /**
     * 
     * @type {CallbackLink}
     * @memberof SelectDocuments
     */
    'callback': CallbackLink;
    /**
     * 
     * @type {string}
     * @memberof SelectDocuments
     */
    'server_context'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof SelectDocuments
     */
    'supported_file_extensions'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface SelectedDocuments
 */
export interface SelectedDocuments {
    /**
     * 
     * @type {string}
     * @memberof SelectedDocuments
     */
    'server_context'?: string | null;
    /**
     * 
     * @type {Array<DocumentVersion>}
     * @memberof SelectedDocuments
     */
    'documents': Array<DocumentVersion>;
}
/**
 * 
 * @export
 * @interface SimpleAuthToken
 */
export interface SimpleAuthToken {
    /**
     * 
     * @type {string}
     * @memberof SimpleAuthToken
     */
    'jwt': string;
    /**
     * 
     * @type {number}
     * @memberof SimpleAuthToken
     */
    'expiresAt': number;
}
/**
 * 
 * @export
 * @interface StatusGet
 */
export interface StatusGet {
    /**
     * 
     * @type {boolean}
     * @memberof StatusGet
     */
    'isHealthy': boolean;
    /**
     * 
     * @type {string}
     * @memberof StatusGet
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof StatusGet
     */
    'informationalVersion': string;
    /**
     * 
     * @type {string}
     * @memberof StatusGet
     */
    'environment': string;
}
/**
 * 
 * @export
 * @interface TokenLoginPost
 */
export interface TokenLoginPost {
    /**
     * 
     * @type {string}
     * @memberof TokenLoginPost
     */
    'identifier': string;
    /**
     * 
     * @type {string}
     * @memberof TokenLoginPost
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface TokenRefreshPost
 */
export interface TokenRefreshPost {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshPost
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface TokenResponseGet
 */
export interface TokenResponseGet {
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'accessToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'error'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'errorDescription'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TokenResponseGet
     */
    'expiresIn'?: number;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'httpErrorReason'?: string | null;
    /**
     * 
     * @type {HttpStatusCode}
     * @memberof TokenResponseGet
     */
    'httpStatusCode'?: HttpStatusCode;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'identityToken'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TokenResponseGet
     */
    'isError'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'refreshToken'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TokenResponseGet
     */
    'tokenType'?: string | null;
    /**
     * 
     * @type {ResponseErrorType}
     * @memberof TokenResponseGet
     */
    'errorType'?: ResponseErrorType;
}


/**
 * 
 * @export
 * @interface UploadDocuments
 */
export interface UploadDocuments {
    /**
     * 
     * @type {CallbackLink}
     * @memberof UploadDocuments
     */
    'callback': CallbackLink;
    /**
     * 
     * @type {string}
     * @memberof UploadDocuments
     */
    'server_context'?: string | null;
    /**
     * 
     * @type {Array<FileToUpload>}
     * @memberof UploadDocuments
     */
    'files': Array<FileToUpload>;
}
/**
 * 
 * @export
 * @interface UploadFileDetail
 */
export interface UploadFileDetail {
    /**
     * 
     * @type {number}
     * @memberof UploadFileDetail
     */
    'size_in_bytes': number;
    /**
     * 
     * @type {string}
     * @memberof UploadFileDetail
     */
    'session_file_id': string;
}
/**
 * 
 * @export
 * @interface UploadFileDetails
 */
export interface UploadFileDetails {
    /**
     * 
     * @type {Array<UploadFileDetail>}
     * @memberof UploadFileDetails
     */
    'files': Array<UploadFileDetail>;
}
/**
 * 
 * @export
 * @interface UploadFilePartInstruction
 */
export interface UploadFilePartInstruction {
    /**
     * 
     * @type {string}
     * @memberof UploadFilePartInstruction
     */
    'url': string;
    /**
     * 
     * @type {HttpMethodEnum}
     * @memberof UploadFilePartInstruction
     */
    'http_method': HttpMethodEnum;
    /**
     * 
     * @type {UploadFilePartInstructionAdditionalHeaders}
     * @memberof UploadFilePartInstruction
     */
    'additional_headers'?: UploadFilePartInstructionAdditionalHeaders | null;
    /**
     * 
     * @type {boolean}
     * @memberof UploadFilePartInstruction
     */
    'include_authorization'?: boolean;
    /**
     * 
     * @type {UploadFilePartInstructionMultipartFormData}
     * @memberof UploadFilePartInstruction
     */
    'multipart_form_data'?: UploadFilePartInstructionMultipartFormData | null;
    /**
     * 
     * @type {number}
     * @memberof UploadFilePartInstruction
     */
    'content_range_start': number;
    /**
     * 
     * @type {number}
     * @memberof UploadFilePartInstruction
     */
    'content_range_end': number;
}


/**
 * @type UploadFilePartInstructionAdditionalHeaders
 * @export
 */
export type UploadFilePartInstructionAdditionalHeaders = Headers;

/**
 * @type UploadFilePartInstructionMultipartFormData
 * @export
 */
export type UploadFilePartInstructionMultipartFormData = MultipartFormData;

/**
 * 
 * @export
 * @interface UploadSessionProjectAssignmentPost
 */
export interface UploadSessionProjectAssignmentPost {
    /**
     * 
     * @type {string}
     * @memberof UploadSessionProjectAssignmentPost
     */
    'projectId': string;
}
/**
 * 
 * @export
 * @interface UploadSessionProjectAssignmentResultGet
 */
export interface UploadSessionProjectAssignmentResultGet {
    /**
     * 
     * @type {string}
     * @memberof UploadSessionProjectAssignmentResultGet
     */
    'clientCallbackUrl': string;
}
/**
 * 
 * @export
 * @interface UserGet
 */
export interface UserGet {
    /**
     * 
     * @type {string}
     * @memberof UserGet
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserGet
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface VersionGet
 */
export interface VersionGet {
    /**
     * 
     * @type {string}
     * @memberof VersionGet
     */
    'api_id': string;
    /**
     * 
     * @type {string}
     * @memberof VersionGet
     */
    'version_id': string;
    /**
     * 
     * @type {string}
     * @memberof VersionGet
     */
    'detailed_version'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VersionGet
     */
    'api_base_url'?: string | null;
}
/**
 * 
 * @export
 * @interface VersionsGet
 */
export interface VersionsGet {
    /**
     * 
     * @type {Array<VersionGet>}
     * @memberof VersionsGet
     */
    'versions': Array<VersionGet>;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationGetAuthenticationMetadata: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/foundation/1.0/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticationGetAuthenticationMetadata(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticationGetAuthenticationMetadata(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticationGetAuthenticationMetadata(options?: any): AxiosPromise<AuthGet> {
            return localVarFp.authenticationGetAuthenticationMetadata(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticationGetAuthenticationMetadata(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticationGetAuthenticationMetadata(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrentUserApi - axios parameter creator
 * @export
 */
export const CurrentUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGetCurrentUserData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/foundation/1.0/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrentUserApi - functional programming interface
 * @export
 */
export const CurrentUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrentUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentUserGetCurrentUserData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentUserGetCurrentUserData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrentUserApi - factory interface
 * @export
 */
export const CurrentUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrentUserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentUserGetCurrentUserData(options?: any): AxiosPromise<UserGet> {
            return localVarFp.currentUserGetCurrentUserData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrentUserApi - object-oriented interface
 * @export
 * @class CurrentUserApi
 * @extends {BaseAPI}
 */
export class CurrentUserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public currentUserGetCurrentUserData(options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).currentUserGetCurrentUserData(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DanglIdentityApi - axios parameter creator
 * @export
 */
export const DanglIdentityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TokenLoginPost} tokenLoginPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginAndReturnToken: async (tokenLoginPost: TokenLoginPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenLoginPost' is not null or undefined
            assertParamExists('danglIdentityLoginAndReturnToken', 'tokenLoginPost', tokenLoginPost)
            const localVarPath = `/identity/token-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenLoginPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginPost} loginPost 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginWithCookie: async (loginPost: LoginPost, redirectUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginPost' is not null or undefined
            assertParamExists('danglIdentityLoginWithCookie', 'loginPost', loginPost)
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenRefreshPost} tokenRefreshPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRefreshToken: async (tokenRefreshPost: TokenRefreshPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefreshPost' is not null or undefined
            assertParamExists('danglIdentityRefreshToken', 'tokenRefreshPost', tokenRefreshPost)
            const localVarPath = `/identity/token-refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterPost} registerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRegister: async (registerPost: RegisterPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPost' is not null or undefined
            assertParamExists('danglIdentityRegister', 'registerPost', registerPost)
            const localVarPath = `/identity/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRequestPasswordReset: async (forgotPasswordPost: ForgotPasswordPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordPost' is not null or undefined
            assertParamExists('danglIdentityRequestPasswordReset', 'forgotPasswordPost', forgotPasswordPost)
            const localVarPath = `/identity/password-forgotten`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentitySignOutWithSignInManager: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/identity/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DanglIdentityApi - functional programming interface
 * @export
 */
export const DanglIdentityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DanglIdentityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TokenLoginPost} tokenLoginPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityLoginAndReturnToken(tokenLoginPost: TokenLoginPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityLoginAndReturnToken(tokenLoginPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginPost} loginPost 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityLoginWithCookie(loginPost: LoginPost, redirectUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityLoginWithCookie(loginPost, redirectUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TokenRefreshPost} tokenRefreshPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRefreshToken(tokenRefreshPost: TokenRefreshPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponseGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRefreshToken(tokenRefreshPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RegisterPost} registerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRegister(registerPost: RegisterPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRegister(registerPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentityRequestPasswordReset(forgotPasswordPost: ForgotPasswordPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentityRequestPasswordReset(forgotPasswordPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async danglIdentitySignOutWithSignInManager(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.danglIdentitySignOutWithSignInManager(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DanglIdentityApi - factory interface
 * @export
 */
export const DanglIdentityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DanglIdentityApiFp(configuration)
    return {
        /**
         * 
         * @param {TokenLoginPost} tokenLoginPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginAndReturnToken(tokenLoginPost: TokenLoginPost, options?: any): AxiosPromise<TokenResponseGet> {
            return localVarFp.danglIdentityLoginAndReturnToken(tokenLoginPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginPost} loginPost 
         * @param {string} [redirectUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityLoginWithCookie(loginPost: LoginPost, redirectUrl?: string, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityLoginWithCookie(loginPost, redirectUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenRefreshPost} tokenRefreshPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRefreshToken(tokenRefreshPost: TokenRefreshPost, options?: any): AxiosPromise<TokenResponseGet> {
            return localVarFp.danglIdentityRefreshToken(tokenRefreshPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterPost} registerPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRegister(registerPost: RegisterPost, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityRegister(registerPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordPost} forgotPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentityRequestPasswordReset(forgotPasswordPost: ForgotPasswordPost, options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentityRequestPasswordReset(forgotPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        danglIdentitySignOutWithSignInManager(options?: any): AxiosPromise<void> {
            return localVarFp.danglIdentitySignOutWithSignInManager(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DanglIdentityApi - object-oriented interface
 * @export
 * @class DanglIdentityApi
 * @extends {BaseAPI}
 */
export class DanglIdentityApi extends BaseAPI {
    /**
     * 
     * @param {TokenLoginPost} tokenLoginPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityLoginAndReturnToken(tokenLoginPost: TokenLoginPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityLoginAndReturnToken(tokenLoginPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginPost} loginPost 
     * @param {string} [redirectUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityLoginWithCookie(loginPost: LoginPost, redirectUrl?: string, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityLoginWithCookie(loginPost, redirectUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenRefreshPost} tokenRefreshPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRefreshToken(tokenRefreshPost: TokenRefreshPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRefreshToken(tokenRefreshPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterPost} registerPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRegister(registerPost: RegisterPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRegister(registerPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordPost} forgotPasswordPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentityRequestPasswordReset(forgotPasswordPost: ForgotPasswordPost, options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentityRequestPasswordReset(forgotPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DanglIdentityApi
     */
    public danglIdentitySignOutWithSignInManager(options?: AxiosRequestConfig) {
        return DanglIdentityApiFp(this.configuration).danglIdentitySignOutWithSignInManager(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDeleteDocument: async (projectId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsDeleteDocument', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsDeleteDocument', 'documentId', documentId)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDownloadDocument: async (projectId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsDownloadDocument', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsDownloadDocument', 'documentId', documentId)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}/content`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGetAllDocumentsForProject: async (projectId: string, filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsGetAllDocumentsForProject', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}/documents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (thenSort !== undefined) {
                localVarQueryParameter['thenSort'] = thenSort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGetDocumentById: async (projectId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsGetDocumentById', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsGetDocumentById', 'documentId', documentId)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMarkDocumentContentAsUploaded: async (projectId: string, documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsMarkDocumentContentAsUploaded', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsMarkDocumentContentAsUploaded', 'documentId', documentId)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}/content-status`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {DocumentContentPreparationPost} documentContentPreparationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPrepareDocumentUploadViaStorageProvider: async (projectId: string, documentId: string, documentContentPreparationPost: DocumentContentPreparationPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsPrepareDocumentUploadViaStorageProvider', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsPrepareDocumentUploadViaStorageProvider', 'documentId', documentId)
            // verify required parameter 'documentContentPreparationPost' is not null or undefined
            assertParamExists('documentsPrepareDocumentUploadViaStorageProvider', 'documentContentPreparationPost', documentContentPreparationPost)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}/content-preparation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentContentPreparationPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {File} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadDocumentContent: async (projectId: string, documentId: string, document?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsUploadDocumentContent', 'projectId', projectId)
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('documentsUploadDocumentContent', 'documentId', documentId)
            const localVarPath = `/api/projects/{projectId}/documents/{documentId}/content`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


            if (document !== undefined) { 
                localVarFormParams.append('document', document as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {DocumentPost} documentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadDocumentMetadataForProject: async (projectId: string, documentPost: DocumentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('documentsUploadDocumentMetadataForProject', 'projectId', projectId)
            // verify required parameter 'documentPost' is not null or undefined
            assertParamExists('documentsUploadDocumentMetadataForProject', 'documentPost', documentPost)
            const localVarPath = `/api/projects/{projectId}/documents`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDeleteDocument(projectId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDeleteDocument(projectId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsDownloadDocument(projectId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsDownloadDocument(projectId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsGetAllDocumentsForProject(projectId: string, filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationResultOfDocumentGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsGetAllDocumentsForProject(projectId, filter, sort, thenSort, pageSize, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsGetDocumentById(projectId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsGetDocumentById(projectId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsMarkDocumentContentAsUploaded(projectId: string, documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentPreparationPost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsMarkDocumentContentAsUploaded(projectId, documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {DocumentContentPreparationPost} documentContentPreparationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsPrepareDocumentUploadViaStorageProvider(projectId: string, documentId: string, documentContentPreparationPost: DocumentContentPreparationPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentContentSasUploadResultGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsPrepareDocumentUploadViaStorageProvider(projectId, documentId, documentContentPreparationPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {File} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsUploadDocumentContent(projectId: string, documentId: string, document?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsUploadDocumentContent(projectId, documentId, document, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {DocumentPost} documentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentsUploadDocumentMetadataForProject(projectId: string, documentPost: DocumentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentsUploadDocumentMetadataForProject(projectId, documentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDeleteDocument(projectId: string, documentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.documentsDeleteDocument(projectId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsDownloadDocument(projectId: string, documentId: string, options?: any): AxiosPromise<File> {
            return localVarFp.documentsDownloadDocument(projectId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGetAllDocumentsForProject(projectId: string, filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: any): AxiosPromise<PaginationResultOfDocumentGet> {
            return localVarFp.documentsGetAllDocumentsForProject(projectId, filter, sort, thenSort, pageSize, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsGetDocumentById(projectId: string, documentId: string, options?: any): AxiosPromise<DocumentGet> {
            return localVarFp.documentsGetDocumentById(projectId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsMarkDocumentContentAsUploaded(projectId: string, documentId: string, options?: any): AxiosPromise<DocumentContentPreparationPost> {
            return localVarFp.documentsMarkDocumentContentAsUploaded(projectId, documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {DocumentContentPreparationPost} documentContentPreparationPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsPrepareDocumentUploadViaStorageProvider(projectId: string, documentId: string, documentContentPreparationPost: DocumentContentPreparationPost, options?: any): AxiosPromise<DocumentContentSasUploadResultGet> {
            return localVarFp.documentsPrepareDocumentUploadViaStorageProvider(projectId, documentId, documentContentPreparationPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {string} documentId 
         * @param {File} [document] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadDocumentContent(projectId: string, documentId: string, document?: File, options?: any): AxiosPromise<DocumentGet> {
            return localVarFp.documentsUploadDocumentContent(projectId, documentId, document, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {DocumentPost} documentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentsUploadDocumentMetadataForProject(projectId: string, documentPost: DocumentPost, options?: any): AxiosPromise<DocumentGet> {
            return localVarFp.documentsUploadDocumentMetadataForProject(projectId, documentPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI {
    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDeleteDocument(projectId: string, documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDeleteDocument(projectId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsDownloadDocument(projectId: string, documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsDownloadDocument(projectId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} [filter] 
     * @param {string} [sort] sort
     * @param {string} [thenSort] then sort
     * @param {number} [pageSize] page size
     * @param {number} [page] page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsGetAllDocumentsForProject(projectId: string, filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsGetAllDocumentsForProject(projectId, filter, sort, thenSort, pageSize, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsGetDocumentById(projectId: string, documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsGetDocumentById(projectId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsMarkDocumentContentAsUploaded(projectId: string, documentId: string, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsMarkDocumentContentAsUploaded(projectId, documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {DocumentContentPreparationPost} documentContentPreparationPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsPrepareDocumentUploadViaStorageProvider(projectId: string, documentId: string, documentContentPreparationPost: DocumentContentPreparationPost, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsPrepareDocumentUploadViaStorageProvider(projectId, documentId, documentContentPreparationPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {string} documentId 
     * @param {File} [document] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsUploadDocumentContent(projectId: string, documentId: string, document?: File, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsUploadDocumentContent(projectId, documentId, document, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {DocumentPost} documentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public documentsUploadDocumentMetadataForProject(projectId: string, documentPost: DocumentPost, options?: AxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).documentsUploadDocumentMetadataForProject(projectId, documentPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FrontendConfigApi - axios parameter creator
 * @export
 */
export const FrontendConfigApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontendConfigGetFrontendConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/frontend-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontendConfigGetFrontendConfigScript: async (timestamp?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/frontend-config/config.js`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontendConfigApi - functional programming interface
 * @export
 */
export const FrontendConfigApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontendConfigApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontendConfigGetFrontendConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontendConfigGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontendConfigGetFrontendConfig(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async frontendConfigGetFrontendConfigScript(timestamp?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.frontendConfigGetFrontendConfigScript(timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FrontendConfigApi - factory interface
 * @export
 */
export const FrontendConfigApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontendConfigApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontendConfigGetFrontendConfig(options?: any): AxiosPromise<FrontendConfigGet> {
            return localVarFp.frontendConfigGetFrontendConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [timestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        frontendConfigGetFrontendConfigScript(timestamp?: string, options?: any): AxiosPromise<File> {
            return localVarFp.frontendConfigGetFrontendConfigScript(timestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrontendConfigApi - object-oriented interface
 * @export
 * @class FrontendConfigApi
 * @extends {BaseAPI}
 */
export class FrontendConfigApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendConfigApi
     */
    public frontendConfigGetFrontendConfig(options?: AxiosRequestConfig) {
        return FrontendConfigApiFp(this.configuration).frontendConfigGetFrontendConfig(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [timestamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontendConfigApi
     */
    public frontendConfigGetFrontendConfigScript(timestamp?: string, options?: AxiosRequestConfig) {
        return FrontendConfigApiFp(this.configuration).frontendConfigGetFrontendConfigScript(timestamp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenCdeDownloadApi - axios parameter creator
 * @export
 */
export const OpenCdeDownloadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SelectDocuments} selectDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadGetDocumentDiscoveryData: async (selectDocuments: SelectDocuments, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'selectDocuments' is not null or undefined
            assertParamExists('openCdeDownloadGetDocumentDiscoveryData', 'selectDocuments', selectDocuments)
            const localVarPath = `/api/opencde/1.0/select-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(selectDocuments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdeDownloadApi - functional programming interface
 * @export
 */
export const OpenCdeDownloadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdeDownloadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SelectDocuments} selectDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadGetDocumentDiscoveryData(selectDocuments: SelectDocuments, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentDiscoverySessionInitialization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadGetDocumentDiscoveryData(selectDocuments, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenCdeDownloadApi - factory interface
 * @export
 */
export const OpenCdeDownloadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdeDownloadApiFp(configuration)
    return {
        /**
         * 
         * @param {SelectDocuments} selectDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadGetDocumentDiscoveryData(selectDocuments: SelectDocuments, options?: any): AxiosPromise<DocumentDiscoverySessionInitialization> {
            return localVarFp.openCdeDownloadGetDocumentDiscoveryData(selectDocuments, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdeDownloadApi - object-oriented interface
 * @export
 * @class OpenCdeDownloadApi
 * @extends {BaseAPI}
 */
export class OpenCdeDownloadApi extends BaseAPI {
    /**
     * 
     * @param {SelectDocuments} selectDocuments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadApi
     */
    public openCdeDownloadGetDocumentDiscoveryData(selectDocuments: SelectDocuments, options?: AxiosRequestConfig) {
        return OpenCdeDownloadApiFp(this.configuration).openCdeDownloadGetDocumentDiscoveryData(selectDocuments, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenCdeDownloadIntegrationApi - axios parameter creator
 * @export
 */
export const OpenCdeDownloadIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentMetadata: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationGetDocumentMetadata', 'documentId', documentId)
            const localVarPath = `/api/open-cde-integration/download/documents/{documentId}/metadata`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentReference: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationGetDocumentReference', 'documentId', documentId)
            const localVarPath = `/api/open-cde-integration/download/documents/{documentId}/reference`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSelectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentSelectionData: async (documentSelectionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSelectionId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationGetDocumentSelectionData', 'documentSelectionId', documentSelectionId)
            const localVarPath = `/api/open-cde-integration/download/document-selections/{documentSelectionId}`
                .replace(`{${"documentSelectionId"}}`, encodeURIComponent(String(documentSelectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentVersions: async (documentId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationGetDocumentVersions', 'documentId', documentId)
            const localVarPath = `/api/open-cde-integration/download/documents/{documentId}/versions`
                .replace(`{${"documentId"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData: async (documentSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData', 'documentSessionId', documentSessionId)
            const localVarPath = `/api/open-cde-integration/download/sessions/{documentSessionId}/simple-auth`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {DocumentSelectionPost} documentSelectionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationSetDocumentSelection: async (documentSessionId: string, documentSelectionPost: DocumentSelectionPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationSetDocumentSelection', 'documentSessionId', documentSessionId)
            // verify required parameter 'documentSelectionPost' is not null or undefined
            assertParamExists('openCdeDownloadIntegrationSetDocumentSelection', 'documentSelectionPost', documentSelectionPost)
            const localVarPath = `/api/open-cde-integration/download/sessions/{documentSessionId}/document-selection`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSelectionPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdeDownloadIntegrationApi - functional programming interface
 * @export
 */
export const OpenCdeDownloadIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdeDownloadIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationGetDocumentMetadata(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationGetDocumentMetadata(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationGetDocumentReference(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectedDocuments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationGetDocumentReference(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSelectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationGetDocumentVersions(documentId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersions>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationGetDocumentVersions(documentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {DocumentSelectionPost} documentSelectionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeDownloadIntegrationSetDocumentSelection(documentSessionId: string, documentSelectionPost: DocumentSelectionPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSelectionGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeDownloadIntegrationSetDocumentSelection(documentSessionId, documentSelectionPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenCdeDownloadIntegrationApi - factory interface
 * @export
 */
export const OpenCdeDownloadIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdeDownloadIntegrationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentMetadata(documentId: string, options?: any): AxiosPromise<DocumentMetadata> {
            return localVarFp.openCdeDownloadIntegrationGetDocumentMetadata(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentReference(documentId: string, options?: any): AxiosPromise<SelectedDocuments> {
            return localVarFp.openCdeDownloadIntegrationGetDocumentReference(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSelectionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId: string, options?: any): AxiosPromise<DocumentVersion> {
            return localVarFp.openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDocumentVersions(documentId: string, options?: any): AxiosPromise<DocumentVersions> {
            return localVarFp.openCdeDownloadIntegrationGetDocumentVersions(documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId: string, options?: any): AxiosPromise<SimpleAuthToken> {
            return localVarFp.openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {DocumentSelectionPost} documentSelectionPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeDownloadIntegrationSetDocumentSelection(documentSessionId: string, documentSelectionPost: DocumentSelectionPost, options?: any): AxiosPromise<DocumentSelectionGet> {
            return localVarFp.openCdeDownloadIntegrationSetDocumentSelection(documentSessionId, documentSelectionPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdeDownloadIntegrationApi - object-oriented interface
 * @export
 * @class OpenCdeDownloadIntegrationApi
 * @extends {BaseAPI}
 */
export class OpenCdeDownloadIntegrationApi extends BaseAPI {
    /**
     * 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationGetDocumentMetadata(documentId: string, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationGetDocumentMetadata(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationGetDocumentReference(documentId: string, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationGetDocumentReference(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSelectionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId: string, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationGetDocumentSelectionData(documentSelectionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationGetDocumentVersions(documentId: string, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationGetDocumentVersions(documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId: string, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationGetDownloadSessionSimpleAuthData(documentSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {DocumentSelectionPost} documentSelectionPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeDownloadIntegrationApi
     */
    public openCdeDownloadIntegrationSetDocumentSelection(documentSessionId: string, documentSelectionPost: DocumentSelectionPost, options?: AxiosRequestConfig) {
        return OpenCdeDownloadIntegrationApiFp(this.configuration).openCdeDownloadIntegrationSetDocumentSelection(documentSessionId, documentSelectionPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenCdeQueryApi - axios parameter creator
 * @export
 */
export const OpenCdeQueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DocumentQuery} documentQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeQueryQueryLatestDocumentVersions: async (documentQuery: DocumentQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentQuery' is not null or undefined
            assertParamExists('openCdeQueryQueryLatestDocumentVersions', 'documentQuery', documentQuery)
            const localVarPath = `/api/opencde/1.0/document-versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdeQueryApi - functional programming interface
 * @export
 */
export const OpenCdeQueryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdeQueryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DocumentQuery} documentQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeQueryQueryLatestDocumentVersions(documentQuery: DocumentQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentDiscoverySessionInitialization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeQueryQueryLatestDocumentVersions(documentQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenCdeQueryApi - factory interface
 * @export
 */
export const OpenCdeQueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdeQueryApiFp(configuration)
    return {
        /**
         * 
         * @param {DocumentQuery} documentQuery 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeQueryQueryLatestDocumentVersions(documentQuery: DocumentQuery, options?: any): AxiosPromise<DocumentDiscoverySessionInitialization> {
            return localVarFp.openCdeQueryQueryLatestDocumentVersions(documentQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdeQueryApi - object-oriented interface
 * @export
 * @class OpenCdeQueryApi
 * @extends {BaseAPI}
 */
export class OpenCdeQueryApi extends BaseAPI {
    /**
     * 
     * @param {DocumentQuery} documentQuery 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeQueryApi
     */
    public openCdeQueryQueryLatestDocumentVersions(documentQuery: DocumentQuery, options?: AxiosRequestConfig) {
        return OpenCdeQueryApiFp(this.configuration).openCdeQueryQueryLatestDocumentVersions(documentQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenCdeUploadApi - axios parameter creator
 * @export
 */
export const OpenCdeUploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UploadDocuments} uploadDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadGetDocumentDiscoveryData: async (uploadDocuments: UploadDocuments, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadDocuments' is not null or undefined
            assertParamExists('openCdeUploadGetDocumentDiscoveryData', 'uploadDocuments', uploadDocuments)
            const localVarPath = `/api/opencde/1.0/upload-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadDocuments, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdeUploadApi - functional programming interface
 * @export
 */
export const OpenCdeUploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdeUploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UploadDocuments} uploadDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadGetDocumentDiscoveryData(uploadDocuments: UploadDocuments, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentUploadSessionInitialization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadGetDocumentDiscoveryData(uploadDocuments, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenCdeUploadApi - factory interface
 * @export
 */
export const OpenCdeUploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdeUploadApiFp(configuration)
    return {
        /**
         * 
         * @param {UploadDocuments} uploadDocuments 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadGetDocumentDiscoveryData(uploadDocuments: UploadDocuments, options?: any): AxiosPromise<DocumentUploadSessionInitialization> {
            return localVarFp.openCdeUploadGetDocumentDiscoveryData(uploadDocuments, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdeUploadApi - object-oriented interface
 * @export
 * @class OpenCdeUploadApi
 * @extends {BaseAPI}
 */
export class OpenCdeUploadApi extends BaseAPI {
    /**
     * 
     * @param {UploadDocuments} uploadDocuments 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadApi
     */
    public openCdeUploadGetDocumentDiscoveryData(uploadDocuments: UploadDocuments, options?: AxiosRequestConfig) {
        return OpenCdeUploadApiFp(this.configuration).openCdeUploadGetDocumentDiscoveryData(uploadDocuments, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OpenCdeUploadIntegrationApi - axios parameter creator
 * @export
 */
export const OpenCdeUploadIntegrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadFileDetails} uploadFileDetails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationGetUploadFileDetails: async (documentSessionId: string, uploadFileDetails: UploadFileDetails, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationGetUploadFileDetails', 'documentSessionId', documentSessionId)
            // verify required parameter 'uploadFileDetails' is not null or undefined
            assertParamExists('openCdeUploadIntegrationGetUploadFileDetails', 'uploadFileDetails', uploadFileDetails)
            const localVarPath = `/api/open-cde-integration/upload/sessions/{documentSessionId}/upload-instructions`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFileDetails, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationGetUploadSessionSimpleAuthData: async (documentSessionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationGetUploadSessionSimpleAuthData', 'documentSessionId', documentSessionId)
            const localVarPath = `/api/open-cde-integration/upload/sessions/{documentSessionId}/simple-auth`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationMarkFileUploadAsCancelled: async (documentSessionId: string, sessionFileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationMarkFileUploadAsCancelled', 'documentSessionId', documentSessionId)
            // verify required parameter 'sessionFileId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationMarkFileUploadAsCancelled', 'sessionFileId', sessionFileId)
            const localVarPath = `/api/open-cde-integration/upload/sessions/{documentSessionId}/upload-cancellation/{sessionFileId}`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)))
                .replace(`{${"sessionFileId"}}`, encodeURIComponent(String(sessionFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationMarkFileUploadAsCompleted: async (documentSessionId: string, sessionFileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationMarkFileUploadAsCompleted', 'documentSessionId', documentSessionId)
            // verify required parameter 'sessionFileId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationMarkFileUploadAsCompleted', 'sessionFileId', sessionFileId)
            const localVarPath = `/api/open-cde-integration/upload/sessions/{documentSessionId}/upload-completion/{sessionFileId}`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)))
                .replace(`{${"sessionFileId"}}`, encodeURIComponent(String(sessionFileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadSessionProjectAssignmentPost} uploadSessionProjectAssignmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationSetProjectForUploadSession: async (documentSessionId: string, uploadSessionProjectAssignmentPost: UploadSessionProjectAssignmentPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSessionId' is not null or undefined
            assertParamExists('openCdeUploadIntegrationSetProjectForUploadSession', 'documentSessionId', documentSessionId)
            // verify required parameter 'uploadSessionProjectAssignmentPost' is not null or undefined
            assertParamExists('openCdeUploadIntegrationSetProjectForUploadSession', 'uploadSessionProjectAssignmentPost', uploadSessionProjectAssignmentPost)
            const localVarPath = `/api/open-cde-integration/upload/sessions/{documentSessionId}/project`
                .replace(`{${"documentSessionId"}}`, encodeURIComponent(String(documentSessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadSessionProjectAssignmentPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OpenCdeUploadIntegrationApi - functional programming interface
 * @export
 */
export const OpenCdeUploadIntegrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OpenCdeUploadIntegrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadFileDetails} uploadFileDetails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadIntegrationGetUploadFileDetails(documentSessionId: string, uploadFileDetails: UploadFileDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentsToUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadIntegrationGetUploadFileDetails(documentSessionId, uploadFileDetails, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SimpleAuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId: string, sessionFileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId, sessionFileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId: string, sessionFileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId, sessionFileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadSessionProjectAssignmentPost} uploadSessionProjectAssignmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId: string, uploadSessionProjectAssignmentPost: UploadSessionProjectAssignmentPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadSessionProjectAssignmentResultGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId, uploadSessionProjectAssignmentPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OpenCdeUploadIntegrationApi - factory interface
 * @export
 */
export const OpenCdeUploadIntegrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OpenCdeUploadIntegrationApiFp(configuration)
    return {
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadFileDetails} uploadFileDetails 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationGetUploadFileDetails(documentSessionId: string, uploadFileDetails: UploadFileDetails, options?: any): AxiosPromise<DocumentsToUpload> {
            return localVarFp.openCdeUploadIntegrationGetUploadFileDetails(documentSessionId, uploadFileDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId: string, options?: any): AxiosPromise<SimpleAuthToken> {
            return localVarFp.openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId: string, sessionFileId: string, options?: any): AxiosPromise<void> {
            return localVarFp.openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId, sessionFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {string} sessionFileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId: string, sessionFileId: string, options?: any): AxiosPromise<DocumentVersion> {
            return localVarFp.openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId, sessionFileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} documentSessionId 
         * @param {UploadSessionProjectAssignmentPost} uploadSessionProjectAssignmentPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId: string, uploadSessionProjectAssignmentPost: UploadSessionProjectAssignmentPost, options?: any): AxiosPromise<UploadSessionProjectAssignmentResultGet> {
            return localVarFp.openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId, uploadSessionProjectAssignmentPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OpenCdeUploadIntegrationApi - object-oriented interface
 * @export
 * @class OpenCdeUploadIntegrationApi
 * @extends {BaseAPI}
 */
export class OpenCdeUploadIntegrationApi extends BaseAPI {
    /**
     * 
     * @param {string} documentSessionId 
     * @param {UploadFileDetails} uploadFileDetails 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadIntegrationApi
     */
    public openCdeUploadIntegrationGetUploadFileDetails(documentSessionId: string, uploadFileDetails: UploadFileDetails, options?: AxiosRequestConfig) {
        return OpenCdeUploadIntegrationApiFp(this.configuration).openCdeUploadIntegrationGetUploadFileDetails(documentSessionId, uploadFileDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadIntegrationApi
     */
    public openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId: string, options?: AxiosRequestConfig) {
        return OpenCdeUploadIntegrationApiFp(this.configuration).openCdeUploadIntegrationGetUploadSessionSimpleAuthData(documentSessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {string} sessionFileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadIntegrationApi
     */
    public openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId: string, sessionFileId: string, options?: AxiosRequestConfig) {
        return OpenCdeUploadIntegrationApiFp(this.configuration).openCdeUploadIntegrationMarkFileUploadAsCancelled(documentSessionId, sessionFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {string} sessionFileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadIntegrationApi
     */
    public openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId: string, sessionFileId: string, options?: AxiosRequestConfig) {
        return OpenCdeUploadIntegrationApiFp(this.configuration).openCdeUploadIntegrationMarkFileUploadAsCompleted(documentSessionId, sessionFileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} documentSessionId 
     * @param {UploadSessionProjectAssignmentPost} uploadSessionProjectAssignmentPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenCdeUploadIntegrationApi
     */
    public openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId: string, uploadSessionProjectAssignmentPost: UploadSessionProjectAssignmentPost, options?: AxiosRequestConfig) {
        return OpenCdeUploadIntegrationApiFp(this.configuration).openCdeUploadIntegrationSetProjectForUploadSession(documentSessionId, uploadSessionProjectAssignmentPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreateProject: async (projectPost: ProjectPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPost' is not null or undefined
            assertParamExists('projectsCreateProject', 'projectPost', projectPost)
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAllProjects: async (filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (thenSort !== undefined) {
                localVarQueryParameter['thenSort'] = thenSort;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectById: async (projectId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsGetProjectById', 'projectId', projectId)
            const localVarPath = `/api/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsCreateProject(projectPost: ProjectPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsCreateProject(projectPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetAllProjects(filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginationResultOfProjectGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetAllProjects(filter, sort, thenSort, pageSize, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGetProjectById(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGetProjectById(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * 
         * @param {ProjectPost} projectPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsCreateProject(projectPost: ProjectPost, options?: any): AxiosPromise<ProjectGet> {
            return localVarFp.projectsCreateProject(projectPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [filter] 
         * @param {string} [sort] sort
         * @param {string} [thenSort] then sort
         * @param {number} [pageSize] page size
         * @param {number} [page] page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetAllProjects(filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: any): AxiosPromise<PaginationResultOfProjectGet> {
            return localVarFp.projectsGetAllProjects(filter, sort, thenSort, pageSize, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGetProjectById(projectId: string, options?: any): AxiosPromise<ProjectGet> {
            return localVarFp.projectsGetProjectById(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * 
     * @param {ProjectPost} projectPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsCreateProject(projectPost: ProjectPost, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsCreateProject(projectPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [filter] 
     * @param {string} [sort] sort
     * @param {string} [thenSort] then sort
     * @param {number} [pageSize] page size
     * @param {number} [page] page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsGetAllProjects(filter?: string, sort?: string, thenSort?: string, pageSize?: number, page?: number, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGetAllProjects(filter, sort, thenSort, pageSize, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsGetProjectById(projectId: string, options?: AxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGetProjectById(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGetStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGetStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGetStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGetStatus(options?: any): AxiosPromise<StatusGet> {
            return localVarFp.statusGetStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGetStatus(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).statusGetStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsGetApiVersions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/foundation/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Dangl.Identity required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "Dangl.Identity", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionsGetApiVersions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionsGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionsGetApiVersions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsGetApiVersions(options?: any): AxiosPromise<VersionsGet> {
            return localVarFp.versionsGetApiVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public versionsGetApiVersions(options?: AxiosRequestConfig) {
        return VersionsApiFp(this.configuration).versionsGetApiVersions(options).then((request) => request(this.axios, this.basePath));
    }
}


